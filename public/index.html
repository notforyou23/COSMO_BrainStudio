<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Standalone Documentation IDE</title>
    
    <!-- External Dependencies -->
    <!-- NOTE: This page has a large inline stylesheet below. We intentionally do NOT load `css/styles.css`
         because it contains an older layout (grid-based) that can conflict with this IDE layout and break scrolling. -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #2d2d30;
            --border-color: #3e3e42;
            --text-primary: #cccccc;
            --text-secondary: #969696;
            --text-active: #ffffff;
            --accent-primary: #007acc;
            --accent-hover: #1177bb;
            --success-color: #10b981;
            --error-color: #ef4444;
            --warning-color: #f0883e;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: var(--bg-primary);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
        }

        .ide-container {
            display: flex;
            flex-direction: column;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Header */
        .ide-header {
            height: 48px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            justify-content: space-between;
            z-index: 100;
        }

        .ide-title {
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .system-info {
            font-size: 12px;
            color: var(--text-secondary);
            margin-left: 8px;
        }
        
        .system-picker {
            background: var(--border-color);
            border: 1px solid #5a5a5a;
            color: var(--text-primary);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            max-width: 300px;
            transition: background 0.2s;
        }
        
        .system-picker:hover {
            background: #505050;
        }

        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .header-group {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0 10px;
            border-right: 1px solid var(--border-color);
            height: 32px;
        }

        .header-group:last-child {
            border-right: none;
        }

        .header-group-label {
            font-size: 9px;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-right: 4px;
            opacity: 0.7;
            font-weight: 700;
            user-select: none;
        }

        .tab-btn {
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            height: 100%;
        }

        .tab-btn:hover {
            color: var(--text-primary);
            background: rgba(255,255,255,0.05);
        }

        .tab-btn.active {
            border-bottom: 2px solid var(--accent-primary);
            color: var(--accent-primary);
        }

        .tab-btn.agent-ide-tab {
            font-weight: 700;
            background: rgba(0, 122, 204, 0.1);
            border-radius: 4px 4px 0 0;
            border-bottom: 2px solid transparent;
            color: #ccc;
        }

        .tab-btn.agent-ide-tab.active {
            background: rgba(0, 122, 204, 0.2);
            color: #00aaff;
            border-bottom-color: #00aaff;
        }

        .btn {
            background: #0e639c;
            border: none;
            color: white;
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover:not(:disabled) {
            background: var(--accent-hover);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .btn-icon {
            padding: 6px 8px;
            font-size: 14px;
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            justify-content: center;
        }

        .btn-icon:hover:not(:disabled) {
            background: var(--bg-hover);
            border-color: var(--border-color);
            color: var(--text-primary);
        }

        .btn-icon.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        /* Body */
        .ide-body {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-height: 0;
            /* Using flex: 1 and min-height: 0 instead of height: 0 for broader compatibility */
        }

        /* Sidebar - Professional resizable panel */
        .sidebar {
            width: 280px;
            flex: 0 0 auto;
            min-width: 150px; /* Allow smaller sidebar */
            max-width: 800px; /* Allow larger sidebar */
            min-height: 0; /* Critical for flex scrolling */
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: none; /* Disable transition during resize */
            position: relative;
        }

        .sidebar.collapsed {
            width: 0 !important;
            min-width: 0 !important;
            padding: 0;
            overflow: hidden;
            border-right: none;
        }
        
        .sidebar.collapsed * {
            opacity: 0;
            pointer-events: none;
        }
        
        .sidebar.collapsed .resize-handle {
            display: none;
        }
        
        /* Sidebar expand button - shown when sidebar is collapsed */
        .sidebar-expand-btn {
            position: absolute;
            left: 0;
            top: 60px;
            width: 24px;
            height: 48px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-left: none;
            border-radius: 0 6px 6px 0;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, width 0.2s;
        }
        
        .sidebar-expand-btn:hover {
            background: var(--accent-primary);
            width: 32px;
        }

        /* Resize handles - Make visible and functional */
        .resize-handle {
            position: absolute;
            background: transparent;
            z-index: 1000;
            transition: background 0.2s, box-shadow 0.2s;
        }

        .resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 48px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .resize-handle:hover {
            background: rgba(0, 122, 204, 0.15);
        }

        .resize-handle:hover::after {
            opacity: 1;
            background: rgba(0, 122, 204, 0.6);
        }

        .resize-handle.active {
            background: rgba(0, 122, 204, 0.25);
        }

        .resize-handle.active::after {
            opacity: 1;
            background: var(--accent-primary);
            height: 100%;
            width: 2px;
        }

        .resize-handle-vertical {
            width: 10px; /* Wider hit area */
            top: 0;
            bottom: 0;
            cursor: col-resize;
            -webkit-user-select: none;
            user-select: none;
        }

        .sidebar .resize-handle-vertical {
            right: -5px;
        }

        .preview-pane .resize-handle-vertical {
            left: -5px;
        }

        .ai-panel .resize-handle-vertical {
            left: -5px;
        }

        .sidebar-header {
            padding: 12px 16px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-tree {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px 0;
            user-select: none;
            min-height: 0; /* Critical for flex scrolling */
        }

        .file-tree::-webkit-scrollbar {
            width: 8px;
        }

        .file-tree::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .tree-item {
            display: block;
        }

        .file-item, .folder-item {
            padding: 4px 12px 4px 8px;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background 0.15s;
            white-space: nowrap;
        }

        .file-item:hover, .folder-item:hover {
            background: #2a2d2e;
        }

        .file-item.active {
            background: #37373d;
            color: var(--text-active);
        }

        .folder-item {
            font-weight: 500;
        }

        .folder-chevron {
            font-size: 10px;
            color: var(--text-secondary);
            transition: transform 0.2s;
            width: 12px;
            text-align: center;
        }

        .folder-chevron.expanded {
            transform: rotate(90deg);
        }

        .folder-icon, .file-icon {
            font-size: 14px;
        }

        .file-icon {
            margin-left: 18px;
        }

        .folder-contents {
            padding-left: 16px;
        }

        .folder-contents.collapsed {
            display: none;
        }

        /* Editor Container - Flexible sizing */
        .editor-container {
            flex: 1;
            min-width: 150px; /* Allow editor to be much smaller */
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            position: relative;
            overflow: hidden;
            min-height: 0; /* Critical for nested flex scrolling */
        }

        /* Tabs Bar */
        .tabs-bar {
            height: 35px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            overflow-x: auto;
        }

        .tabs-bar::-webkit-scrollbar {
            height: 3px;
        }

        .tabs-bar::-webkit-scrollbar-thumb {
            background: var(--border-color);
        }

        /* Breadcrumb Bar */
        .breadcrumb-bar {
            user-select: none;
        }

        .breadcrumb-bar::-webkit-scrollbar {
            height: 3px;
        }

        .breadcrumb-bar::-webkit-scrollbar-thumb {
            background: var(--border-color);
        }

        .breadcrumb-item {
            display: inline-block;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background 0.15s, color 0.15s;
        }

        .breadcrumb-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .breadcrumb-item.active {
            color: var(--text-active);
            font-weight: 500;
        }

        .breadcrumb-separator {
            display: inline-block;
            margin: 0 6px;
            color: var(--text-secondary);
            font-size: 10px;
        }

        .tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-right: 1px solid var(--border-color);
            color: var(--text-secondary);
            cursor: pointer;
            white-space: nowrap;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.15s, color 0.15s;
            max-width: 200px;
        }

        .tab:hover {
            background: #2a2d2e;
            color: var(--text-primary);
        }

        .tab.active {
            background: var(--bg-primary);
            color: var(--text-active);
        }

        .tab.pinned {
            background: var(--bg-secondary);
            border-left: 2px solid #0e639c;
        }

        .tab.pinned.active {
            background: var(--bg-primary);
        }

        .tab.dragging {
            opacity: 0.5;
        }

        .tab.drag-over {
            border-left: 2px solid #0e639c;
        }

        .tab-pin {
            opacity: 0;
            margin-right: 4px;
            font-size: 12px;
            line-height: 1;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .tab:hover .tab-pin {
            opacity: 0.6;
        }

        .tab-pin:hover {
            opacity: 1;
        }

        .tab.pinned .tab-pin {
            opacity: 0.8;
        }

        .tab-close {
            opacity: 0;
            margin-left: 4px;
            font-size: 16px;
            line-height: 1;
            transition: opacity 0.2s;
        }

        .tab:hover .tab-close {
            opacity: 0.6;
        }

        .tab-close:hover {
            opacity: 1;
        }

        /* Split View */
        .editor-split-container {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-width: 0;
            min-height: 0;
        }

        .editor-pane {
            flex: 1 1 0;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-height: 0;
        }

        /* Preview Pane - Professional resizable panel */
        .preview-pane {
            width: 400px;
            flex: 0 0 auto;
            min-width: 200px; /* Allow smaller preview */
            max-width: 1200px; /* Allow larger preview */
            background: var(--bg-primary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            min-height: 0; /* Critical for nested flex scrolling */
        }

        .preview-pane.hidden {
            display: none;
        }

        /* Resize handle position already defined above */

        .preview-header {
            height: 35px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            font-weight: 600;
        }

        .preview-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            color: var(--text-primary);
            min-height: 0; /* Critical for flex scrolling */
        }

        .preview-content h1, .preview-content h2, .preview-content h3 {
            color: var(--text-active);
            margin-top: 24px;
            margin-bottom: 12px;
        }

        .preview-content h1 { font-size: 28px; }
        .preview-content h2 { font-size: 22px; }
        .preview-content h3 { font-size: 18px; }

        .preview-content p {
            margin-bottom: 12px;
            line-height: 1.6;
        }

        .preview-content code {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .preview-content pre {
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 12px 0;
        }

        .preview-content pre code {
            background: none;
            padding: 0;
        }

        /* AI Chat Panel - Professional resizable panel */
        /* Modern AI Panel Overhaul */
        .ai-panel {
            width: 400px;
            flex: 0 0 auto;
            min-width: 250px;
            max-width: 1600px;
            min-height: 0;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .ai-panel.hidden {
            display: none;
        }

        .ai-header {
            height: 40px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 0 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            user-select: none;
        }

        .ai-chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            background: var(--bg-primary);
        }

        .ai-message {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 100%;
            animation: fadeIn 0.3s ease-out;
        }

        .ai-message.assistant {
            background: transparent;
            padding: 0;
            border: none;
            box-shadow: none;
        }

        .ai-message.user {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            align-self: flex-start;
            width: 100%;
        }

        .ai-message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .ai-message.assistant .ai-message-header {
            color: var(--accent-primary);
        }

        .ai-message.user .ai-message-header {
            color: var(--text-secondary);
        }

        .ai-message-content {
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-primary);
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .ai-message.assistant .ai-message-content {
            font-size: 14px;
            line-height: 1.6;
        }

        /* Modern Code Blocks in Chat */
        .ai-message.assistant pre {
            background: #121212;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
            overflow-x: auto;
            position: relative;
        }

        .ai-message.assistant code {
            font-family: var(--font-mono, monospace);
            font-size: 13px;
            color: #e0e0e0;
        }

        /* System/Tool Messages - Minimalist */
        .ai-message.system, .ai-message.tool-feedback {
            background: rgba(255, 255, 255, 0.02);
            border-left: 2px solid var(--accent-primary);
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            opacity: 0.8;
        }

        .ai-message.system .ai-message-content, 
        .ai-message.tool-feedback .ai-message-content {
            font-size: 12px;
            font-family: var(--font-mono, monospace);
            color: var(--text-secondary);
        }

        .ai-message.system.thinking {
            border-left-color: #6a6a6a;
            font-style: italic;
        }

        .ai-message.system.tool-success {
            border-left-color: var(--success-color);
        }

        .ai-message.system.tool-error {
            border-left-color: var(--error-color);
        }

        /* Input Area - Modern Float */
        .ai-input-container {
            padding: 16px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }

        .ai-input-wrapper {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            transition: border-color 0.2s;
        }

        .ai-input-wrapper:focus-within {
            border-color: var(--accent-primary);
        }

        #ai-input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 14px;
            font-family: inherit;
            resize: none;
            padding: 4px;
            min-height: 40px;
            max-height: 200px;
            outline: none;
        }
        
        /* AI Details Container - Smaller, subtle, collapsible */
        .ai-details-container {
            background: rgba(100, 100, 100, 0.03);
            border: 1px solid rgba(100, 100, 100, 0.15);
            border-radius: 6px;
            padding: 8px 12px;
            margin: 8px 0;
            font-size: 11px;
            opacity: 0.85;
        }
        
        .ai-details-container details {
            cursor: pointer;
        }
        
        .ai-details-container summary {
            font-weight: 600;
            color: #6b7280;
            font-size: 11px;
            padding: 4px 0;
            user-select: none;
            list-style: none;
            opacity: 0.7;
        }
        
        .ai-details-container summary:hover {
            opacity: 1;
        }
        
        .ai-details-container summary::-webkit-details-marker {
            display: none;
        }
        
        .ai-details-container summary::before {
            content: 'â–¼ ';
            display: inline-block;
            transition: transform 0.2s;
            font-size: 9px;
        }
        
        .ai-details-container details:not([open]) summary::before {
            transform: rotate(-90deg);
        }
        
        .ai-details-content {
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid rgba(100, 100, 100, 0.1);
            max-width: 100%;
            overflow: visible;
        }
        
        .thinking-item, .tool-item {
            padding: 4px 6px;
            margin: 3px 0;
            border-radius: 3px;
            font-size: 11px;
            display: flex;
            align-items: flex-start;
            gap: 6px;
            max-width: 100%;
            overflow: visible;
        }
        
        .thinking-item {
            background: rgba(156, 163, 175, 0.05);
            border-left: 2px solid rgba(156, 163, 175, 0.2);
        }
        
        .thinking-icon {
            flex-shrink: 0;
            font-size: 10px;
        }
        
        .thinking-text {
            color: #6b7280;
            font-style: italic;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            flex: 1;
            min-width: 0;
        }
        
        .tool-item {
            background: rgba(138, 180, 248, 0.03);
            border-left: 2px solid rgba(138, 180, 248, 0.2);
        }
        
        .tool-item.tool-running {
            border-left-color: rgba(138, 180, 248, 0.4);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        .tool-item.tool-running .tool-status {
            color: #8ab4f8;
        }
        
        .tool-item.tool-success {
            border-left-color: rgba(129, 201, 149, 0.3);
        }
        
        .tool-item.tool-success .tool-status {
            color: #81c995;
        }
        
        .tool-item.tool-error {
            border-left-color: rgba(244, 135, 113, 0.3);
        }
        
        .tool-item.tool-error .tool-status {
            color: #f48771;
        }
        
        .tool-icon, .tool-status {
            flex-shrink: 0;
            font-size: 11px;
        }
        
        .tool-text {
            color: #6b7280;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            flex: 1;
            min-width: 0;
        }

        /* AI Chat History Modern Overhaul */
        #chat-history-panel {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            max-height: 0;
            opacity: 0;
        }

        #chat-history-panel:not(.hidden) {
            max-height: 400px;
            opacity: 1;
            box-shadow: inset 0 -10px 20px rgba(0,0,0,0.1);
        }

        .chat-history-header {
            padding: 10px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .chat-history-item {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .chat-history-item:last-child {
            border-bottom: none;
        }

        .chat-history-item:hover {
            background: var(--bg-hover);
        }

        .chat-history-item .conv-title {
            font-size: 13px;
            color: var(--text-primary);
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-history-item .conv-meta {
            font-size: 10px;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }

        #chat-history-list::-webkit-scrollbar {
            width: 4px;
        }

        #chat-history-list::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 2px;
        }

        .ai-message.assistant p {
            margin: 8px 0;
            line-height: 1.6;
        }
        
        .ai-message.assistant p:first-child {
            margin-top: 0;
        }
        
        .ai-message.assistant p:last-child {
            margin-bottom: 0;
        }

        .ai-message.assistant ul, .ai-message.assistant ol {
            margin: 10px 0;
            padding-left: 24px;
        }

        .ai-message.assistant li {
            margin: 4px 0;
            line-height: 1.5;
        }

        .ai-message.assistant h1,
        .ai-message.assistant h2,
        .ai-message.assistant h3,
        .ai-message.assistant h4 {
            margin: 20px 0 12px 0;
            color: var(--text-primary);
            font-weight: 600;
        }

        .ai-message.assistant h1 { font-size: 1.6em; }
        .ai-message.assistant h2 { font-size: 1.4em; }
        .ai-message.assistant h3 { font-size: 1.2em; }
        .ai-message.assistant h4 { font-size: 1.1em; }

        .ai-message.assistant code {
            background: rgba(255, 255, 255, 0.08);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: var(--font-mono, monospace);
            font-size: 0.9em;
            color: var(--accent-primary);
        }

        .ai-message.assistant blockquote {
            border-left: 3px solid var(--accent-primary);
            padding-left: 14px;
            margin: 16px 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        .ai-message.assistant a {
            color: var(--accent-primary);
            text-decoration: none;
        }

        .ai-message.assistant a:hover {
            text-decoration: underline;
        }

        .ai-message.assistant hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 20px 0;
        }

        .ai-message.assistant table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
        }

        .ai-message.assistant th,
        .ai-message.assistant td {
            border: 1px solid #e1e4e8;
            padding: 8px 12px;
            text-align: left;
        }

        .ai-message.assistant th {
            background: #f6f8fa;
            font-weight: 600;
        }

        .ai-message.assistant img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 12px 0;
        }

        /* Tool feedback / thinking cards */
        .ai-message.system, .ai-message.tool-feedback {
            background: linear-gradient(135deg, #fff9f0 0%, #ffffff 100%);
            border: 1.5px solid rgba(255,149,0,0.4);
            border-radius: 20px;
            padding: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 16px 50px rgba(255,149,0,0.15);
        }

        .ai-message.system::before, .ai-message.tool-feedback::before {
            content: "";
            position: absolute;
            top: 0; 
            left: -100%;
            width: 50%; 
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,149,0,0.12), transparent);
            animation: shimmer 2.5s infinite;
        }

        .ai-message.system .ai-message-header, .ai-message.tool-feedback .ai-message-header {
            color: #ff9500;
        }

        .ai-message.system .ai-message-content, .ai-message.tool-feedback .ai-message-content {
            color: #1a1a1a;
            font-family: "JetBrains Mono", ui-monospace, monospace;
            font-size: 13px;
        }

        .ai-message.error {
            background: #3d2020;
            border-radius: 12px;
            padding: 16px;
        }

        .ai-message.error .ai-message-content {
            color: var(--error-color);
        }

        @keyframes fadeUp { 
            from { 
                opacity: 0; 
                transform: translateY(30px); 
            } 
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes shimmer { 
            0% { left: -100%; } 
            100% { left: 100%; } 
        }

        .ai-message-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
        }

        .ai-quick-actions {
            padding: 12px 16px;
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }

        .ai-quick-actions-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .ai-quick-action-btn {
            display: block;
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-align: left;
            margin-bottom: 6px;
            transition: all 0.15s;
        }

        .ai-quick-action-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .ai-input-container {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }

        .ai-input {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            min-height: 60px;
            max-height: 200px;
            box-sizing: border-box;
            overflow-wrap: break-word;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .ai-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .ai-send-btn {
            margin-top: 8px;
            width: 100%;
            background: var(--accent-primary);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .ai-send-btn:hover:not(:disabled) {
            background: var(--accent-hover);
        }

        .ai-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .ai-thinking {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .ai-thinking-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Editor Wrapper */
        .editor-wrapper {
            flex: 1;
            position: relative;
            min-height: 0; /* Critical for nested flex scrolling */
        }

        #monaco-editor {
            width: 100%;
            height: 100%;
        }
        
        #monaco-diff-editor {
            width: 100%;
            height: 100%;
        }
        
        #monaco-diff-editor.hidden {
            display: none;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            font-size: 14px;
            z-index: 50;
        }

        .loading-overlay.hidden {
            display: none;
        }

        /* Command Palette */
        .command-palette {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            max-width: 90vw;
            max-height: 400px;
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-primary);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 10000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .command-palette.hidden {
            display: none;
        }

        .command-palette input {
            width: 100%;
            padding: 16px;
            background: var(--border-color);
            border: none;
            color: var(--text-primary);
            font-size: 14px;
            outline: none;
        }

        .command-results {
            flex: 1;
            overflow-y: auto;
        }

        .command-item {
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.15s;
            border-left: 3px solid transparent;
        }

        .command-item:hover, .command-item.selected {
            background: var(--bg-secondary);
            border-left-color: var(--accent-primary);
        }

        .command-label {
            font-size: 13px;
        }

        .command-keys {
            font-size: 11px;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 2px 8px;
            border-radius: 3px;
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 400px;
            height: 100vh;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s;
            box-shadow: -4px 0 12px rgba(0,0,0,0.3);
        }

        .settings-panel.open {
            transform: translateX(0);
        }

        .settings-header {
            height: 48px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
        }

        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .setting-group {
            margin-bottom: 24px;
        }

        .setting-group-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .setting-item {
            margin-bottom: 16px;
        }

        .setting-label {
            font-size: 13px;
            margin-bottom: 6px;
            display: block;
        }

        .setting-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 13px;
        }

        .setting-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .setting-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .setting-checkbox input {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Search Panel */
        .search-panel {
            position: absolute;
            top: 50px;
            right: 20px;
            width: 350px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 1000;
            padding: 12px;
        }

        .search-panel.hidden {
            display: none;
        }

        .search-input-group {
            margin-bottom: 8px;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 13px;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .search-options {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            font-size: 12px;
        }

        .search-option {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
        }

        /* Keyboard Help */
        .keyboard-help {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 700px;
            max-width: 90vw;
            max-height: 80vh;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 10000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .keyboard-help.hidden {
            display: none;
        }

        .keyboard-help-header {
            padding: 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            display: flex;
            justify-content: space-between;
        }

        .keyboard-help-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .shortcut-section {
            margin-bottom: 20px;
        }

        .shortcut-section-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 13px;
        }

        .shortcut-keys {
            color: var(--text-secondary);
            font-family: monospace;
        }

        /* Status Bar */
        .status-bar {
            height: 22px;
            background: var(--accent-primary);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 12px;
            font-size: 12px;
            justify-content: space-between;
        }

        .status-left, .status-right {
            display: flex;
            gap: 16px;
        }

        .status-item {
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .status-item:hover {
            opacity: 0.8;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 12px 20px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            font-size: 13px;
            z-index: 10001;
            animation: slideIn 0.3s ease-out;
        }

        .toast.success {
            border-left: 3px solid var(--success-color);
        }

        .toast.error {
            border-left: 3px solid var(--error-color);
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 10000;
            min-width: 180px;
            padding: 4px 0;
        }

        .context-menu.hidden {
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.15s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .context-menu-item:hover {
            background: var(--bg-secondary);
        }

        .context-menu-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .context-menu-item.disabled:hover {
            background: transparent;
        }
        
        .context-menu-item.danger {
            color: var(--error-color);
        }
        
        .context-menu-item span:first-child {
            margin-right: 8px;
        }

        .context-menu-separator {
            height: 1px;
            background: var(--border-color);
            margin: 4px 0;
        }

        /* Tooltips */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-4px);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            border: 1px solid var(--border-color);
            z-index: 10000;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
        }

        /* Overlay for modals */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
            pointer-events: auto;
            display: block;
        }

        .overlay.hidden {
            display: none !important;
            pointer-events: none !important;
        }

        /* Optimized transitions - removed universal selector which breaks performance/scrolling */
        input, select, button, .tab, .file-item, .btn, .tree-item, .node-item {
            transition: background-color 0.15s ease, color 0.15s ease, border-color 0.15s ease, opacity 0.15s ease, transform 0.15s ease;
        }

        /* Global scrollbar styles */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: #3e3e42;
            border-radius: 5px;
            border: 2px solid var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #505050;
        }

        /* ========================================================================== */
        /* EDIT QUEUE PANEL - Cursor-style edit review */
        /* ========================================================================== */
        
        .edit-queue-panel {
            position: fixed;
            right: 0;
            top: 60px;
            bottom: 0;
            width: 340px;
            background: #ffffff;
            border-left: 1px solid rgba(255,149,0,0.3);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transform: translateX(0);
            transition: transform 0.3s ease;
            box-shadow: -5px 0 30px rgba(0,0,0,0.1);
        }

        .edit-queue-panel.hidden {
            transform: translateX(100%);
        }

        .edit-queue-header {
            padding: 20px;
            background: linear-gradient(135deg, #fff9f0 0%, #ffffff 100%);
            border-bottom: 1px solid rgba(255,149,0,0.25);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .edit-queue-header h3 {
            font-size: 15px;
            font-weight: 700;
            margin: 0;
            color: #ff9500;
        }

        .edit-queue-actions {
            padding: 12px;
            display: flex;
            gap: 6px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .edit-queue-actions .btn {
            flex: 1;
            min-width: 80px;
            padding: 6px 10px;
            font-size: 11px;
        }

        .edit-queue-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .edit-item {
            background: linear-gradient(135deg, #fff9f0 0%, #ffffff 100%);
            border: 1.5px solid rgba(255,149,0,0.4);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(255,149,0,0.1);
        }

        .edit-item::before {
            content: "";
            position: absolute;
            top: 0; 
            left: -100%;
            width: 50%; 
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,149,0,0.08), transparent);
            animation: shimmer 3s infinite;
        }

        .edit-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 30px rgba(255,149,0,0.2);
            border-color: rgba(255,149,0,0.6);
        }

        .edit-item.accepted {
            border-left: 4px solid #10b981;
            opacity: 0.7;
            background: linear-gradient(135deg, #f0fdf4 0%, #ffffff 100%);
        }

        .edit-item.rejected {
            border-left: 4px solid #ef4444;
            opacity: 0.7;
            background: linear-gradient(135deg, #fef2f2 0%, #ffffff 100%);
        }

        .edit-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .edit-item-file {
            font-weight: 700;
            font-size: 13px;
            color: #ff9500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        .edit-item-status {
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 8px;
            margin-left: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .edit-item-status.pending {
            background: linear-gradient(135deg, #ff9500, #ffb84d);
            color: white;
            box-shadow: 0 2px 8px rgba(255,149,0,0.3);
        }

        .edit-item-status.accepted {
            background: linear-gradient(135deg, #10b981, #34d399);
            color: white;
            box-shadow: 0 2px 8px rgba(16,185,129,0.3);
        }

        .edit-item-status.rejected {
            background: linear-gradient(135deg, #ef4444, #f87171);
            color: white;
            box-shadow: 0 2px 8px rgba(239,68,68,0.3);
        }

        .edit-item-summary {
            font-size: 12px;
            color: #666;
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .edit-item-actions {
            display: flex;
            gap: 8px;
        }

        .edit-item-actions button {
            flex: 1;
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 10px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .edit-item-actions button:hover {
            transform: scale(1.05);
        }

        .edit-item.accepted .edit-item-actions,
        .edit-item.rejected .edit-item-actions {
            display: none;
        }
        /* Brain Studio Tab Panels */
        .brain-studio-tabs {
          flex: 1;
          overflow: hidden;
          position: relative;
          min-height: 0; /* Critical for nested flex scrolling */
        }
        .brain-tab-panel {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          overflow: hidden; /* Lock the panel itself */
          display: flex;
          flex-direction: column;
          min-height: 0;
          background: var(--bg-primary);
        }
        #files-tab-panel {
          display: flex;
          flex-direction: column;
          min-height: 0; /* Critical for nested flex scrolling */
        }

        /* Query Tab Styles */
        .query-container {
          display: flex;
          flex-direction: column;
          height: 100%;
          padding: 24px;
          overflow-y: auto;
          background: var(--bg-primary);
        }
        
        .query-input-section {
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 8px;
          padding: 20px;
          margin-bottom: 24px;
        }
        
        .query-textarea {
          width: 100%;
          min-height: 120px;
          padding: 12px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          color: var(--text-primary);
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
          font-size: 14px;
          resize: vertical;
          margin-bottom: 16px;
        }
        
        .query-options {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 16px;
          margin-bottom: 16px;
        }
        
        .option-group {
          display: flex;
          flex-direction: column;
          gap: 6px;
        }
        
        .option-group label {
          font-size: 12px;
          color: var(--text-secondary);
          font-weight: 500;
        }
        
        .query-select {
          padding: 8px 12px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          color: var(--text-primary);
          font-size: 13px;
        }
        
        .query-select-sm {
          padding: 6px 10px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          color: var(--text-primary);
          font-size: 12px;
        }
        
        .option-hint {
          font-size: 11px;
          color: var(--text-muted);
          font-style: italic;
          margin-top: 4px;
        }
        
        .query-enhancements, .query-context-options {
          display: flex;
          gap: 16px;
          margin-bottom: 12px;
          flex-wrap: wrap;
        }
        
        .query-enhancements label, .query-context-options label {
          display: flex;
          align-items: center;
          gap: 6px;
          font-size: 13px;
          color: var(--text-primary);
          cursor: pointer;
        }
        
        .query-actions {
          display: flex;
          gap: 12px;
          align-items: center;
          flex-wrap: wrap;
        }
        
        .btn-primary {
          padding: 10px 20px;
          background: var(--accent-primary);
          color: white;
          border: none;
          border-radius: 6px;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .btn-primary:hover {
          background: var(--accent-hover);
          transform: translateY(-1px);
        }
        
        .btn-secondary {
          padding: 10px 20px;
          background: var(--bg-tertiary);
          color: var(--text-primary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          font-size: 14px;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .btn-secondary:hover {
          background: var(--bg-secondary);
        }
        
        .export-controls {
          display: flex;
          align-items: center;
          gap: 8px;
          margin-left: auto;
          font-size: 13px;
          color: var(--text-secondary);
        }
        
        .query-loading {
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 8px;
          padding: 40px;
          text-align: center;
          color: var(--text-secondary);
        }
        
        .loading-spinner {
          width: 40px;
          height: 40px;
          border: 3px solid var(--border-color);
          border-top-color: var(--accent-primary);
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin: 0 auto 16px;
        }
        
        .loading-hint {
          font-size: 12px;
          color: var(--text-muted);
          margin-top: 8px;
        }
        
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
        
        #queryResults {
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 8px;
          padding: 20px;
          margin-bottom: 24px;
        }
        
        #queryHistory {
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 8px;
          padding: 20px;
        }

        /* Explore Tab Styles */
        .explore-layout {
          display: grid;
          grid-template-columns: 280px 1fr 320px;
          height: 100%;
          gap: 0;
          background: var(--bg-primary);
        }
        
        .explore-sidebar {
          background: var(--bg-secondary);
          border-right: 1px solid var(--border-color);
          display: flex;
          flex-direction: column;
          overflow: hidden;
        }
        
        .sidebar-header {
          padding: 16px;
          font-weight: 600;
          color: var(--text-primary);
          border-bottom: 1px solid var(--border-color);
          font-size: 14px;
        }
        
        .search-input {
          margin: 12px;
          padding: 8px 12px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          color: var(--text-primary);
          font-size: 13px;
        }
        
        .tag-filter {
          margin: 0 12px 12px;
          padding: 8px 12px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          color: var(--text-primary);
          font-size: 13px;
        }
        
        .node-list {
          flex: 1;
          overflow-y: auto;
          padding: 8px;
        }
        
        .node-item {
          padding: 10px 12px;
          margin-bottom: 4px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s;
          font-size: 13px;
          color: var(--text-primary);
        }
        
        .node-item:hover {
          background: var(--bg-tertiary);
          border-color: var(--accent-primary);
        }
        
        .graph-view {
          position: relative;
          background: var(--bg-primary);
          overflow: hidden;
        }
        
        #graph {
          width: 100%;
          height: 100%;
        }
        
        .graph-controls {
          position: absolute;
          top: 16px;
          right: 16px;
          display: flex;
          gap: 8px;
        }
        
        .graph-controls button {
          padding: 8px 12px;
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          color: var(--text-primary);
          font-size: 13px;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .graph-controls button:hover {
          background: var(--bg-tertiary);
          border-color: var(--accent-primary);
        }
        
        .explore-detail {
          background: var(--bg-secondary);
          border-left: 1px solid var(--border-color);
          padding: 20px;
          overflow-y: auto;
        }
        
        .empty-state {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          color: var(--text-muted);
          gap: 12px;
        }
        
        .empty-icon {
          font-size: 48px;
          opacity: 0.5;
        }

        /* Enhanced Explore Tab Styles */
        .mini-btn {
          padding: 6px 12px;
          background: var(--bg-tertiary);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          color: var(--text-primary);
          font-size: 11px;
          cursor: pointer;
          transition: all 0.2s;
          white-space: nowrap;
        }
        
        .mini-btn:hover {
          background: var(--bg-hover);
          border-color: var(--accent-primary);
          transform: translateY(-1px);
        }
        
        .node-item {
          padding: 12px;
          margin-bottom: 6px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .node-item:hover {
          background: var(--bg-tertiary);
          border-color: var(--accent-primary);
          transform: translateX(4px);
          box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .node-item.selected {
          background: var(--bg-tertiary);
          border-color: var(--accent-primary);
          border-width: 2px;
          box-shadow: 0 0 12px rgba(0, 122, 204, 0.3);
        }
        
        .connection-item:hover {
          transform: translateX(4px);
          box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        }
        
        .loading-spinner {
          width: 40px;
          height: 40px;
          border: 3px solid var(--border-color);
          border-top-color: var(--accent-primary);
          border-radius: 50%;
          animation: spin 1s linear infinite;
        }
        
        /* Graph node tooltips */
        .node-tooltip {
          position: absolute;
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          padding: 8px 12px;
          font-size: 12px;
          pointer-events: none;
          z-index: 1000;
          box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        
        /* Smooth scrollbars for node list */
        #nodeListContainer::-webkit-scrollbar {
          width: 8px;
        }
        
        #nodeListContainer::-webkit-scrollbar-track {
          background: var(--bg-primary);
        }
        
        #nodeListContainer::-webkit-scrollbar-thumb {
          background: var(--border-color);
          border-radius: 4px;
        }
        
        #nodeListContainer::-webkit-scrollbar-thumb:hover {
          background: var(--accent-primary);
        }
        
        /* Filter Buttons */
        .filter-btn {
          padding: 6px 12px;
          background: var(--bg-tertiary);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          color: var(--text-primary);
          font-size: 11px;
          cursor: pointer;
          transition: all 0.2s;
          display: inline-flex;
          align-items: center;
          gap: 6px;
        }
        
        .filter-btn:hover {
          background: var(--bg-hover);
          border-color: var(--accent-primary);
        }
        
        .filter-btn.active {
          background: var(--accent-primary);
          border-color: var(--accent-primary);
          color: white;
        }
        
        .filter-count {
          background: rgba(255,255,255,0.2);
          padding: 2px 6px;
          border-radius: 3px;
          font-size: 10px;
          font-weight: 600;
        }
        
        .filter-btn.active .filter-count {
          background: rgba(255,255,255,0.3);
        }

        /* Documentation Tab Styling */
        .markdown-body {
          color: var(--text-primary);
          line-height: 1.6;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
          padding-bottom: 50px;
        }
        .markdown-body h1, .markdown-body h2, .markdown-body h3 {
          margin-top: 24px;
          margin-bottom: 16px;
          font-weight: 600;
          line-height: 1.25;
          color: var(--text-active);
          border-bottom: 1px solid var(--border-color);
          padding-bottom: 0.3em;
        }
        .markdown-body p, .markdown-body ul, .markdown-body ol {
          margin-bottom: 16px;
        }
        .markdown-body code {
          padding: 0.2em 0.4em;
          margin: 0;
          font-size: 85%;
          background-color: rgba(255,255,255,0.05);
          border-radius: 6px;
          font-family: var(--font-mono, monospace);
        }
        .markdown-body pre {
          padding: 16px;
          overflow: auto;
          font-size: 85%;
          line-height: 1.45;
          background-color: #121212;
          border-radius: 6px;
          margin-bottom: 16px;
          border: 1px solid var(--border-color);
        }
        .markdown-body pre code {
          background: transparent;
          padding: 0;
        }
        .markdown-body blockquote {
          padding: 0 1em;
          color: var(--text-secondary);
          border-left: 0.25em solid var(--accent-primary);
          margin-bottom: 16px;
        }

    </style>
</head>
<body>
    <div class="ide-container">
        <!-- Header -->
        <div class="ide-header">
            <div class="ide-title">
                <span style="font-size: 18px;">ðŸ§ </span>
                <div style="display: flex; flex-direction: column;">
                    <span id="brainStudioTitle" style="line-height: 1.2;">Brain Studio</span>
                    <span id="modeDescription" style="font-size: 9px; color: var(--text-secondary); font-weight: 400; opacity: 0.8;">Action-oriented workspace</span>
                </div>
            </div>
            
            <!-- BRAIN STUDIO TABS (Main App Modes) -->
            <nav style="display: flex; gap: 8px; margin-left: 32px; height: 100%; align-items: center;">
                <button class="tab-btn" data-tab="readme" onclick="switchBrainTab('readme')" data-tooltip="Documentation: View the platform README and guide.">
                    ðŸ“– Docs
                </button>
                <button class="tab-btn" data-tab="query" onclick="switchBrainTab('query')" data-tooltip="Research Mode: Deep dive into memory, find evidence, and synthesize knowledge.">
                    ðŸ’¬ Research
                </button>
                <button class="tab-btn active agent-ide-tab" data-tab="files" onclick="switchBrainTab('files')" data-tooltip="Agent IDE: Operation mode. Create files, write code, and execute tasks.">
                    ðŸ¤– Agent IDE
                </button>
                <button class="tab-btn" data-tab="explore" onclick="switchBrainTab('explore')" data-tooltip="Explore Mode: Visualize and navigate the knowledge graph.">
                    ðŸ”­ Explore
                </button>
            </nav>
            
            <div class="header-actions">
                <!-- Group 1: File Operations -->
                <div class="header-group">
                    <span class="header-group-label">File</span>
                    <button class="btn btn-icon" onclick="createNewFile()" data-tooltip="New File (Cmd+N)" title="Create new file">ðŸ“„</button>
                    <button class="btn btn-icon" onclick="createNewFolder()" data-tooltip="New Folder" title="Create new folder">ðŸ“</button>
                    <button class="btn btn-icon" onclick="showCSVBuilder()" data-tooltip="New CSV Table" title="Create CSV spreadsheet">ðŸ“Š</button>
                    <button class="btn btn-icon" onclick="downloadCurrentFile()" id="download-btn" disabled data-tooltip="Download Current File">â¬‡ï¸</button>
                </div>

                <!-- Group 2: Editor Tools -->
                <div class="header-group">
                    <span class="header-group-label">Tools</span>
                    <button class="btn btn-icon" onclick="toggleSearch()" data-tooltip="Search (Cmd+F)">ðŸ”</button>
                    <button class="btn btn-icon" onclick="togglePreview()" id="preview-btn" data-tooltip="Toggle Preview" style="display: none;">ðŸ‘ï¸</button>
                    <button class="btn btn-icon" onclick="toggleSnapshotHistory()" data-tooltip="File History" id="snapshot-btn" disabled>âª</button>
                    <button class="btn active" onclick="toggleAI()" id="ai-btn" data-tooltip="AI Assistant (Cmd+K A)" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); margin-left: 4px; border-radius: 16px; padding: 4px 12px; height: 28px;">ðŸ¤– AI</button>
                </div>

                <!-- Group 3: Save Actions -->
                <div class="header-group">
                    <button class="btn" onclick="saveCurrentFile()" id="save-btn" disabled data-tooltip="Save (Cmd+S)">ðŸ’¾ Save</button>
                    <button class="btn btn-secondary" onclick="saveAllFiles()" id="save-all-btn" disabled data-tooltip="Save All (Cmd+Shift+S)">Save All</button>
                </div>

                <!-- Group 4: System -->
                <div class="header-group">
                    <button class="btn btn-icon" onclick="toggleSettings()" data-tooltip="Settings">âš™ï¸</button>
                    <button class="btn btn-icon" onclick="toggleKeyboardHelp()" data-tooltip="Keyboard Shortcuts (?)">âŒ¨ï¸</button>
                    <button class="btn btn-icon" onclick="window.location.href='/'" data-tooltip="Back to Home">ðŸ </button>
                </div>
            </div>
        </div>

        <!-- Tab Panels Container -->
        <div class="brain-studio-tabs">
          <!-- Documentation Panel (README) -->
          <div id="readme-tab-panel" class="brain-tab-panel" style="display: none; flex-direction: column; overflow: hidden; background: var(--bg-primary);">
            <div style="padding: 24px 48px; overflow-y: auto; flex: 1; max-width: 1000px; margin: 0 auto; width: 100%;">
              <div id="readme-content" class="markdown-body">
                <div style="display: flex; justify-content: center; padding: 100px;">
                    <div class="ai-thinking-spinner"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- Query Panel (hidden by default) -->
          <div id="query-tab-panel" class="brain-tab-panel" style="display: none;">
            <!-- Will be populated by query-tab.js -->
          </div>
          
          <!-- Files Panel (IDE - active by default) -->
          <div id="files-tab-panel" class="brain-tab-panel" style="display: flex;">
            
        <!-- Body -->
        <div class="ide-body">
            <!-- Sidebar Expand Button (visible when collapsed) -->
            <button class="sidebar-expand-btn" id="sidebar-expand-btn" onclick="toggleSidebar()" title="Show Sidebar" style="display: none;">
                âµ
            </button>
            
            <!-- Sidebar -->
            <div class="sidebar" id="sidebar">
                <div class="resize-handle resize-handle-vertical" data-target="sidebar"></div>
                <div class="sidebar-header">
                    <span>DOCUMENTATION FILES</span>
                    <div style="display: flex; gap: 4px;">
                        <button class="btn btn-icon" onclick="refreshFileTree()" data-tooltip="Refresh File Tree" style="background: none; padding: 4px 8px; font-size: 14px;">
                            ðŸ”„
                        </button>
                        <button class="btn btn-icon" onclick="toggleSidebar()" data-tooltip="Hide Sidebar" style="background: none; padding: 4px 8px; font-size: 14px;">
                            â´
                        </button>
                    </div>
                </div>
                <div class="file-tree" id="file-tree">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <!-- Editor -->
            <div class="editor-container">
                <div class="tabs-bar" id="tabs-bar">
                    <!-- Tabs populated by JavaScript -->
                </div>
                
                <div class="breadcrumb-bar" id="breadcrumb-bar" style="height: 28px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); padding: 0 16px; display: none; align-items: center; font-size: 12px; color: var(--text-secondary); overflow-x: auto; white-space: nowrap;">
                    <!-- Breadcrumb populated by JavaScript -->
                </div>
                
                <div class="editor-split-container">
                    <div class="editor-pane">
                        <div class="editor-wrapper">
                            <div id="monaco-editor"></div>
                            <div id="monaco-diff-editor" class="hidden"></div>
                            <div class="loading-overlay" id="loading-overlay">
                                <span>ðŸŒŒ Loading Monaco Editor...</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Markdown Preview Pane -->
                    <div class="preview-pane hidden" id="preview-pane">
                        <div class="resize-handle resize-handle-vertical" data-target="preview-pane"></div>
                        <div class="preview-header">
                            <span>ðŸ“„ Preview</span>
                            <button onclick="togglePreview()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">Ã—</button>
                        </div>
                        <div class="preview-content" id="preview-content">
                            <p style="color: var(--text-secondary);">Preview will appear here...</p>
                        </div>
                    </div>
                    
                        <!-- AI Chat Panel -->
                        <div class="ai-panel" id="ai-panel">
                            <div class="resize-handle resize-handle-vertical" data-target="ai-panel"></div>
                            <div class="ai-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span>ðŸ¤– AI Assistant</span>
                                </div>
                                <div style="display: flex; gap: 4px; align-items: center;">
                                    <button class="btn-icon" id="history-toggle-btn" onclick="toggleChatHistory()" title="History">ðŸ•’</button>
                                    <button class="btn-icon" onclick="startNewChat()" title="New Chat">âž•</button>
                                    <button class="btn-icon" onclick="toggleAI()" title="Close">Ã—</button>
                                </div>
                            </div>
                            
                            <!-- Model Selector (Inline Style) -->
                            <div style="padding: 10px 12px; border-bottom: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: space-between;">
                                <span style="font-size: 10px; color: var(--text-secondary); font-weight: 700;">MODEL</span>
                                <select id="ai-model-select" style="background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 11px; outline: none; cursor: pointer;">
                                    <option value="claude-sonnet-4-5">Claude Sonnet 4.5</option>
                                    <option value="claude-opus-4-5">Claude Opus 4.5</option>
                                    <option value="gpt-5.2">GPT-5.2</option>
                                    <option value="grok-code-fast-1">Grok (xAI)</option>
                                </select>
                            </div>
                            
                            <!-- Chat History Panel (Drawer-style) -->
                            <div id="chat-history-panel" class="hidden">
                                <div class="chat-history-header">
                                    <span style="font-size: 10px; font-weight: 700; color: var(--text-secondary);">CONVERSATIONS</span>
                                    <button onclick="chatHistory.clearDirectory()" style="background: none; border: none; color: var(--error-color); cursor: pointer; font-size: 10px; font-weight: 600;" title="Delete all history for this directory">
                                        Clear All
                                    </button>
                                </div>
                                <div id="chat-history-list" style="overflow-y: auto; flex: 1; min-height: 0;">
                                    <!-- Populated dynamically -->
                                </div>
                            </div>
                            
                            <div class="ai-chat-messages" id="ai-chat-messages">
                                <div style="padding: 40px 20px; text-align: center; color: var(--text-secondary); font-size: 13px; opacity: 0.6;">
                                    <div style="font-size: 32px; margin-bottom: 16px;">âœ¨</div>
                                    Ask me anything about your brain or documents.
                                </div>
                            </div>
                            
                            <div class="ai-input-container">
                                <div class="ai-input-wrapper">
                                    <textarea id="ai-input" placeholder="Message AI Assistant..." onkeydown="handleAIInputKeydown(event)"></textarea>
                                    <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 4px;">
                                        <span style="font-size: 9px; color: var(--text-secondary); opacity: 0.5; padding-left: 4px;">Enter to send, Shift+Enter for new line</span>
                                        <div style="display: flex; gap: 8px;">
                                            <button class="btn btn-secondary" id="ai-stop-btn" onclick="stopAIRequest()" style="display: none; padding: 4px 12px; background: var(--error-color); color: white; border: none;">Stop</button>
                                            <button class="btn" id="ai-send-btn" onclick="sendAIMessage()" style="padding: 4px 16px; height: 28px; border-radius: 14px;">Send</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                </div>
            </div>
        </div>

          </div>
          <!-- End Files Tab Panel -->
          
          <!-- Explore Panel (hidden by default) -->
          <div id="explore-tab-panel" class="brain-tab-panel" style="display: none;">
            <!-- Will be populated by explore-tab.js -->
          </div>
        </div>
        <!-- End Tab Panels Container -->

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-left">
                <span id="status-file">No file open</span>
                <span id="status-line">Ln 1, Col 1</span>
                <span id="status-selection"></span>
                <span id="status-dirty"></span>
            </div>
            <div class="status-right">
                <span id="status-edits" class="status-item" onclick="toggleEditQueue()" style="display:none; cursor:pointer; color: #3b82f6;" title="Click to open AI Edits panel"></span>
                <span id="status-size"></span>
                <span id="status-words"></span>
                <span id="status-lang">Plain Text</span>
                <span id="status-encoding">UTF-8</span>
            </div>
        </div>
    </div>

    <!-- Command Palette -->
    <div class="command-palette hidden" id="command-palette">
        <input type="text" id="command-input" placeholder="Type a command or search files (Cmd+Shift+P)..." />
        <div class="command-results" id="command-results"></div>
    </div>

    <!-- Search Panel -->
    <div class="search-panel hidden" id="search-panel">
        <div class="search-input-group">
            <input type="text" class="search-input" id="search-input" placeholder="Find..." />
        </div>
        <div class="search-input-group">
            <input type="text" class="search-input" id="replace-input" placeholder="Replace..." />
        </div>
        <div class="search-options">
            <label class="search-option">
                <input type="checkbox" id="search-case" />
                <span>Match Case</span>
            </label>
            <label class="search-option">
                <input type="checkbox" id="search-whole" />
                <span>Whole Word</span>
            </label>
            <label class="search-option">
                <input type="checkbox" id="search-regex" />
                <span>Regex</span>
            </label>
        </div>
        <div style="margin-top: 12px; display: flex; gap: 8px;">
            <button class="btn" onclick="findNext()" style="flex: 1;">Find Next</button>
            <button class="btn btn-secondary" onclick="replaceOne()" style="flex: 1;">Replace</button>
        </div>
        <div style="margin-top: 8px;">
            <button class="btn btn-secondary" onclick="replaceAll()" style="width: 100%;">Replace All</button>
        </div>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settings-panel">
        <div class="settings-header">
            <span>âš™ï¸ Settings</span>
            <button onclick="toggleSettings()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">Ã—</button>
        </div>
        <div class="settings-content">
            <div class="setting-group">
                <div class="setting-group-title">Editor</div>
                <div class="setting-item">
                    <label class="setting-label">Theme</label>
                    <select class="setting-input" id="setting-theme" onchange="applyTheme()">
                        <option value="vs-dark">Dark (default)</option>
                        <option value="vs">Light</option>
                        <option value="hc-black">High Contrast Dark</option>
                        <option value="hc-light">High Contrast Light</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Font Size</label>
                    <input type="number" class="setting-input" id="setting-font-size" value="14" min="10" max="24" onchange="applyFontSize()" />
                </div>
                <div class="setting-item">
                    <label class="setting-label">Tab Size</label>
                    <input type="number" class="setting-input" id="setting-tab-size" value="2" min="2" max="8" onchange="applyTabSize()" />
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-group-title">View</div>
                <div class="setting-item">
                    <label class="setting-checkbox">
                        <input type="checkbox" id="setting-minimap" checked onchange="applyMinimap()" />
                        <span>Show Minimap</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label class="setting-checkbox">
                        <input type="checkbox" id="setting-line-numbers" checked onchange="applyLineNumbers()" />
                        <span>Show Line Numbers</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label class="setting-checkbox">
                        <input type="checkbox" id="setting-word-wrap" checked onchange="applyWordWrap()" />
                        <span>Word Wrap</span>
                    </label>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-group-title">Auto-Save</div>
                <div class="setting-item">
                    <label class="setting-label">Auto-Save Mode</label>
                    <select class="setting-input" id="setting-auto-save" onchange="applyAutoSave()">
                        <option value="off">Off</option>
                        <option value="afterDelay">After Delay</option>
                        <option value="onFocusChange">On Focus Change</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Auto-Save Delay (ms)</label>
                    <input type="number" class="setting-input" id="setting-auto-save-delay" value="1000" min="500" max="5000" step="500" />
                </div>
            </div>
            <div style="margin-top: 24px;">
                <button class="btn" onclick="resetSettings()" style="width: 100%;">Reset to Defaults</button>
            </div>
        </div>
    </div>

    <!-- Keyboard Help -->
    <div class="keyboard-help hidden" id="keyboard-help">
        <div class="keyboard-help-header">
            <span>âŒ¨ï¸ Keyboard Shortcuts</span>
            <button onclick="toggleKeyboardHelp()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">Ã—</button>
        </div>
        <div class="keyboard-help-content">
            <div class="shortcut-section">
                <div class="shortcut-section-title">File Operations</div>
                <div class="shortcut-item"><span>Save File</span><span class="shortcut-keys">Cmd+S / Ctrl+S</span></div>
                <div class="shortcut-item"><span>Save All Files</span><span class="shortcut-keys">Cmd+Shift+S</span></div>
                <div class="shortcut-item"><span>Close File</span><span class="shortcut-keys">Cmd+W / Ctrl+W</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">Navigation</div>
                <div class="shortcut-item"><span>Command Palette</span><span class="shortcut-keys">Cmd+Shift+P</span></div>
                <div class="shortcut-item"><span>Quick Open File</span><span class="shortcut-keys">Cmd+P</span></div>
                <div class="shortcut-item"><span>Go to Line</span><span class="shortcut-keys">Cmd+G / Ctrl+G</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">Editing</div>
                <div class="shortcut-item"><span>Find</span><span class="shortcut-keys">Cmd+F / Ctrl+F</span></div>
                <div class="shortcut-item"><span>Replace</span><span class="shortcut-keys">Cmd+H / Ctrl+H</span></div>
                <div class="shortcut-item"><span>Format Document</span><span class="shortcut-keys">Shift+Alt+F</span></div>
                <div class="shortcut-item"><span>Toggle Comment</span><span class="shortcut-keys">Cmd+/ / Ctrl+/</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">View</div>
                <div class="shortcut-item"><span>Toggle Sidebar</span><span class="shortcut-keys">Cmd+B / Ctrl+B</span></div>
                <div class="shortcut-item"><span>Toggle Preview</span><span class="shortcut-keys">Cmd+K V</span></div>
                <div class="shortcut-item"><span>Toggle AI Assistant</span><span class="shortcut-keys">Cmd+K A</span></div>
                <div class="shortcut-item"><span>Settings</span><span class="shortcut-keys">Cmd+,</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">AI Assistant</div>
                <div class="shortcut-item"><span>Send Message</span><span class="shortcut-keys">Cmd+Enter</span></div>
                <div class="shortcut-item"><span>Improve Selection</span><span class="shortcut-keys">Right-click â†’ AI menu</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">Help</div>
                <div class="shortcut-item"><span>Keyboard Shortcuts</span><span class="shortcut-keys">? / Cmd+K Cmd+S</span></div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu hidden" id="context-menu">
        <!-- Populated dynamically -->
    </div>

    <!-- Overlay -->
    <div class="overlay hidden" id="overlay" onclick="closeAllModals()"></div>

    <!-- Folder Browser Modal -->
    <div class="keyboard-help hidden" id="folder-browser" style="width: 900px; max-width: 90vw;">
        <div class="keyboard-help-header">
            <span>ðŸ“‚ Browse for Folder</span>
            <button onclick="closeFolderBrowser()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">Ã—</button>
        </div>
        <div class="keyboard-help-content" style="padding: 0; max-height: 70vh;">
            <div style="padding: 12px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <button onclick="navigateUp()" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;">â¬†ï¸ Up</button>
                    <button onclick="navigateToHome()" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;">ðŸ  Home</button>
                    <div style="flex: 1; padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 12px; font-family: monospace; overflow-x: auto; white-space: nowrap;" id="current-path-display">
                        /Users
                    </div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <input type="text" id="manual-path-input" placeholder="Or type path directly... (e.g., /path/to/folder)" 
                           style="flex: 1; padding: 8px 12px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 12px; font-family: monospace;"
                           onkeypress="if(event.key==='Enter') goToManualPath()">
                    <button onclick="goToManualPath()" class="btn" style="padding: 8px 16px; font-size: 12px;">Go</button>
                </div>
            </div>
            <div id="folder-list" style="padding: 12px; overflow-y: auto; max-height: calc(70vh - 120px);">
                <div style="text-align: center; color: var(--text-secondary); padding: 40px;">Loading...</div>
            </div>
            <div style="padding: 12px; background: var(--bg-secondary); border-top: 1px solid var(--border-color); display: flex; gap: 8px;">
                <button onclick="closeFolderBrowser()" class="btn btn-secondary" style="flex: 1;">Cancel</button>
                <button onclick="selectCurrentFolder()" class="btn" style="flex: 2;">âœ“ Open This Folder</button>
            </div>
        </div>
    </div>

    <!-- Edit Queue Panel (Cursor-style edit review) -->
    <div id="edit-queue-panel" class="edit-queue-panel hidden">
        <div class="edit-queue-header">
            <h3>ðŸ“ AI Edits (<span id="edit-count">0</span>)</h3>
            <button onclick="toggleEditQueue()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">Ã—</button>
        </div>
        
        <div class="edit-queue-actions">
            <button class="btn btn-primary" onclick="editQueue.acceptAll()" title="Accept all pending edits">
                âœ“ Accept All
            </button>
            <button class="btn btn-secondary" onclick="editQueue.rejectAll()" title="Reject all pending edits">
                âœ— Reject All
            </button>
            <button class="btn btn-secondary" onclick="editQueue.clearProcessed()" title="Clear accepted/rejected edits">
                Clear
            </button>
        </div>
        
        <div id="edit-queue-list" class="edit-queue-list">
            <div style="text-align: center; color: var(--text-secondary); padding: 40px; font-size: 13px;">
                No pending edits
            </div>
        </div>
    </div>

    <!-- Snapshot History Panel -->
    <div id="snapshot-history-panel" class="edit-queue-panel hidden" style="width: 400px;">
        <div class="edit-queue-header">
            <h3>âª File History: <span id="snapshot-file-name">-</span></h3>
            <button onclick="toggleSnapshotHistory()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">Ã—</button>
        </div>
        
        <div class="edit-queue-actions" style="padding: 12px; border-bottom: 1px solid var(--border-color);">
            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
                Auto-snapshots created before AI edits
            </div>
            <button class="btn btn-secondary" onclick="clearAllSnapshots()" style="width: 100%; font-size: 12px;">
                ðŸ—‘ï¸ Clear All History
            </button>
        </div>
        
        <div id="snapshot-list" class="edit-queue-list">
            <div style="text-align: center; color: var(--text-secondary); padding: 40px; font-size: 13px;">
                No snapshots yet
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu hidden" id="context-menu">
        <!-- Populated dynamically -->
    </div>

    <!-- CSV Table Builder Modal -->
    <div class="keyboard-help hidden" id="csv-builder" style="width: 800px; max-width: 90vw;">
        <div class="keyboard-help-header">
            <span>ðŸ“Š Create CSV Table</span>
            <button onclick="closeCSVBuilder()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">Ã—</button>
        </div>
        <div class="keyboard-help-content" style="padding: 20px;">
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600;">File Name:</label>
                <input type="text" id="csv-filename" value="data.csv" 
                       style="width: 100%; padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-family: monospace;">
            </div>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600;">Table Size:</label>
                <div style="display: flex; gap: 12px;">
                    <div>
                        <label style="font-size: 12px; color: var(--text-secondary);">Rows:</label>
                        <input type="number" id="csv-rows" value="5" min="1" max="100" 
                               style="width: 80px; padding: 6px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: var(--text-secondary);">Columns:</label>
                        <input type="number" id="csv-cols" value="4" min="1" max="50" 
                               style="width: 80px; padding: 6px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">
                    </div>
                    <button class="btn btn-secondary" onclick="generateCSVGrid()" style="margin-left: auto;">
                        Generate Grid
                    </button>
                </div>
            </div>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600;">Edit Table:</label>
                <div id="csv-grid" style="overflow: auto; max-height: 400px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-tertiary);">
                    <p style="text-align: center; padding: 40px; color: var(--text-secondary);">Click "Generate Grid" to start</p>
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; justify-content: flex-end;">
                <button onclick="closeCSVBuilder()" class="btn btn-secondary">
                    Cancel
                </button>
                <button onclick="createCSVFile()" class="btn btn-primary">
                    ðŸ“Š Create CSV File
                </button>
            </div>
        </div>
    </div>

    <!-- Monaco Loader -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>

    <script>
        // ============================================================================
        // MARKDOWN & SYNTAX HIGHLIGHTING CONFIGURATION
        // ============================================================================
        
        // Configure marked.js with highlight.js for beautiful code rendering
        marked.setOptions({
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(code, { language: lang }).value;
                    } catch (err) {
                        return hljs.highlightAuto(code).value;
                    }
                }
                return hljs.highlightAuto(code).value;
            },
            breaks: true,
            gfm: true,
            headerIds: false,
            mangle: false
        });
        
        // ============================================================================
        // STATE MANAGEMENT
        // ============================================================================
        
        // Parse URL parameters
        const params = new URLSearchParams(window.location.search);
        let folderPath = params.get('path');
        let initialFileName = params.get('file');
        
        // Standalone mode - filesystem only
        const IDE_MODE = 'filesystem';
        const runName = null;
        const systemId = null;
        
        // Show folder picker on startup if no path
        if (!folderPath) {
            // Folder picker is now opened on-demand or if no brain is loaded
            // See main DOMContentLoaded handler for auto-loading logic
        }
        
        // FileAPI - filesystem only
        const FileAPI = {
            async listFiles() {
                const res = await fetch(`/api/folder/browse?path=${encodeURIComponent(folderPath)}&recursive=true`);
                return await res.json();
            },
            async readFile(filePath) {
                const res = await fetch(`/api/folder/read?path=${encodeURIComponent(filePath)}`);
                return await res.json();
            },
            async writeFile(filePath, content) {
                const res = await fetch('/api/folder/write', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: filePath, content })
                });
                return await res.json();
            },
            getDisplayName() {
                return folderPath ? folderPath.split('/').pop() || folderPath : 'Filesystem';
            }
        };
        
        /**
         * Resolve a path relative to the current working folder
         * Handles: relative paths (README.md), dot-relative (./src), and absolute paths
         * @param {string} inputPath - The path from AI tool commands
         * @returns {string} Absolute path ready for API calls
         */
        function resolvePathForAPI(inputPath) {
            if (!inputPath) return inputPath;
            
            // Get the current working folder based on IDE mode
            const currentFolder = IDE_MODE === 'filesystem' 
                ? folderPath 
                : (currentBrowsePath || '.');
            
            // Already absolute? Return as-is
            if (inputPath.startsWith('/')) {
                return inputPath;
            }
            
            // Handle . and ./ (current directory)
            if (inputPath === '.' || inputPath === './') {
                return currentFolder;
            }
            
            // Handle ./ prefix
            if (inputPath.startsWith('./')) {
                inputPath = inputPath.slice(2);
            }
            
            // Join with current folder
            // Simple join - avoid double slashes
            const base = currentFolder.endsWith('/') ? currentFolder.slice(0, -1) : currentFolder;
            return `${base}/${inputPath}`;
        }

        // Core state
        let editor = null;
        let openFiles = new Map();
        let activeFile = null;
        let allFiles = [];
        let availableSystems = [];
        let autoSaveTimer = null;
        let previewUpdateTimer = null;
        let selectedCommandIndex = 0;
        let pinnedTabs = new Set(); // Track pinned file paths
        let recentFiles = []; // Track recently opened files
        const MAX_RECENT_FILES = 20;
        
        // Settings
        const defaultSettings = {
            theme: 'vs-dark',
            fontSize: 14,
            tabSize: 2,
            minimap: true,
            lineNumbers: true,
            wordWrap: true,
            autoSave: 'off',
            autoSaveDelay: 1000,
        };
        
        let settings = loadSettings();

        // ============================================================================
        // EDIT QUEUE MANAGER - Cursor-style edit review system
        // ============================================================================
        
        class EditQueueManager {
            constructor() {
                this.queue = [];
                this.onUpdate = null;
            }
            
            addEdit(filePath, original, modified) {
                const edit = {
                    id: `edit-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    filePath,
                    fileName: filePath.split('/').pop(),
                    originalContent: original,
                    modifiedContent: modified,
                    summary: this.generateSummary(original, modified),
                    status: 'pending',
                    timestamp: Date.now()
                };
                
                this.queue.push(edit);
                
                // Auto-open panel on first pending edit in this session
                if (this.getPending().length === 1) {
                    showEditQueue();
                    showToast('AI proposed edits â€“ review in the AI Edits panel', 'success');
                }
                
                this.notify();
                return edit.id;
            }
            
            async acceptEdit(id) {
                const edit = this.queue.find(e => e.id === id);
                if (edit && edit.status === 'pending') {
                    edit.status = 'accepted';
                    await this.applyEdit(edit);
                    this.notify();
                }
            }
            
            rejectEdit(id) {
                const edit = this.queue.find(e => e.id === id);
                if (edit && edit.status === 'pending') {
                    edit.status = 'rejected';
                    this.notify();
                }
            }
            
            async acceptAll() {
                const pending = this.queue.filter(e => e.status === 'pending');
                for (const e of pending) {
                    await this.acceptEdit(e.id);
                }
            }
            
            rejectAll() {
                const pending = this.queue.filter(e => e.status === 'pending');
                pending.forEach(e => this.rejectEdit(e.id));
            }
            
            clearProcessed() {
                this.queue = this.queue.filter(e => e.status === 'pending');
                this.notify();
            }
            
            getPending() {
                return this.queue.filter(e => e.status === 'pending');
            }
            
            getAll() {
                return this.queue;
            }
            
            generateSummary(original, modified) {
                const origLines = original.split('\n').length;
                const modLines = modified.split('\n').length;
                const diff = modLines - origLines;
                if (diff > 0) return `+${diff} lines added`;
                if (diff < 0) return `${Math.abs(diff)} lines removed`;
                return 'Modified';
            }
            
            async applyEdit(edit) {
                try {
                    // Create snapshot before applying AI edit
                    console.log(`[SNAPSHOT] Creating snapshot before applying edit to ${edit.fileName}`);
                    await createSnapshot(edit.filePath, edit.originalContent, `Before AI edit: ${edit.summary}`);
                    
                    // Always save to disk first
                    const saveResult = await FileAPI.writeFile(edit.filePath, edit.modifiedContent);
                    if (!saveResult.success) {
                        showToast(`Failed to save ${edit.fileName}: ${saveResult.error}`, 'error');
                        return;
                    }

                    console.log(`[EDIT] âœ“ Saved to disk: ${edit.filePath}`);

                    // Update in-memory model if file is open
                    const fileData = openFiles.get(edit.filePath);
                    if (fileData) {
                        fileData.model.setValue(edit.modifiedContent);
                        fileData.dirty = false;  // Already saved!
                        updateTabDirtyState(edit.filePath, false);
                        updateSaveButtons();
                    }

                    showToast(`âœ“ Saved: ${edit.fileName}`, 'success');
                    
                } catch (error) {
                    console.error(`[EDIT] Failed to apply edit:`, error);
                    showToast(`Failed to save ${edit.fileName}: ${error.message}`, 'error');
                }
            }
            
            notify() {
                if (this.onUpdate) {
                    this.onUpdate(this.queue);
                }
                updateEditQueueUI();
            }
        }
        
        // Global edit queue instance
        const editQueue = new EditQueueManager();
        
        /**
         * Add surgical edit to queue (from function calling)
         * Applies surgical edit markers to get full content, then queues for review
         */
        async function addToEditQueue(filePath, instructions, surgicalEditContent) {
            try {
                // Read current file content
                const result = await FileAPI.readFile(filePath);
                if (!result.success) {
                    console.error(`Cannot queue edit for ${filePath}: file not found`);
                    showToast(`Cannot edit ${filePath}: file not found`, 'error');
                    return;
                }
                
                const originalContent = result.content;
                
                // Apply surgical edit to get full modified content
                // Direct replacement (no surgical parsing - simpler, more reliable)
                const modifiedContent = surgicalEditContent;
                
                // Add to queue
                const editId = editQueue.addEdit(filePath, originalContent, modifiedContent);
                
                console.log(`[EDIT QUEUE] Added edit for ${filePath}: ${instructions}`);
                
            } catch (error) {
                console.error(`Error adding edit to queue:`, error);
                showToast(`Error queuing edit: ${error.message}`, 'error');
            }
        }
        
        // ============================================================================
        // CHAT HISTORY MANAGER - Directory-specific conversation persistence
        // ============================================================================
        
        class ChatHistoryManager {
            constructor() {
                this.currentConversationId = null;
                this.currentConversationData = null;
                this.allConversations = [];
                this.autoSaveTimeout = null;
            }
            
            getCurrentDirectory() {
                return IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            }
            
            async loadConversationsFromServer() {
                try {
                    const response = await fetch('/api/conversations');
                    const data = await response.json();
                    if (data.success) {
                        this.allConversations = data.conversations;
                        return this.allConversations;
                    }
                } catch (e) {
                    console.error('Failed to load conversations:', e);
                }
                return [];
            }
            
            startNewConversation() {
                this.currentConversationId = null;
                this.currentConversationData = {
                    id: null,
                    title: `Chat ${new Date().toLocaleString()}`,
                    timestamp: new Date().toISOString(),
                    folder: this.getCurrentDirectory(),
                    brainPath: window.currentBrainInfo?.brainPath || null,
                    messages: []
                };
                return this.currentConversationId;
            }
            
            async saveMessage(role, content, fileContext = null) {
                // Add to in-memory conversation
                if (!this.currentConversationData) {
                    this.startNewConversation();
                }
                
                this.currentConversationData.messages.push({ role, content, timestamp: Date.now() });
                
                // Auto-save after 2 seconds of inactivity (debounced)
                clearTimeout(this.autoSaveTimeout);
                this.autoSaveTimeout = setTimeout(() => this.autoSaveConversation(), 2000);
            }
            
            async autoSaveConversation() {
                if (!this.currentConversationData || this.currentConversationData.messages.length === 0) {
                    return;
                }
                
                try {
                    // Generate title from first message if new conversation
                    if (!this.currentConversationId) {
                        const firstUserMsg = this.currentConversationData.messages.find(m => m.role === 'user');
                        if (firstUserMsg) {
                            const preview = firstUserMsg.content.substring(0, 50);
                            this.currentConversationData.title = preview + (firstUserMsg.content.length > 50 ? '...' : '');
                        }
                    }
                    
                    const url = this.currentConversationId 
                        ? `/api/conversations/${this.currentConversationId}`
                        : '/api/conversations';
                    
                    const method = this.currentConversationId ? 'PUT' : 'POST';
                    
                    const response = await fetch(url, {
                        method,
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            title: this.currentConversationData.title,
                            messages: this.currentConversationData.messages,
                            folder: this.currentConversationData.folder,
                            brainPath: this.currentConversationData.brainPath
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        if (!this.currentConversationId) {
                            this.currentConversationId = data.id || data.conversation.id;
                            this.currentConversationData.id = this.currentConversationId;
                        }
                        console.log('[CHAT] Auto-saved conversation:', this.currentConversationId);
                    }
                } catch (e) {
                    console.error('Failed to auto-save conversation:', e);
                }
            }
            
            async loadConversation(conversationId) {
                try {
                    const response = await fetch(`/api/conversations/${conversationId}`);
                    const data = await response.json();
                    
                    if (data.success) {
                        this.currentConversationId = conversationId;
                        this.currentConversationData = data.conversation;
                        return data.conversation;
                    }
                } catch (e) {
                    console.error('Failed to load conversation:', e);
                }
                return null;
            }
            
            getRecentConversations(directory = null) {
                const dir = directory || this.getCurrentDirectory();
                const currentBrainPath = window.currentBrainInfo?.brainPath;
                
                // Filter by directory if specified AND brainPath to prevent cross-contamination
                return this.allConversations
                    .filter(c => {
                        const dirMatch = !dir || c.folder === dir;
                        const brainMatch = !currentBrainPath || c.brainPath === currentBrainPath;
                        return dirMatch && brainMatch;
                    })
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            }
            
            async clearDirectory(directory = null) {
                const dir = directory || this.getCurrentDirectory();
                const conversations = this.getRecentConversations(dir);
                
                if (!confirm(`Delete all ${conversations.length} conversations for this folder?`)) {
                    return;
                }
                
                try {
                    for (const conv of conversations) {
                        await fetch(`/api/conversations/${conv.id}`, { method: 'DELETE' });
                    }
                    await this.loadConversationsFromServer();
                    showToast('All conversations deleted', 'success');
                } catch (e) {
                    console.error('Failed to clear conversations:', e);
                    showToast('Error deleting conversations', 'error');
                }
            }
        }
        
        // Global chat history manager
        const chatHistory = new ChatHistoryManager();
        
        // ============================================================================
        // DIFF AND PATH UTILITIES
        // ============================================================================
        
        /**
         * Simple line-based diff (no external dependencies)
         * Returns array of {type: 'add'|'remove'|'same', line: string, oldIndex, newIndex}
         */
        function computeLineDiff(oldText, newText) {
            const oldLines = oldText.split('\n');
            const newLines = newText.split('\n');
            const diffs = [];
            let i = 0, j = 0;

            while (i < oldLines.length || j < newLines.length) {
                const oldLine = oldLines[i];
                const newLine = newLines[j];

                if (oldLine === undefined) {
                    diffs.push({ type: 'add', line: newLine, oldIndex: null, newIndex: j });
                    j++;
                } else if (newLine === undefined) {
                    diffs.push({ type: 'remove', line: oldLine, oldIndex: i, newIndex: null });
                    i++;
                } else if (oldLine === newLine) {
                    diffs.push({ type: 'same', line: oldLine, oldIndex: i, newIndex: j });
                    i++; j++;
                } else {
                    // Treat as remove + add (simple approach)
                    diffs.push({ type: 'remove', line: oldLine, oldIndex: i, newIndex: null });
                    diffs.push({ type: 'add', line: newLine, oldIndex: null, newIndex: j });
                    i++; j++;
                }
            }

            return diffs;
        }
        
        /**
         * Normalize relative paths like ./ and ../ against a base path
         * Handles both absolute and relative paths safely
         */
        function normalizePath(base, relative) {
            if (relative.startsWith('/')) return relative;

            const stack = base.split('/').filter(Boolean);
            const parts = relative.split('/');

            // If base ends with a file (has a dot), drop it
            if (stack.length && stack[stack.length - 1].includes('.')) {
                stack.pop();
            }

            for (const part of parts) {
                if (!part || part === '.') continue;
                if (part === '..') {
                    stack.pop();
                } else {
                    stack.push(part);
                }
            }

            return '/' + stack.join('/');
        }
        

        /**
         * Apply surgical edit (Cursor-style) - FAST edits with only changed sections
         * Parses // ... existing code ... markers and applies only the changes
         */


/**
 * Cursor-Style Surgical Edit Parser (Enterprise-Grade)
 * 
 * Based on Cursor's edit_file tool specification:
 * - Parses // ... existing code ... markers
 * - Uses context lines to find exact positions
 * - Handles multiple edits in sequence
 * - Robust matching with context validation
 */
        function applySurgicalEdit(originalContent, editContent) {
            // Check for surgical edit markers
            const markerPattern = /(?:\/\/|#|<!--|--)\s*\.\.\.\s*existing code\s*\.\.\.(?:\s*-->)?/gi;
            if (!markerPattern.test(editContent)) {
                // No markers - treat as full file replacement
                return editContent;
            }
    
            console.log('[SURGICAL EDIT] Parsing Cursor-style surgical edit...');
    
            // Extract INSTRUCTIONS if present (first line starting with INSTRUCTIONS:)
            let instructions = '';
            let codeContent = editContent;
            const instructionsMatch = editContent.match(/^INSTRUCTIONS:\s*(.+?)$/m);
            if (instructionsMatch) {
                instructions = instructionsMatch[1];
                codeContent = editContent.replace(/^INSTRUCTIONS:.*?$\n*/m, '');
                console.log(`[SURGICAL EDIT] Instructions: ${instructions}`);
            }
    
            // Split into sections by the markers
            // Use a more flexible regex that captures different comment styles
            const markerRegex = /(?:\/\/|#|<!--|\/\*)\s*\.\.\.\s*existing code\s*\.\.\.\s*(?:-->|\*\/)?/gi;
            const parts = codeContent.split(markerRegex);
    
            // parts[0] might be empty or have leading content
            // parts[1], parts[3], parts[5]... are the changed sections (between markers)
            // The pattern is: [optional prefix] MARKER [change1] MARKER [change2] MARKER [optional suffix]
    
            const changedBlocks = [];
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i].trim();
                if (part) {
                    changedBlocks.push({
                        content: part,
                        index: i
                    });
                }
            }
    
            if (changedBlocks.length === 0) {
                console.warn('[SURGICAL EDIT] No content blocks found');
                return editContent;
            }
    
            console.log(`[SURGICAL EDIT] Processing ${changedBlocks.length} change blocks`);
    
            // Build the result by applying each change in order
            const originalLines = originalContent.split('\n');
            let result = [...originalLines];
            let offsetAdjustment = 0; // Track line number shifts from previous edits
    
            for (const block of changedBlocks) {
                const blockLines = block.content.split('\n');
        
                // Find context lines (lines that should exist in original to anchor this change)
                // Look for lines with actual code (not just comments or whitespace)
                const contextLines = blockLines.filter(line => {
                    const trimmed = line.trim();
                    return trimmed && 
                           !trimmed.startsWith('//') && 
                           !trimmed.startsWith('#') && 
                           !trimmed.startsWith('*') &&
                           !trimmed.startsWith('/*');
                });
        
                if (contextLines.length === 0) {
                    console.warn('[SURGICAL EDIT] Block has no significant lines - skipping');
                    continue;
                }
        
                // Use first significant line as anchor to find position
                const anchorLine = contextLines[0].trim();
                const searchLength = Math.min(anchorLine.length, 50);
                const searchStr = anchorLine.substring(0, searchLength);
        
                // Find this line in the original (accounting for offset from previous edits)
                let foundAt = -1;
                for (let i = offsetAdjustment; i < result.length; i++) {
                    if (result[i].trim().includes(searchStr)) {
                        foundAt = i;
                        console.log(`[SURGICAL EDIT] Found anchor at line ${foundAt + 1}: "${searchStr.substring(0, 30)}..."`);
                        break;
                    }
                }
        
                if (foundAt === -1) {
                    console.warn(`[SURGICAL EDIT] Could not find anchor: "${searchStr.substring(0, 30)}..."`);
                    // Fallback: append at end
                    result.push('', ...blockLines);
                    continue;
                }
        
                // Determine how many lines this edit replaces
                // This is tricky - we need to figure out the span of the original code this edit covers
                // For now, use a heuristic: same number of lines as the block
                const linesToReplace = blockLines.length;
        
                // Apply the edit
                result.splice(foundAt, linesToReplace, ...blockLines);
        
                // Adjust offset for next iteration
                offsetAdjustment = foundAt + blockLines.length;
        
                console.log(`[SURGICAL EDIT] Replaced ${linesToReplace} lines at position ${foundAt + 1}`);
            }
    
            const finalContent = result.join('\n');
            console.log(`[SURGICAL EDIT] Complete - ${originalLines.length} â†’ ${result.length} lines`);
    
            return finalContent;
        }

        // ============================================================================
        // EDIT QUEUE UI FUNCTIONS
        // ============================================================================
        
        function toggleEditQueue() {
            const panel = document.getElementById('edit-queue-panel');
            panel.classList.toggle('hidden');
        }
        
        function showEditQueue() {
            const panel = document.getElementById('edit-queue-panel');
            panel.classList.remove('hidden');
        }
        
        function hideEditQueue() {
            const panel = document.getElementById('edit-queue-panel');
            panel.classList.add('hidden');
        }
        
        function updateEditQueueUI() {
            const queue = editQueue.getAll();
            const pending = editQueue.getPending();
            const countEl = document.getElementById('edit-count');
            const listEl = document.getElementById('edit-queue-list');
            
            // Update count
            countEl.textContent = pending.length;
            
            // Update list
            if (queue.length === 0) {
                listEl.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); padding: 40px; font-size: 13px;">
                        No pending edits
                    </div>
                `;
                return;
            }
            
            listEl.innerHTML = queue.map(edit => `
                <div class="edit-item ${edit.status}" data-edit-id="${edit.id}">
                    <div class="edit-item-header">
                        <div class="edit-item-file" title="${edit.filePath}">${edit.fileName}</div>
                        <span class="edit-item-status ${edit.status}">${edit.status}</span>
                    </div>
                    <div class="edit-item-summary">${edit.summary}</div>
                    <div class="edit-item-actions">
                        <button class="btn btn-secondary" onclick="viewEditDiff('${edit.id}')" title="View changes">
                            ðŸ‘ï¸ View
                        </button>
                        <button class="btn btn-primary" onclick="editQueue.acceptEdit('${edit.id}')" title="Accept this edit">
                            âœ“
                        </button>
                        <button class="btn btn-secondary" onclick="editQueue.rejectEdit('${edit.id}')" title="Reject this edit">
                            âœ—
                        </button>
                    </div>
                </div>
            `).join('');
            
            // Update status bar indicator
            const statusEdits = document.getElementById('status-edits');
            if (statusEdits) {
                if (pending.length > 0) {
                    statusEdits.style.display = 'inline';
                    statusEdits.textContent = `ðŸ“ AI Edits: ${pending.length}`;
                } else {
                    statusEdits.style.display = 'none';
                    statusEdits.textContent = '';
                }
            }
        }
        
        async function viewEditDiff(editId) {
            const edit = editQueue.getAll().find(e => e.id === editId);
            if (!edit) return;
            
            // Open file if not already open
            if (!openFiles.has(edit.filePath)) {
                const fileName = edit.fileName;
                try {
                    // Wait for file to open before showing diff
                    await openFile(edit.filePath, fileName);
                } catch (err) {
                    console.error('Could not open file:', err);
                    showToast('Could not open file for diff view', 'error');
                    return; // Don't show diff if file couldn't be opened
                }
            }
            
            // Show diff using existing modal (now that file is loaded)
            showDiffPreview(edit.originalContent, edit.modifiedContent, () => {
                editQueue.acceptEdit(editId);
            });
        }

        // ============================================================================
        // SNAPSHOT HISTORY
        // ============================================================================

        async function toggleSnapshotHistory() {
            const panel = document.getElementById('snapshot-history-panel');
            const isHidden = panel.classList.contains('hidden');
            
            if (isHidden) {
                // Show panel
                panel.classList.remove('hidden');
                await loadSnapshotHistory();
            } else {
                // Hide panel
                panel.classList.add('hidden');
            }
        }

        async function loadSnapshotHistory() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) {
                showToast('No file open', 'error');
                return;
            }
            
            const filePath = activeFile;
            const fileName = fileData.name;
            
            // Update panel title
            document.getElementById('snapshot-file-name').textContent = fileName;
            
            try {
                const response = await fetch(`/api/snapshots?filePath=${encodeURIComponent(filePath)}`);
                const data = await response.json();
                
                if (!data.success) {
                    showToast('Failed to load snapshots', 'error');
                    return;
                }
                
                renderSnapshotList(data.snapshots);
            } catch (error) {
                console.error('Error loading snapshots:', error);
                showToast('Error loading file history', 'error');
            }
        }

        function renderSnapshotList(snapshots) {
            const listEl = document.getElementById('snapshot-list');
            
            if (!snapshots || snapshots.length === 0) {
                listEl.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); padding: 40px; font-size: 13px;">
                        No snapshots yet<br>
                        <span style="font-size: 11px; margin-top: 8px; display: block;">Snapshots are created automatically before AI edits</span>
                    </div>
                `;
                return;
            }
            
            let html = '';
            for (const snapshot of snapshots) {
                const date = new Date(snapshot.timestamp);
                const timeAgo = getTimeAgo(date);
                const sizeKB = Math.round(snapshot.size / 1024);
                
                html += `
                    <div class="edit-item" style="padding: 12px; border-bottom: 1px solid var(--border-color);">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-size: 12px; font-weight: 500; color: var(--text-primary); margin-bottom: 4px;">
                                    ${escapeHtml(snapshot.reason)}
                                </div>
                                <div style="font-size: 11px; color: var(--text-secondary);">
                                    ${timeAgo} â€¢ ${sizeKB} KB
                                </div>
                            </div>
                        </div>
                        <div class="edit-item-actions" style="display: flex; gap: 8px; margin-top: 8px;">
                            <button class="btn btn-secondary" onclick="viewSnapshotDiff('${snapshot.id}')" title="View changes" style="flex: 1; font-size: 11px;">
                                ðŸ‘ï¸ View
                            </button>
                            <button class="btn btn-primary" onclick="restoreSnapshot('${snapshot.id}')" title="Restore this version" style="flex: 1; font-size: 11px;">
                                â†©ï¸ Restore
                            </button>
                            <button class="btn btn-secondary" onclick="deleteSnapshot('${snapshot.id}')" title="Delete snapshot" style="padding: 4px 8px; font-size: 11px;">
                                ðŸ—‘ï¸
                            </button>
                        </div>
                    </div>
                `;
            }
            
            listEl.innerHTML = html;
        }

        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            if (seconds < 60) return 'Just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
            return date.toLocaleDateString();
        }

        async function createSnapshot(filePath, content, reason = 'Manual snapshot') {
            try {
                const response = await fetch('/api/snapshots', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filePath, content, reason })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log(`[SNAPSHOT] Created: ${reason}`);
                    return data.id;
                } else {
                    console.error('[SNAPSHOT] Failed:', data.error);
                    return null;
                }
            } catch (error) {
                console.error('[SNAPSHOT] Error:', error);
                return null;
            }
        }

        async function viewSnapshotDiff(snapshotId) {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;
            
            try {
                const response = await fetch(`/api/snapshots/${snapshotId}?filePath=${encodeURIComponent(activeFile)}`);
                const data = await response.json();
                
                if (!data.success) {
                    showToast('Failed to load snapshot', 'error');
                    return;
                }
                
                const currentContent = fileData.model.getValue();
                const snapshotContent = data.snapshot.content;
                
                showDiffPreview(snapshotContent, currentContent, () => {
                    restoreSnapshot(snapshotId);
                }, 'Snapshot vs Current');
            } catch (error) {
                console.error('Error viewing snapshot:', error);
                showToast('Error loading snapshot', 'error');
            }
        }

        async function restoreSnapshot(snapshotId) {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;
            
            if (!confirm('Restore this version? Current changes will be replaced.')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/snapshots/${snapshotId}?filePath=${encodeURIComponent(activeFile)}`);
                const data = await response.json();
                
                if (!data.success) {
                    showToast('Failed to load snapshot', 'error');
                    return;
                }
                
                // Create a snapshot of current state before restoring
                await createSnapshot(activeFile, fileData.model.getValue(), 'Before restore');
                
                // Restore the snapshot content
                fileData.model.setValue(data.snapshot.content);
                markFileAsModified(activeFile);
                
                showToast(`Restored from ${new Date(data.snapshot.timestamp).toLocaleString()}`, 'success');
                
                // Refresh snapshot list
                await loadSnapshotHistory();
            } catch (error) {
                console.error('Error restoring snapshot:', error);
                showToast('Error restoring snapshot', 'error');
            }
        }

        async function deleteSnapshot(snapshotId) {
            if (!confirm('Delete this snapshot?')) {
                return;
            }
            
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;
            
            try {
                const response = await fetch(`/api/snapshots/${snapshotId}?filePath=${encodeURIComponent(activeFile)}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showToast('Snapshot deleted', 'success');
                    await loadSnapshotHistory();
                } else {
                    showToast('Failed to delete snapshot', 'error');
                }
            } catch (error) {
                console.error('Error deleting snapshot:', error);
                showToast('Error deleting snapshot', 'error');
            }
        }

        async function clearAllSnapshots() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;
            
            if (!confirm('Delete all snapshots for this file?')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/snapshots?filePath=${encodeURIComponent(activeFile)}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showToast('All snapshots cleared', 'success');
                    await loadSnapshotHistory();
                } else {
                    showToast('Failed to clear snapshots', 'error');
                }
            } catch (error) {
                console.error('Error clearing snapshots:', error);
                showToast('Error clearing snapshots', 'error');
            }
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        // Start a new conversation on load
        chatHistory.startNewConversation();
        
        if (IDE_MODE === 'picker') {
            showSystemPickerModal();
        } else {
            initializeMonaco();
        }

        // ============================================================================
        // SYSTEM PICKER
        // ============================================================================
        
        async function showSystemPickerModal() {
            try {
                const response = await fetch('/api/compiled-docs/all');
                const data = await response.json();
                
                if (!data.success || data.systems.length === 0) {
                    document.getElementById('loading-overlay').innerHTML = `
                        <div style="text-align: center;">
                            <div style="font-size: 18px; margin-bottom: 12px;">ðŸ“¦ No Compiled Systems Yet</div>
                            <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 20px;">
                                Compile your first system from the Query tab in Intelligence.
                            </div>
                            <a href="/intelligence" 
                               style="background: #0e639c; color: white; padding: 10px 20px; border-radius: 6px; text-decoration: none; font-size: 13px;">
                                Go to Intelligence Dashboard
                            </a>
                        </div>
                    `;
                    return;
                }
                
                let html = `
                    <div style="text-align: center; max-width: 500px;">
                        <div style="font-size: 18px; margin-bottom: 8px; color: var(--text-primary);">Select Documentation System</div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 20px;">
                            ${data.systems.length} compiled ${data.systems.length === 1 ? 'system' : 'systems'} available
                        </div>
                        <select id="initial-system-picker" 
                                style="width: 100%; padding: 10px; background: var(--border-color); border: 1px solid #5a5a5a; color: var(--text-primary); border-radius: 4px; font-size: 13px; margin-bottom: 16px;">
                `;
                
                const byRun = {};
                data.systems.forEach(sys => {
                    if (!byRun[sys.runName]) byRun[sys.runName] = [];
                    byRun[sys.runName].push(sys);
                });
                
                for (const [run, systems] of Object.entries(byRun)) {
                    html += `<optgroup label="${run}">`;
                    systems.forEach(sys => {
                        const label = `${sys.systemId} (${sys.mdFiles} docs, ${sys.queryCount || 0} queries)`;
                        html += `<option value="${sys.runName}:${sys.systemId}">${label}</option>`;
                    });
                    html += `</optgroup>`;
                }
                
                html += `
                        </select>
                        <button onclick="loadSelectedSystem()" 
                                style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px 24px; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
                            ðŸ“ Open Compiled Docs
                        </button>
                        <div style="margin: 20px 0; text-align: center; color: var(--text-secondary); font-size: 12px;">
                            â”€â”€â”€â”€â”€â”€â”€ OR â”€â”€â”€â”€â”€â”€â”€
                        </div>
                        <button onclick="showFolderBrowser()" 
                                style="width: 100%; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 12px 24px; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
                            ðŸ“‚ Browse for Folder...
                        </button>
                    </div>
                `;
                
                document.getElementById('loading-overlay').innerHTML = html;
                
            } catch (error) {
                document.getElementById('loading-overlay').innerHTML = `
                    <div style="color: var(--error-color);">Failed to load systems: ${error.message}</div>
                `;
            }
        }
        
        function loadSelectedSystem() {
            const picker = document.getElementById('initial-system-picker');
            const value = picker.value;
            if (!value) return;
            const [run, system] = value.split(':');
            window.location.href = `/docs-ide?run=${run}&system=${system}`;
        }

        function goBackToPicker() {
            // Go back to picker screen
            window.location.href = '/docs-ide';
        }

        // ============================================================================
        // MONACO EDITOR INITIALIZATION
        // ============================================================================
        
        function initializeMonaco() {
            loadAvailableSystems();
            
            require.config({ 
                paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' } 
            });

            require(['vs/editor/editor.main'], async function() {
                console.log('Monaco Editor loaded');

                // Create editor instance
                editor = monaco.editor.create(document.getElementById('monaco-editor'), {
                    theme: settings.theme,
                    fontSize: settings.fontSize,
                    lineNumbers: settings.lineNumbers ? 'on' : 'off',
                    minimap: { enabled: settings.minimap },
                    scrollBeyondLastLine: false,
                    wordWrap: settings.wordWrap ? 'on' : 'off',
                    automaticLayout: true,
                    renderWhitespace: 'selection',
                    tabSize: settings.tabSize,
                    insertSpaces: true,
                    folding: true,
                    lineDecorationsWidth: 10,
                    lineNumbersMinChars: 4,
                    glyphMargin: false,
                    overviewRulerBorder: false,
                    hideCursorInOverviewRuler: true,
                    find: {
                        seedSearchStringFromSelection: 'always',
                        autoFindInSelection: 'never'
                    }
                });

                // Event handlers
                editor.onDidChangeCursorPosition((e) => {
                    document.getElementById('status-line').textContent = 
                        `Ln ${e.position.lineNumber}, Col ${e.position.column}`;
                    updateSelectionInfo();
                });

                editor.onDidChangeCursorSelection(() => {
                    updateSelectionInfo();
                });

                editor.onDidChangeModelContent(() => {
                    if (activeFile) {
                        const fileData = openFiles.get(activeFile);
                        if (fileData && !fileData.dirty) {
                            fileData.dirty = true;
                            updateTabDirtyState(activeFile, true);
                            updateSaveButtons();
                        }
                        updateFileStats();
                        schedulePreviewUpdate();
                    }
                });

                // Add context menu actions for AI
                editor.addAction({
                    id: 'ai-improve-selection',
                    label: 'ðŸ¤– AI: Improve Selection',
                    contextMenuGroupId: 'ai',
                    contextMenuOrder: 1,
                    run: async function(ed) {
                        const selection = ed.getSelection();
                        if (selection && !selection.isEmpty()) {
                            // Open AI panel if closed
                            const aiPanel = document.getElementById('ai-panel');
                            if (aiPanel.classList.contains('hidden')) {
                                toggleAI();
                            }
                            // Set quick action
                            await aiQuickAction('improve');
                        }
                    }
                });

                editor.addAction({
                    id: 'ai-fix-grammar',
                    label: 'âœ“ AI: Check Grammar',
                    contextMenuGroupId: 'ai',
                    contextMenuOrder: 2,
                    run: async function(ed) {
                        const aiPanel = document.getElementById('ai-panel');
                        if (aiPanel.classList.contains('hidden')) {
                            toggleAI();
                        }
                        await aiQuickAction('grammar');
                    }
                });

                editor.addAction({
                    id: 'ai-custom',
                    label: 'ðŸ’¬ Ask AI About This...',
                    contextMenuGroupId: 'ai',
                    contextMenuOrder: 3,
                    run: function(ed) {
                        const aiPanel = document.getElementById('ai-panel');
                        if (aiPanel.classList.contains('hidden')) {
                            toggleAI();
                        }
                        document.getElementById('ai-input').focus();
                    }
                });

                // Keyboard shortcuts
                setupKeyboardShortcuts();

                // Hide loading overlay
                document.getElementById('loading-overlay').classList.add('hidden');

                // Load file tree (skip in picker mode)
                if (IDE_MODE !== 'picker') {
                await loadFileTree();
                }
                
                // Restore workspace state
                restoreWorkspaceState();
            });
        }

        // ============================================================================
        // KEYBOARD SHORTCUTS
        // ============================================================================
        
        function setupKeyboardShortcuts() {
            // Save
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_S,
                () => saveCurrentFile()
            );

            // Save All
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_S,
                () => saveAllFiles()
            );

            // Close Tab
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_W,
                () => { if (activeFile) closeTab(activeFile); }
            );

            // Command Palette
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_P,
                () => toggleCommandPalette()
            );

            // Quick Open
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_P,
                () => toggleCommandPalette('file')
            );

            // Find
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_F,
                () => toggleSearch()
            );

            // Toggle Sidebar
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_B,
                () => toggleSidebar()
            );

            // Settings
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.US_COMMA,
                () => toggleSettings()
            );

            // Recent Files
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_E,
                () => showRecentFiles()
            );

            // Find in Files
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_F,
                () => showFindInFiles()
            );

            // Toggle AI Panel
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_K,
                () => {
                    // Wait for next key
                    const nextKeyHandler = (e) => {
                        if (e.key === 'a' || e.key === 'A') {
                            toggleAI();
                            document.removeEventListener('keydown', nextKeyHandler);
                        }
                    };
                    document.addEventListener('keydown', nextKeyHandler);
                    setTimeout(() => document.removeEventListener('keydown', nextKeyHandler), 2000);
                }
            );

            // Global keyboard listener for non-editor shortcuts
            document.addEventListener('keydown', (e) => {
                // Escape - close modals
                if (e.key === 'Escape') {
                    closeAllModals();
                }
                
                // Cmd/Ctrl+? - help (changed from plain ? to allow typing question marks)
                if (e.key === '?' && (e.metaKey || e.ctrlKey)) {
                    toggleKeyboardHelp();
                    e.preventDefault();
                }
                
                // Arrow navigation in command palette
                const palette = document.getElementById('command-palette');
                if (!palette.classList.contains('hidden')) {
                    if (e.key === 'ArrowDown') {
                        navigateCommands(1);
                        e.preventDefault();
                    } else if (e.key === 'ArrowUp') {
                        navigateCommands(-1);
                        e.preventDefault();
                    } else if (e.key === 'Enter') {
                        executeSelectedCommand();
                        e.preventDefault();
                    }
                }
            });
        }

        // ============================================================================
        // FILE TREE
        // ============================================================================
        
        async function loadFileTree() {
            try {
                if (!folderPath) return;  // No folder selected yet
                const data = await FileAPI.listFiles();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to load files');
                }

                allFiles = data.files;

                const tree = document.getElementById('file-tree');
                tree.innerHTML = '';

                if (allFiles.length === 0) {
                    tree.innerHTML = '<div style="padding: 16px; color: var(--text-secondary); font-size: 12px;">No files found</div>';
                    return;
                }

                // Build hierarchical tree from flat list
                const treeStructure = buildTreeStructure(allFiles, folderPath);
                renderTree(treeStructure, tree);

                // Auto-open file
                let fileToOpen = null;
                
                if (initialFileName) {
                    fileToOpen = findFileInTree(allFiles, initialFileName);
                }
                
                if (!fileToOpen) {
                    fileToOpen = findFileInTree(allFiles, 'INDEX.md');
                }
                
                if (fileToOpen) {
                    setTimeout(() => openFile(fileToOpen.path, fileToOpen.name), 100);
                }

            } catch (error) {
                console.error('Failed to load file tree:', error);
                showToast('Failed to load files: ' + error.message, 'error');
            }
        }

        function buildTreeStructure(flatFiles, rootPath) {
            const tree = {};
            
            flatFiles.forEach(file => {
                // Get relative path from root
                const relativePath = file.path.startsWith(rootPath) 
                    ? file.path.substring(rootPath.length).replace(/^\//, '')
                    : file.path;
                
                if (!relativePath) return; // Skip root itself
                
                const parts = relativePath.split('/');
                let current = tree;
                
                // Build nested structure
                parts.forEach((part, index) => {
                    if (!current[part]) {
                        const isLastPart = index === parts.length - 1;
                        current[part] = {
                            name: part,
                            path: file.path,
                            isDirectory: isLastPart ? file.isDirectory : true,
                            children: {}
                        };
                    }
                    current = current[part].children;
                });
            });
            
            // Convert to array format
            const treeToArray = (obj) => {
                return Object.values(obj).map(item => ({
                    name: item.name,
                    path: item.path,
                    isDirectory: item.isDirectory,
                    children: item.isDirectory && Object.keys(item.children).length > 0 
                        ? treeToArray(item.children)
                        : []
                })).sort((a, b) => {
                    // Directories first, then alphabetical
                    if (a.isDirectory && !b.isDirectory) return -1;
                    if (!a.isDirectory && b.isDirectory) return 1;
                    return a.name.localeCompare(b.name);
                });
            };
            
            return treeToArray(tree);
        }
        
        function renderTree(items, container) {
            items.forEach(item => {
                const treeItem = document.createElement('div');
                treeItem.className = 'tree-item';
                
                if (item.isDirectory) {
                    const folderHeader = document.createElement('div');
                    folderHeader.className = 'folder-item';
                    folderHeader.dataset.path = item.path; // Add path for breadcrumb navigation
                    folderHeader.innerHTML = `
                        <span class="folder-chevron">â–¶</span>
                        <span class="folder-icon">ðŸ“</span>
                        <span>${item.name}</span>
                    `;
                    
                    const folderContents = document.createElement('div');
                    folderContents.className = 'folder-contents collapsed';
                    
                    folderHeader.onclick = (e) => {
                        e.stopPropagation();
                        const chevron = folderHeader.querySelector('.folder-chevron');
                        chevron.classList.toggle('expanded');
                        folderContents.classList.toggle('collapsed');
                    };
                    
                    // Context menu for folders
                    folderHeader.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showContextMenu(e.clientX, e.clientY, item.path);
                    });
                    
                    treeItem.appendChild(folderHeader);
                    treeItem.appendChild(folderContents);
                    
                    if (item.children && item.children.length > 0) {
                        renderTree(item.children, folderContents);
                    }
                } else {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.dataset.path = item.path;
                    
                    const icon = getFileIcon(item.name);
                    
                    fileItem.innerHTML = `
                        <span class="file-icon">${icon}</span>
                        <span>${item.name}</span>
                    `;
                    
                    fileItem.onclick = () => openFile(item.path, item.name);
                    
                    // Context menu (Cursor-style)
                    fileItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showContextMenu(e.clientX, e.clientY, item.path);
                    });
                    
                    treeItem.appendChild(fileItem);
                }
                
                container.appendChild(treeItem);
            });
        }

        function findFileInTree(items, fileName) {
            for (const item of items) {
                if (item.type !== 'directory' && item.name === fileName) {
                    return item;
                }
                if (item.children) {
                    const found = findFileInTree(item.children, fileName);
                    if (found) return found;
                }
            }
            return null;
        }

        // ============================================================================
        // FILE OPERATIONS
        // ============================================================================
        
        async function openFile(filePath, fileName) {
            if (openFiles.has(filePath)) {
                setActiveFile(filePath);
                return;
            }

            try {
                // Check if this is a special file type that needs handling
                const ext = fileName.split('.').pop().toLowerCase();
                const isOfficeFile = ['docx', 'xlsx', 'xls', 'msg'].includes(ext);
                const isImageFile = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico'].includes(ext);
                
                let fileContent = '';
                let isReadOnly = false;
                
                if (isImageFile) {
                    // Image files - show placeholder and auto-open preview
                    fileContent = `============================================
IMAGE FILE: ${fileName}
File Type: ${ext.toUpperCase()}
This is a binary image file.
Click the Preview button (Cmd+K V) to view the image.
============================================

Image path: ${filePath}

To view this image:
1. Click the Preview button (ðŸ‘ï¸) in the toolbar
2. Or press Cmd+K V

The image will be displayed in the preview pane.`;
                    isReadOnly = true;
                } else if (isOfficeFile) {
                    // Extract text content from Office files
                    const response = await fetch(`/api/extract-office-text?path=${encodeURIComponent(filePath)}`);
                    const result = await response.json();
                    
                    if (result.success) {
                        // Add a header explaining this is extracted content
                        fileContent = `============================================
EXTRACTED CONTENT FROM: ${fileName}
File Type: ${ext.toUpperCase()}
This is a READ-ONLY view of the extracted text.
Click the Preview button (Cmd+K V) to see formatted version.
============================================

${result.content}`;
                        isReadOnly = true;
                    } else {
                        throw new Error(result.error || 'Failed to extract content from Office file');
                    }
                } else {
                    // Regular text file
                    const data = await FileAPI.readFile(filePath);

                    if (!data.success) {
                        throw new Error(data.error || 'Failed to load file');
                    }
                    
                    fileContent = data.content;
                }

                const language = detectLanguage(fileName);

                // Check if model already exists and dispose it
                const uri = monaco.Uri.file(filePath);
                let model = monaco.editor.getModel(uri);
                
                if (model) {
                    // Model exists - dispose it first
                    model.dispose();
                }
                
                // Create new model
                model = monaco.editor.createModel(
                    fileContent,
                    language,
                    uri
                );
                
                // Make Office files read-only
                if (isReadOnly) {
                    model.updateOptions({ readOnly: true });
                }

                openFiles.set(filePath, {
                    model,
                    dirty: false,
                    name: fileName,
                    path: filePath,
                    originalContent: fileContent,
                    isOfficeFile: isOfficeFile,
                    isImageFile: isImageFile,
                    readOnly: isReadOnly
                });

                addTab(filePath, fileName);
                setActiveFile(filePath);

                console.log('Opened:', fileName, 'Language:', language, 
                    isOfficeFile ? '(Office File - Read Only)' : 
                    isImageFile ? '(Image File)' : '');
                
                // Auto-open preview for Office files and images
                if (isOfficeFile || isImageFile) {
                    const previewPane = document.getElementById('preview-pane');
                    if (previewPane.classList.contains('hidden')) {
                        togglePreview();
                    }
                }

            } catch (error) {
                console.error('Failed to open file:', error);
                showToast('Failed to open file: ' + error.message, 'error');
            }
        }

        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const iconMap = {
                // Office Documents
                'docx': 'ðŸ“„',
                'doc': 'ðŸ“„',
                'xlsx': 'ðŸ“Š',
                'xls': 'ðŸ“Š',
                'pptx': 'ðŸ“½ï¸',
                'ppt': 'ðŸ“½ï¸',
                'msg': 'ðŸ“§',
                
                // Code Files
                'js': 'ðŸ“œ',
                'jsx': 'âš›ï¸',
                'ts': 'ðŸ“˜',
                'tsx': 'âš›ï¸',
                'py': 'ðŸ',
                'java': 'â˜•',
                'cpp': 'âš™ï¸',
                'c': 'âš™ï¸',
                'h': 'âš™ï¸',
                'cs': '#ï¸âƒ£',
                'go': 'ðŸ”·',
                'rs': 'ðŸ¦€',
                'php': 'ðŸ˜',
                'rb': 'ðŸ’Ž',
                'swift': 'ðŸ¦',
                'kt': 'ðŸŸ£',
                
                // Web
                'html': 'ðŸŒ',
                'htm': 'ðŸŒ',
                'css': 'ðŸŽ¨',
                'scss': 'ðŸŽ¨',
                'sass': 'ðŸŽ¨',
                'less': 'ðŸŽ¨',
                'vue': 'ðŸ’š',
                
                // Data
                'json': 'ðŸ“‹',
                'xml': 'ðŸ“‹',
                'yaml': 'ðŸ“‹',
                'yml': 'ðŸ“‹',
                'csv': 'ðŸ“Š',
                'tsv': 'ðŸ“Š',
                'sql': 'ðŸ—„ï¸',
                
                // Documentation
                'md': 'ðŸ“',
                'markdown': 'ðŸ“',
                'txt': 'ðŸ“„',
                'pdf': 'ðŸ“•',
                
                // Images
                'png': 'ðŸ–¼ï¸',
                'jpg': 'ðŸ–¼ï¸',
                'jpeg': 'ðŸ–¼ï¸',
                'gif': 'ðŸ–¼ï¸',
                'svg': 'ðŸŽ¨',
                'ico': 'ðŸ–¼ï¸',
                'webp': 'ðŸ–¼ï¸',
                
                // Config
                'env': 'âš™ï¸',
                'config': 'âš™ï¸',
                'conf': 'âš™ï¸',
                'ini': 'âš™ï¸',
                'toml': 'âš™ï¸',
                
                // Archives
                'zip': 'ðŸ“¦',
                'tar': 'ðŸ“¦',
                'gz': 'ðŸ“¦',
                'rar': 'ðŸ“¦',
                '7z': 'ðŸ“¦',
                
                // Other
                'sh': 'âš¡',
                'bash': 'âš¡',
                'zsh': 'âš¡',
                'log': 'ðŸ“œ',
                'lock': 'ðŸ”’'
            };
            return iconMap[ext] || 'ðŸ“„';
        }

        function detectLanguage(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const langMap = {
                'md': 'markdown',
                'markdown': 'markdown',
                'json': 'json',
                'js': 'javascript',
                'ts': 'typescript',
                'py': 'python',
                'html': 'html',
                'css': 'css',
                'yaml': 'yaml',
                'yml': 'yaml',
                'csv': 'csv',
                'tsv': 'csv',
                'txt': 'plaintext'
            };
            return langMap[ext] || 'plaintext';
        }

        function setActiveFile(filePath) {
            activeFile = filePath;
            const fileData = openFiles.get(filePath);

            if (!fileData) return;

            editor.setModel(fileData.model);

            document.querySelectorAll('.file-item').forEach(item => {
                item.classList.toggle('active', item.dataset.path === filePath);
            });

            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.path === filePath);
            });

            document.getElementById('status-file').textContent = fileData.name;
            document.getElementById('status-lang').textContent = 
                fileData.model.getLanguageId().toUpperCase();

            updateSaveButtons();
            updateFileStats();
            
            // Show/hide preview button for previewable file types
            const language = fileData.model.getLanguageId();
            const fileName = fileData.name.toLowerCase();
            const isImage = /\.(png|jpg|jpeg|gif|webp|svg|bmp|ico)$/i.test(fileName);
            const isPDF = fileName.endsWith('.pdf');
            const isOfficeFile = /\.(docx|xlsx|xls|msg)$/i.test(fileName);
            const isPreviewable = ['markdown', 'html', 'json', 'css', 'svg'].includes(language) || isImage || isPDF || isOfficeFile;
            document.getElementById('preview-btn').style.display = isPreviewable ? 'flex' : 'none';
            
            // Update preview if it's open and file is previewable
            const previewPane = document.getElementById('preview-pane');
            if (isPreviewable && !previewPane.classList.contains('hidden')) {
                updatePreview();
                updatePreviewHeader();
            } else if (!isPreviewable && !previewPane.classList.contains('hidden')) {
                // Hide preview if switching to non-previewable file
                previewPane.classList.add('hidden');
            }
            
            updateBreadcrumb();
            addToRecentFiles(filePath, fileData.name);
            saveWorkspaceState();
        }
        
        function updateBreadcrumb() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            const breadcrumbBar = document.getElementById('breadcrumb-bar');
            
            if (!fileData) {
                breadcrumbBar.style.display = 'none';
                return;
            }
            
            breadcrumbBar.style.display = 'flex';
            const fullPath = activeFile;
            const pathParts = fullPath.split('/').filter(p => p);
            
            let html = '';
            let currentPath = '';
            
            for (let i = 0; i < pathParts.length; i++) {
                const part = pathParts[i];
                currentPath += '/' + part;
                const isLast = i === pathParts.length - 1;
                const partPath = currentPath;
                
                if (i > 0) {
                    html += `<span class="breadcrumb-separator">â–¸</span>`;
                }
                
                if (isLast) {
                    // Last item (filename) - not clickable
                    html += `<span class="breadcrumb-item active">${part}</span>`;
                } else {
                    // Folder - clickable
                    html += `<span class="breadcrumb-item" onclick="openFolderInTree('${partPath.replace(/'/g, "\\'")}')" title="Open folder in tree">${part}</span>`;
                }
            }
            
            breadcrumbBar.innerHTML = html;
        }
        
        function openFolderInTree(folderPath) {
            // Expand the folder in the file tree
            const folders = document.querySelectorAll('.folder-item');
            folders.forEach(folder => {
                const path = folder.dataset.path;
                if (path === folderPath) {
                    const folderContents = folder.querySelector('.folder-contents');
                    const chevron = folder.querySelector('.folder-chevron');
                    if (folderContents && chevron) {
                        folderContents.classList.remove('collapsed');
                        chevron.classList.add('expanded');
                    }
                    // Scroll into view
                    folder.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            });
        }
        
        function addToRecentFiles(filePath, fileName) {
            // Remove if already in list
            recentFiles = recentFiles.filter(f => f.path !== filePath);
            
            // Add to front
            recentFiles.unshift({ path: filePath, name: fileName, timestamp: Date.now() });
            
            // Limit size
            if (recentFiles.length > MAX_RECENT_FILES) {
                recentFiles = recentFiles.slice(0, MAX_RECENT_FILES);
            }
            
            // Save to localStorage
            try {
                if (folderPath) localStorage.setItem(`cosmo-recent-files-${folderPath}`, JSON.stringify(recentFiles));
            } catch (e) {
                console.error('Failed to save recent files:', e);
            }
        }
        
        function loadRecentFiles() {
            try {
                if (!folderPath) return;  // No folder selected yet
                const saved = folderPath ? localStorage.getItem(`cosmo-recent-files-${folderPath}`) : null;
                if (saved) {
                    recentFiles = JSON.parse(saved);
                }
            } catch (e) {
                console.error('Failed to load recent files:', e);
                recentFiles = [];
            }
        }
        
        function showRecentFiles() {
            if (recentFiles.length === 0) {
                showToast('No recent files', 'error');
                return;
            }
            
            // Show in command palette
            toggleCommandPalette('recent');
        }

        async function saveCurrentFile() {
            if (!activeFile) return;

            const fileData = openFiles.get(activeFile);
            if (!fileData || !fileData.dirty) return;

            try {
                const content = fileData.model.getValue();

                const data = await FileAPI.writeFile(fileData.path, content);

                if (!data.success) {
                    throw new Error(data.error || 'Save failed');
                }

                fileData.dirty = false;
                fileData.originalContent = content;
                updateTabDirtyState(activeFile, false);
                updateSaveButtons();

                showToast(`Saved: ${fileData.name}`, 'success');
                console.log('Saved:', fileData.path);

            } catch (error) {
                console.error('Save failed:', error);
                showToast('Save failed: ' + error.message, 'error');
            }
        }

        async function saveAllFiles() {
            const dirtyFiles = Array.from(openFiles.entries())
                .filter(([path, data]) => data.dirty);

            if (dirtyFiles.length === 0) {
                showToast('No files to save', 'info');
                return;
            }

            let savedCount = 0;
            let failedCount = 0;

            showToast(`Saving ${dirtyFiles.length} file(s)...`, 'info');

            for (const [filePath, fileData] of dirtyFiles) {
                try {
                    const content = fileData.model.getValue();

                    const data = await FileAPI.writeFile(fileData.path, content);

                    if (data.success) {
                        fileData.dirty = false;
                        fileData.originalContent = content;
                        updateTabDirtyState(filePath, false);
                        savedCount++;
                    } else {
                        failedCount++;
                    }

                } catch (error) {
                    console.error('Failed to save:', fileData.path, error);
                    failedCount++;
                }
            }

            updateSaveButtons();

            if (failedCount === 0) {
                showToast(`âœ… Saved ${savedCount} ${savedCount === 1 ? 'file' : 'files'}`, 'success');
            } else {
                showToast(`âš ï¸ Saved ${savedCount}, failed ${failedCount}`, 'error');
            }
        }

        // ============================================================================
        // TAB MANAGEMENT
        // ============================================================================
        
        function addTab(filePath, fileName) {
            const tab = document.createElement('button');
            tab.className = 'tab';
            if (pinnedTabs.has(filePath)) {
                tab.classList.add('pinned');
            }
            tab.dataset.path = filePath;
            tab.draggable = true;
            
            // Create tab content
            const pinIcon = document.createElement('span');
            pinIcon.className = 'tab-pin';
            pinIcon.textContent = pinnedTabs.has(filePath) ? 'ðŸ“Œ' : 'ðŸ“';
            pinIcon.title = pinnedTabs.has(filePath) ? 'Unpin tab' : 'Pin tab';
            pinIcon.onclick = (e) => {
                e.stopPropagation();
                togglePinTab(filePath);
            };
            
            const tabName = document.createElement('span');
            tabName.className = 'tab-name';
            tabName.textContent = fileName;
            
            const closeBtn = document.createElement('span');
            closeBtn.className = 'tab-close';
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                closeTab(filePath);
            };
            
            tab.appendChild(pinIcon);
            tab.appendChild(tabName);
            tab.appendChild(closeBtn);
            tab.onclick = () => setActiveFile(filePath);
            
            // Drag and drop handlers
            tab.addEventListener('dragstart', handleTabDragStart);
            tab.addEventListener('dragover', handleTabDragOver);
            tab.addEventListener('drop', handleTabDrop);
            tab.addEventListener('dragend', handleTabDragEnd);
            
            // Context menu (right-click)
            tab.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showContextMenu(e.clientX, e.clientY, filePath);
            });
            
            // Insert tab in correct position (pinned tabs first)
            const tabsBar = document.getElementById('tabs-bar');
            if (pinnedTabs.has(filePath)) {
                // Find position among pinned tabs
                const pinnedTabElements = Array.from(tabsBar.querySelectorAll('.tab.pinned'));
                tabsBar.insertBefore(tab, pinnedTabElements[pinnedTabElements.length] || tabsBar.firstChild);
            } else {
                tabsBar.appendChild(tab);
            }
        }
        
        // Tab drag and drop
        let draggedTab = null;
        
        function handleTabDragStart(e) {
            draggedTab = e.currentTarget;
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', e.currentTarget.dataset.path);
        }
        
        function handleTabDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            
            const target = e.currentTarget;
            if (target !== draggedTab && target.classList.contains('tab')) {
                target.classList.add('drag-over');
            }
            return false;
        }
        
        function handleTabDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            const target = e.currentTarget;
            target.classList.remove('drag-over');
            
            if (draggedTab !== target) {
                const tabsBar = document.getElementById('tabs-bar');
                const allTabs = Array.from(tabsBar.children);
                const draggedIndex = allTabs.indexOf(draggedTab);
                const targetIndex = allTabs.indexOf(target);
                
                if (draggedIndex < targetIndex) {
                    tabsBar.insertBefore(draggedTab, target.nextSibling);
                } else {
                    tabsBar.insertBefore(draggedTab, target);
                }
            }
            
            return false;
        }
        
        function handleTabDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('drag-over');
            });
        }
        
        function togglePinTab(filePath) {
            if (pinnedTabs.has(filePath)) {
                pinnedTabs.delete(filePath);
            } else {
                pinnedTabs.add(filePath);
            }
            
            // Update tab appearance
            const tab = document.querySelector(`.tab[data-path="${filePath}"]`);
            if (tab) {
                tab.classList.toggle('pinned');
                const pinIcon = tab.querySelector('.tab-pin');
                if (pinIcon) {
                    pinIcon.textContent = pinnedTabs.has(filePath) ? 'ðŸ“Œ' : 'ðŸ“';
                    pinIcon.title = pinnedTabs.has(filePath) ? 'Unpin tab' : 'Pin tab';
                }
                
                // Move tab to correct position
                const tabsBar = document.getElementById('tabs-bar');
                tab.remove();
                
                if (pinnedTabs.has(filePath)) {
                    const pinnedTabElements = Array.from(tabsBar.querySelectorAll('.tab.pinned'));
                    tabsBar.insertBefore(tab, pinnedTabElements[pinnedTabElements.length] || tabsBar.firstChild);
                } else {
                    const firstUnpinned = tabsBar.querySelector('.tab:not(.pinned)');
                    if (firstUnpinned) {
                        tabsBar.insertBefore(tab, firstUnpinned.nextSibling);
                    } else {
                        tabsBar.appendChild(tab);
                    }
                }
            }
            
            saveWorkspaceState();
        }

        function closeTab(filePath) {
            const fileData = openFiles.get(filePath);

            if (!fileData) return;

            if (fileData.dirty) {
                if (!confirm(`File has unsaved changes. Close anyway?`)) {
                    return;
                }
            }

            fileData.model.dispose();
            openFiles.delete(filePath);

            const tab = document.querySelector(`.tab[data-path="${filePath}"]`);
            if (tab) {
                tab.remove();
            }

            if (activeFile === filePath) {
                const remainingFiles = Array.from(openFiles.keys());
                if (remainingFiles.length > 0) {
                    setActiveFile(remainingFiles[0]);
                } else {
                    activeFile = null;
                    editor.setModel(null);
                    document.getElementById('status-file').textContent = 'No file open';
                    document.getElementById('status-lang').textContent = '';
                    updateSaveButtons();
                }
            }
            
            saveWorkspaceState();
        }

        function updateTabDirtyState(filePath, dirty) {
            const tab = document.querySelector(`.tab[data-path="${filePath}"]`);
            if (!tab) return;

            const fileData = openFiles.get(filePath);
            const nameSpan = tab.querySelector('.tab-name');
            
            if (dirty) {
                nameSpan.textContent = 'â— ' + fileData.name;
            } else {
                nameSpan.textContent = fileData.name;
            }
        }

        // ============================================================================
        // COMMAND PALETTE
        // ============================================================================
        
        // Commands will be initialized after all functions are defined
        let commands = [];

        function toggleCommandPalette(mode = 'command') {
            const palette = document.getElementById('command-palette');
            const input = document.getElementById('command-input');
            const overlay = document.getElementById('overlay');
            
            if (palette.classList.contains('hidden')) {
                palette.classList.remove('hidden');
                overlay.classList.remove('hidden');
                input.value = '';
                
                if (mode === 'file') {
                    input.placeholder = 'Type to search files...';
                    renderFileCommands();
                } else if (mode === 'recent') {
                    input.placeholder = 'Recent files...';
                    renderRecentFileCommands();
                } else {
                    input.placeholder = 'Type a command or search files...';
                    renderCommands('');
                }
                
                input.focus();
                input.dataset.mode = mode;
            } else {
                palette.classList.add('hidden');
                overlay.classList.add('hidden');
            }
        }

        function renderCommands(query) {
            const results = document.getElementById('command-results');
            selectedCommandIndex = 0;
            
            let filtered = commands;
            
            if (query) {
                query = query.toLowerCase();
                filtered = commands.filter(cmd => 
                    cmd.label.toLowerCase().includes(query) ||
                    cmd.id.toLowerCase().includes(query)
                );
            }
            
            results.innerHTML = filtered.map((cmd, idx) => `
                <div class="command-item ${idx === 0 ? 'selected' : ''}" data-index="${idx}" onclick="executeCommand('${cmd.id}')">
                    <span class="command-label">${cmd.label}</span>
                    ${cmd.keys ? `<span class="command-keys">${cmd.keys}</span>` : ''}
                </div>
            `).join('');
        }

        function renderFileCommands() {
            const results = document.getElementById('command-results');
            selectedCommandIndex = 0;
            
            const flatFiles = [];
            const collectFiles = (items) => {
                items.forEach(item => {
                    if (item.type !== 'directory') {
                        flatFiles.push(item);
                    }
                    if (item.children) {
                        collectFiles(item.children);
                    }
                });
            };
            collectFiles(allFiles);
            
            results.innerHTML = flatFiles.map((file, idx) => `
                <div class="command-item ${idx === 0 ? 'selected' : ''}" data-index="${idx}" onclick="openFileFromPalette('${file.path}', '${file.name}')">
                    <span class="command-label">${file.path}</span>
                </div>
            `).join('');
        }
        
        function renderRecentFileCommands() {
            const results = document.getElementById('command-results');
            selectedCommandIndex = 0;
            
            if (recentFiles.length === 0) {
                results.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: var(--text-secondary);">
                        No recent files
                    </div>
                `;
                return;
            }
            
            results.innerHTML = recentFiles.map((file, idx) => {
                const timeAgo = formatTimeAgo(file.timestamp);
                return `
                    <div class="command-item ${idx === 0 ? 'selected' : ''}" data-index="${idx}" onclick="openFileFromPalette('${file.path}', '${file.name}')">
                        <span class="command-label">${file.name}</span>
                        <span class="command-keys">${timeAgo}</span>
                    </div>
                `;
            }).join('');
        }
        
        function formatTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }

        function executeCommand(commandId) {
            const cmd = commands.find(c => c.id === commandId);
            if (cmd && cmd.action) {
                cmd.action();
                toggleCommandPalette();
            }
        }

        function executeSelectedCommand() {
            const selected = document.querySelector('.command-item.selected');
            if (selected) {
                selected.click();
            }
        }

        function openFileFromPalette(path, name) {
            openFile(path, name);
            toggleCommandPalette();
        }

        function navigateCommands(direction) {
            const items = document.querySelectorAll('.command-item');
            if (items.length === 0) return;
            
            items[selectedCommandIndex].classList.remove('selected');
            selectedCommandIndex = (selectedCommandIndex + direction + items.length) % items.length;
            items[selectedCommandIndex].classList.add('selected');
            
            items[selectedCommandIndex].scrollIntoView({ block: 'nearest' });
        }

        // Listen to input changes
        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('command-input');
            if (input) {
                input.addEventListener('input', (e) => {
                    const query = e.target.value;
                    const mode = e.target.dataset.mode || 'command';
                    
                    if (mode === 'command') {
                        renderCommands(query);
                    } else if (mode === 'file') {
                        // Could filter files by query here
                        renderFileCommands();
                    } else if (mode === 'recent') {
                        // Could filter recent files by query here
                        renderRecentFileCommands();
                    }
                });
            }
            
            // Load recent files on startup
            loadRecentFiles();
        });

        // ============================================================================
        // MARKDOWN PREVIEW
        // ============================================================================
        
        function togglePreview() {
            const pane = document.getElementById('preview-pane');
            pane.classList.toggle('hidden');
            
            if (!pane.classList.contains('hidden')) {
                updatePreview();
                updatePreviewHeader();
            }
        }
        
        function updatePreviewHeader() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;
            
            const language = fileData.model.getLanguageId();
            const fileName = fileData.name.toLowerCase();
            const previewHeader = document.querySelector('.preview-header span');
            
            if (language === 'markdown') {
                previewHeader.textContent = 'ðŸ“„ Markdown Preview';
            } else if (language === 'html') {
                previewHeader.textContent = 'ðŸŒ HTML Preview';
            } else if (language === 'json') {
                previewHeader.textContent = 'ðŸ“Š JSON Viewer';
            } else if (language === 'css') {
                previewHeader.textContent = 'ðŸŽ¨ CSS Preview';
            } else if (language === 'svg' || fileName.endsWith('.svg')) {
                previewHeader.textContent = 'ðŸ–¼ï¸ SVG Preview';
            } else if (fileName.endsWith('.pdf')) {
                previewHeader.textContent = 'ðŸ“‘ PDF Viewer';
            } else if (/\.(png|jpg|jpeg|gif|webp|bmp|ico)$/i.test(fileName)) {
                previewHeader.textContent = 'ðŸ–¼ï¸ Image Preview';
            } else if (fileName.endsWith('.docx')) {
                previewHeader.textContent = 'ðŸ“„ Word Document Preview';
            } else if (/\.(xlsx|xls)$/i.test(fileName)) {
                previewHeader.textContent = 'ðŸ“Š Excel Spreadsheet Preview';
            } else if (fileName.endsWith('.msg')) {
                previewHeader.textContent = 'ðŸ“§ Outlook Message Preview';
            } else {
                previewHeader.textContent = 'ðŸ‘ï¸ Preview';
            }
        }

        function schedulePreviewUpdate() {
            if (document.getElementById('preview-pane').classList.contains('hidden')) return;
            
            clearTimeout(previewUpdateTimer);
            previewUpdateTimer = setTimeout(updatePreview, 500);
        }

        function updatePreview() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;
            
            const language = fileData.model.getLanguageId();
            const fileName = fileData.name.toLowerCase();
            const content = fileData.model.getValue();
            const previewContent = document.getElementById('preview-content');
            
            try {
                if (language === 'markdown') {
                    // Parse markdown to HTML
            const html = marked.parse(content);
                    previewContent.innerHTML = html;
                    
                } else if (language === 'html') {
                    // Render HTML in sandboxed iframe
                    previewContent.innerHTML = `
                        <iframe 
                            id="html-preview-frame" 
                            style="width: 100%; height: 100%; border: none; background: white;"
                            sandbox="allow-same-origin allow-scripts"
                        ></iframe>
                    `;
                    const iframe = document.getElementById('html-preview-frame');
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    iframeDoc.open();
                    iframeDoc.write(content);
                    iframeDoc.close();
                    
                } else if (language === 'json') {
                    // JSON formatted tree view
                    try {
                        const parsed = JSON.parse(content);
                        const formatted = JSON.stringify(parsed, null, 2);
                        previewContent.innerHTML = `
                            <div style="padding: 20px; font-family: 'Monaco', monospace; font-size: 13px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 16px; border-bottom: 1px solid #3e3e42; padding-bottom: 12px;">
                                    <strong style="color: var(--text-active);">JSON Structure</strong>
                                    <button onclick="copyJsonToClipboard()" class="btn btn-secondary" style="padding: 4px 12px; font-size: 11px;">
                                        Copy Formatted
                                    </button>
                                </div>
                                <div id="json-tree-view"></div>
                            </div>
                        `;
                        renderJsonTree(parsed, document.getElementById('json-tree-view'));
                    } catch (e) {
                        previewContent.innerHTML = `
                            <div style="color: var(--error-color); padding: 20px;">
                                <strong>Invalid JSON</strong><br>
                                ${e.message}
                                <pre style="margin-top: 12px; padding: 12px; background: var(--bg-secondary); border-radius: 4px; overflow-x: auto;">${content}</pre>
                            </div>
                        `;
                    }
                    
                } else if (language === 'css') {
                    // CSS preview with test HTML
                    previewContent.innerHTML = `
                        <iframe 
                            id="css-preview-frame" 
                            style="width: 100%; height: 100%; border: none; background: white;"
                            sandbox="allow-same-origin"
                        ></iframe>
                    `;
                    const iframe = document.getElementById('css-preview-frame');
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    const testHTML = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <style>${content}</style>
                        </head>
                        <body>
                            <h1>Heading 1</h1>
                            <h2>Heading 2</h2>
                            <h3>Heading 3</h3>
                            <p>This is a paragraph with <strong>bold</strong> and <em>italic</em> text.</p>
                            <p>Another paragraph with a <a href="#">link</a>.</p>
                            <ul>
                                <li>Unordered list item 1</li>
                                <li>Unordered list item 2</li>
                                <li>Unordered list item 3</li>
                            </ul>
                            <ol>
                                <li>Ordered list item 1</li>
                                <li>Ordered list item 2</li>
                                <li>Ordered list item 3</li>
                            </ol>
                            <button>Button</button>
                            <input type="text" placeholder="Text input" />
                            <table>
                                <tr><th>Header 1</th><th>Header 2</th></tr>
                                <tr><td>Cell 1</td><td>Cell 2</td></tr>
                                <tr><td>Cell 3</td><td>Cell 4</td></tr>
                            </table>
                            <div class="box">Box with class "box"</div>
                            <div id="special">Div with id "special"</div>
                        </body>
                        </html>
                    `;
                    iframeDoc.open();
                    iframeDoc.write(testHTML);
                    iframeDoc.close();
                    
                } else if (language === 'svg' || fileName.endsWith('.svg')) {
                    // SVG preview
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center; background: white; height: 100%; overflow: auto;">
                            ${content}
                        </div>
                    `;
                    
                } else if (fileName.endsWith('.pdf')) {
                    // PDF viewer (requires base64 encoded content or URL)
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center;">
                            <p style="color: var(--text-secondary); margin-bottom: 16px;">
                                PDF preview requires a URL or base64 encoded content.
                            </p>
                            <button onclick="downloadCurrentFile()" class="btn">
                                Download PDF to View
                            </button>
                        </div>
                    `;
                    
                } else if (/\.(png|jpg|jpeg|gif|webp|bmp|ico)$/i.test(fileName)) {
                    // Image preview - load image as base64 and display
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center; background: #f5f5f5; height: 100%; overflow: auto;">
                            <div style="color: #666; margin-bottom: 16px; font-size: 13px; font-weight: 600;">
                                ${fileData.name}
                            </div>
                            <div style="color: #999; margin-bottom: 16px;">
                                Loading image...
                            </div>
                        </div>
                    `;
                    
                    // Display image using server endpoint
                    const imageUrl = `/api/serve-file?path=${encodeURIComponent(activeFile)}`;
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center; background: #f5f5f5; height: 100%; overflow: auto; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                            <div style="color: #666; margin-bottom: 16px; font-size: 13px; font-weight: 600;">
                                ${fileData.name}
                            </div>
                            <div style="max-width: 100%; max-height: calc(100% - 100px); display: inline-block;">
                                <img src="${imageUrl}" 
                                     style="max-width: 100%; max-height: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);"
                                     onerror="this.style.display='none'; const err = document.createElement('div'); err.style.cssText='color:#e74c3c; padding: 20px;'; err.textContent='Unable to load image: ${fileData.name}'; this.parentElement.appendChild(err);"
                                     alt="${fileData.name}">
                            </div>
                            <div style="margin-top: 16px; font-size: 11px; color: #999; max-width: 600px; word-wrap: break-word;">
                                Path: ${activeFile}
                            </div>
                        </div>
                    `;
                    
                } else if (/\.(docx|xlsx|xls|msg)$/i.test(fileName)) {
                    // Office file preview - load HTML from server
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center;">
                            <div style="color: var(--text-secondary); margin-bottom: 16px;">
                                Loading preview...
                            </div>
                        </div>
                    `;
                    
                    // Fetch HTML preview from server
                    fetch(`/api/preview-office-file?path=${encodeURIComponent(activeFile)}`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`Failed to load preview: ${response.statusText}`);
                            }
                            return response.text();
                        })
                        .then(html => {
                            // Render in iframe for safety
                            previewContent.innerHTML = `
                                <iframe 
                                    id="office-preview-frame" 
                                    style="width: 100%; height: 100%; border: none; background: white;"
                                    sandbox="allow-same-origin"
                                ></iframe>
                            `;
                            const iframe = document.getElementById('office-preview-frame');
                            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                            iframeDoc.open();
                            iframeDoc.write(html);
                            iframeDoc.close();
                        })
                        .catch(error => {
                            previewContent.innerHTML = `
                                <div style="color: var(--error-color); padding: 20px;">
                                    <strong>Preview Error</strong><br>
                                    ${error.message}
                                    <br><br>
                                    <button onclick="downloadCurrentFile()" class="btn">
                                        Download File to View
                                    </button>
                                </div>
                            `;
                        });
                }
                
            } catch (error) {
                console.error('Preview error:', error);
                previewContent.innerHTML = 
                    `<div style="color: var(--error-color); padding: 20px;">
                        <strong>Preview Error</strong><br>
                        ${error.message}
                    </div>`;
            }
        }
        
        // Helper function to render JSON tree
        function renderJsonTree(obj, container, level = 0) {
            const indent = level * 20;
            
            if (obj === null) {
                container.innerHTML += `<div style="margin-left: ${indent}px; color: #569cd6;">null</div>`;
                return;
            }
            
            if (typeof obj !== 'object') {
                const color = typeof obj === 'string' ? '#ce9178' : 
                             typeof obj === 'number' ? '#b5cea8' : 
                             typeof obj === 'boolean' ? '#569cd6' : '#cccccc';
                const value = typeof obj === 'string' ? `"${obj}"` : String(obj);
                container.innerHTML += `<div style="margin-left: ${indent}px; color: ${color};">${value}</div>`;
                return;
            }
            
            const isArray = Array.isArray(obj);
            const entries = Object.entries(obj);
            
            if (entries.length === 0) {
                container.innerHTML += `<div style="margin-left: ${indent}px; color: #808080;">${isArray ? '[]' : '{}'}</div>`;
                return;
            }
            
            for (let i = 0; i < entries.length; i++) {
                const [key, value] = entries[i];
                const isLast = i === entries.length - 1;
                const isExpandable = value !== null && typeof value === 'object';
                
                const line = document.createElement('div');
                line.style.marginLeft = indent + 'px';
                line.style.marginTop = '2px';
                
                if (isExpandable) {
                    const toggle = document.createElement('span');
                    toggle.textContent = 'â–¼ ';
                    toggle.style.cursor = 'pointer';
                    toggle.style.color = '#808080';
                    toggle.style.fontSize = '10px';
                    toggle.style.marginRight = '4px';
                    
                    const keySpan = document.createElement('span');
                    keySpan.style.color = '#9cdcfe';
                    keySpan.textContent = isArray ? `[${key}]` : `"${key}"`;
                    
                    const colonSpan = document.createElement('span');
                    colonSpan.textContent = ': ';
                    colonSpan.style.color = '#cccccc';
                    
                    const typeSpan = document.createElement('span');
                    typeSpan.style.color = '#808080';
                    typeSpan.textContent = Array.isArray(value) ? `Array(${value.length})` : 'Object';
                    
                    const childContainer = document.createElement('div');
                    childContainer.style.marginLeft = '20px';
                    
                    toggle.onclick = () => {
                        const isCollapsed = childContainer.style.display === 'none';
                        childContainer.style.display = isCollapsed ? 'block' : 'none';
                        toggle.textContent = isCollapsed ? 'â–¼ ' : 'â–¶ ';
                    };
                    
                    line.appendChild(toggle);
                    line.appendChild(keySpan);
                    line.appendChild(colonSpan);
                    line.appendChild(typeSpan);
                    container.appendChild(line);
                    container.appendChild(childContainer);
                    
                    renderJsonTree(value, childContainer, level + 1);
                } else {
                    const keySpan = document.createElement('span');
                    keySpan.style.color = '#9cdcfe';
                    keySpan.style.marginLeft = '16px';
                    keySpan.textContent = isArray ? `[${key}]` : `"${key}"`;
                    
                    const colonSpan = document.createElement('span');
                    colonSpan.textContent = ': ';
                    colonSpan.style.color = '#cccccc';
                    
                    const valueColor = typeof value === 'string' ? '#ce9178' : 
                                      typeof value === 'number' ? '#b5cea8' : 
                                      typeof value === 'boolean' ? '#569cd6' : '#cccccc';
                    const valueSpan = document.createElement('span');
                    valueSpan.style.color = valueColor;
                    valueSpan.textContent = typeof value === 'string' ? `"${value}"` : String(value);
                    
                    line.appendChild(keySpan);
                    line.appendChild(colonSpan);
                    line.appendChild(valueSpan);
                    container.appendChild(line);
                }
            }
        }
        
        function copyJsonToClipboard() {
            if (!activeFile) return;
            const fileData = openFiles.get(activeFile);
            if (!fileData) return;
            
            try {
                const content = fileData.model.getValue();
                const parsed = JSON.parse(content);
                const formatted = JSON.stringify(parsed, null, 2);
                copyToClipboard(formatted);
            } catch (e) {
                showToast('Invalid JSON, cannot copy', 'error');
            }
        }

        // ============================================================================
        // SEARCH & REPLACE
        // ============================================================================
        
        function toggleSearch() {
            const panel = document.getElementById('search-panel');
            panel.classList.toggle('hidden');
            
            if (!panel.classList.contains('hidden')) {
                document.getElementById('search-input').focus();
            }
        }

        function findNext() {
            const query = document.getElementById('search-input').value;
            if (!query || !editor) return;
            
            const caseSensitive = document.getElementById('search-case').checked;
            const wholeWord = document.getElementById('search-whole').checked;
            const regex = document.getElementById('search-regex').checked;
            
            // Use Monaco's find controller with our options
            const findController = editor.getContribution('editor.contrib.findController');
            if (findController) {
                findController.start({
                    forceRevealReplace: false,
                    seedSearchStringFromSelection: 'never',
                    seedSearchStringFromGlobalClipboard: false,
                    shouldFocus: 2, // FindInputFocusType.FindInput
                    shouldAnimate: true,
                    updateSearchScope: false,
                    loop: true
                });
                
                // Set the search string and options
                const state = findController.getState();
                if (state) {
                    state.change({
                        searchString: query,
                        isRegex: regex,
                        matchCase: caseSensitive,
                        wholeWord: wholeWord
                    }, false);
                }
                
                // Find next match
                findController.moveToNextMatch();
            }
        }

        function replaceOne() {
            const find = document.getElementById('search-input').value;
            const replace = document.getElementById('replace-input').value;
            if (!find || !editor) return;
            
            const caseSensitive = document.getElementById('search-case').checked;
            const wholeWord = document.getElementById('search-whole').checked;
            const regex = document.getElementById('search-regex').checked;
            
            // Get current selection
            const selection = editor.getSelection();
            if (!selection) return;
            
            const model = editor.getModel();
            if (!model) return;
            
            const text = model.getValueInRange(selection);
            
            // Check if selection matches search (accounting for options)
            let matches = false;
            if (regex) {
                try {
                    const regexPattern = new RegExp(find, caseSensitive ? '' : 'i');
                    matches = regexPattern.test(text);
                } catch (e) {
                    showToast('Invalid regex pattern', 'error');
                    return;
                }
            } else {
                matches = caseSensitive ? text === find : text.toLowerCase() === find.toLowerCase();
                if (wholeWord && matches) {
                    // Check word boundaries
                    const start = selection.getStartPosition();
                    const end = selection.getEndPosition();
                    const startCol = start.column;
                    const endCol = end.column;
                    const line = model.getLineContent(start.lineNumber);
                    
                    const beforeChar = startCol > 1 ? line[startCol - 2] : ' ';
                    const afterChar = endCol <= line.length ? line[endCol - 1] : ' ';
                    
                    const wordBoundary = /\W/;
                    matches = wordBoundary.test(beforeChar) && wordBoundary.test(afterChar);
                }
            }
            
            if (matches) {
                editor.executeEdits('replace', [{
                    range: selection,
                    text: replace
                }]);
                showToast('Replaced 1 occurrence', 'success');
                
                // Find next match after replace
                setTimeout(() => findNext(), 100);
            } else {
                showToast('Selection does not match search', 'error');
            }
        }
        
        function replaceAll() {
            const find = document.getElementById('search-input').value;
            const replace = document.getElementById('replace-input').value;
            if (!find || !editor) return;
            
            const caseSensitive = document.getElementById('search-case').checked;
            const wholeWord = document.getElementById('search-whole').checked;
            const regex = document.getElementById('search-regex').checked;
            
            const model = editor.getModel();
            if (!model) return;
            
            let searchRegex;
            try {
                if (regex) {
                    searchRegex = new RegExp(find, 'g' + (caseSensitive ? '' : 'i'));
                } else {
                    const escapedFind = find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const pattern = wholeWord ? `\\b${escapedFind}\\b` : escapedFind;
                    searchRegex = new RegExp(pattern, 'g' + (caseSensitive ? '' : 'i'));
                }
            } catch (e) {
                showToast('Invalid search pattern', 'error');
                return;
            }
            
            const content = model.getValue();
            const newContent = content.replace(searchRegex, replace);
            const matches = (content.match(searchRegex) || []).length;
            
            if (matches > 0) {
                model.setValue(newContent);
                showToast(`Replaced ${matches} occurrence${matches === 1 ? '' : 's'}`, 'success');
            } else {
                showToast('No matches found', 'error');
            }
        }

        // ============================================================================
        // SETTINGS
        // ============================================================================
        
        function loadSettings() {
            try {
            const saved = localStorage.getItem('cosmo-ide-settings');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Validate and merge with defaults
                    return { ...defaultSettings, ...parsed };
                }
            } catch (e) {
                console.error('Failed to load settings:', e);
                // Clear corrupted settings
                localStorage.removeItem('cosmo-ide-settings');
            }
            return { ...defaultSettings };
        }

        function saveSettings() {
            localStorage.setItem('cosmo-ide-settings', JSON.stringify(settings));
        }

        function toggleSettings() {
            const panel = document.getElementById('settings-panel');
            panel.classList.toggle('open');
            
            if (panel.classList.contains('open')) {
                // Load current settings into UI
                document.getElementById('setting-theme').value = settings.theme;
                document.getElementById('setting-font-size').value = settings.fontSize;
                document.getElementById('setting-tab-size').value = settings.tabSize;
                document.getElementById('setting-minimap').checked = settings.minimap;
                document.getElementById('setting-line-numbers').checked = settings.lineNumbers;
                document.getElementById('setting-word-wrap').checked = settings.wordWrap;
                document.getElementById('setting-auto-save').value = settings.autoSave;
                document.getElementById('setting-auto-save-delay').value = settings.autoSaveDelay;
            }
        }

        function applyTheme() {
            settings.theme = document.getElementById('setting-theme').value;
            monaco.editor.setTheme(settings.theme);
            saveSettings();
        }

        function applyFontSize() {
            settings.fontSize = parseInt(document.getElementById('setting-font-size').value);
            editor.updateOptions({ fontSize: settings.fontSize });
            saveSettings();
        }

        function applyTabSize() {
            settings.tabSize = parseInt(document.getElementById('setting-tab-size').value);
            editor.updateOptions({ tabSize: settings.tabSize });
            saveSettings();
        }

        function applyMinimap() {
            settings.minimap = document.getElementById('setting-minimap').checked;
            editor.updateOptions({ minimap: { enabled: settings.minimap } });
            saveSettings();
        }

        function applyLineNumbers() {
            settings.lineNumbers = document.getElementById('setting-line-numbers').checked;
            editor.updateOptions({ lineNumbers: settings.lineNumbers ? 'on' : 'off' });
            saveSettings();
        }

        function applyWordWrap() {
            settings.wordWrap = document.getElementById('setting-word-wrap').checked;
            editor.updateOptions({ wordWrap: settings.wordWrap ? 'on' : 'off' });
            saveSettings();
        }

        function applyAutoSave() {
            settings.autoSave = document.getElementById('setting-auto-save').value;
            settings.autoSaveDelay = parseInt(document.getElementById('setting-auto-save-delay').value);
            saveSettings();
            setupAutoSave();
        }

        function setupAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
            
            if (settings.autoSave === 'afterDelay') {
                autoSaveTimer = setInterval(() => {
                    const hasDirty = Array.from(openFiles.values()).some(f => f.dirty);
                    if (hasDirty) {
                        saveAllFiles();
                    }
                }, settings.autoSaveDelay);
            }
        }

        function resetSettings() {
            if (!confirm('Reset all settings to defaults?')) return;
            
            settings = { ...defaultSettings };
            saveSettings();
            toggleSettings();
            
            // Reload to apply all defaults
            location.reload();
        }

        // ============================================================================
        // WORKSPACE STATE PERSISTENCE
        // ============================================================================
        
        function saveWorkspaceState() {
            const state = {
                openTabs: Array.from(openFiles.keys()),
                activeFile: activeFile,
                sidebarCollapsed: document.getElementById('sidebar').classList.contains('collapsed'),
                pinnedTabs: Array.from(pinnedTabs),
            };
            
            const key = folderPath ? `cosmo-workspace-${folderPath}` : 'cosmo-workspace-default';
            localStorage.setItem(key, JSON.stringify(state));
        }

        function restoreWorkspaceState() {
            if (!folderPath) return;  // No folder selected yet
            const key = folderPath ? `cosmo-workspace-${folderPath}` : 'cosmo-workspace-default';
            const saved = localStorage.getItem(key);
            
            if (!saved) return;
            
            try {
                const state = JSON.parse(saved);
                
                // Restore sidebar state
                if (state.sidebarCollapsed) {
                    toggleSidebar();
                }
                
                // Restore pinned tabs
                if (state.pinnedTabs && Array.isArray(state.pinnedTabs)) {
                    pinnedTabs = new Set(state.pinnedTabs);
                }
                
                // Note: Files are already opened by loadFileTree()
                // Pinned status will be applied when tabs are created
            } catch (e) {
                console.error('Failed to restore workspace:', e);
            }
        }

        // ============================================================================
        // UI HELPERS
        // ============================================================================
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const expandBtn = document.getElementById('sidebar-expand-btn');
            const isCollapsed = sidebar.classList.toggle('collapsed');
            
            // Show/hide the expand button
            if (expandBtn) {
                expandBtn.style.display = isCollapsed ? 'flex' : 'none';
            }
            
            // Update button icon and tooltip
            const toggleBtn = document.querySelector('[data-tooltip="Hide Sidebar"], [data-tooltip="Show Sidebar"]');
            if (toggleBtn) {
                toggleBtn.textContent = isCollapsed ? 'âµ' : 'â´';
                toggleBtn.setAttribute('data-tooltip', isCollapsed ? 'Show Sidebar' : 'Hide Sidebar');
            }
        }
        
        async function refreshFileTree() {
            if (!folderPath) {
                showToast('No folder open', 'error');
                return;
            }
            
            showToast('Refreshing file tree...', 'info');
            
            try {
                // Reload the file tree
                await loadFileTree(folderPath);
                showToast('âœ… File tree refreshed', 'success');
            } catch (error) {
                console.error('Failed to refresh file tree:', error);
                showToast('Error refreshing file tree', 'error');
            }
        }

        function toggleKeyboardHelp() {
            const help = document.getElementById('keyboard-help');
            const overlay = document.getElementById('overlay');
            help.classList.toggle('hidden');
            overlay.classList.toggle('hidden');
        }

        function closeAllModals() {
            document.getElementById('command-palette').classList.add('hidden');
            document.getElementById('keyboard-help').classList.add('hidden');
            document.getElementById('search-panel').classList.add('hidden');
            document.getElementById('context-menu').classList.add('hidden');
            // Also close folder browser + other modal-style panels
            const folderBrowser = document.getElementById('folder-browser');
            if (folderBrowser) folderBrowser.classList.add('hidden');
            const csvBuilder = document.getElementById('csv-builder');
            if (csvBuilder) csvBuilder.classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');
            // Note: Don't close AI panel on Escape - it's a persistent panel like preview
        }

        function showContextMenu(x, y, items) {
            const menu = document.getElementById('context-menu');
            
            // Clear previous content and event listeners
            menu.innerHTML = '';
            
            // Build menu items with proper event handlers
            items.forEach((item, index) => {
                if (item.type === 'separator') {
                    const separator = document.createElement('div');
                    separator.className = 'context-menu-separator';
                    menu.appendChild(separator);
                } else {
                    const menuItem = document.createElement('div');
                    menuItem.className = 'context-menu-item';
                    menuItem.textContent = item.label;
                    menuItem.dataset.index = index;
                    
                    // Add click handler
                    menuItem.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (item.action && typeof item.action === 'function') {
                            item.action();
                        }
                        menu.classList.add('hidden');
                    });
                    
                    menu.appendChild(menuItem);
                }
            });
            
            // Position menu
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.remove('hidden');
            
            // Ensure menu stays within viewport
            setTimeout(() => {
                const rect = menu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
                }
            }, 0);
            
            // Close on click outside
            setTimeout(() => {
                const closeHandler = (e) => {
                    if (!menu.contains(e.target)) {
                    menu.classList.add('hidden');
                        document.removeEventListener('click', closeHandler);
                    }
                };
                document.addEventListener('click', closeHandler);
            }, 0);
        }

        function copyToClipboard(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('Copied to clipboard', 'success');
                }).catch(err => {
                    console.error('Clipboard copy failed:', err);
                    fallbackCopyToClipboard(text);
                });
            } else {
                fallbackCopyToClipboard(text);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            // Fallback for browsers that don't support clipboard API
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showToast('Copied to clipboard', 'success');
            } catch (err) {
                console.error('Fallback copy failed:', err);
                showToast('Copy failed', 'error');
            }
            document.body.removeChild(textArea);
        }

        function updateSaveButtons() {
            const activeFileData = activeFile ? openFiles.get(activeFile) : null;
            const currentFileDirty = activeFileData?.dirty || false;
            const isReadOnly = activeFileData?.readOnly || false;
            const hasDirtyFiles = Array.from(openFiles.values()).some(f => f.dirty && !f.readOnly);
            const hasActiveFile = activeFile !== null;

            // Disable save for read-only files (Office files)
            document.getElementById('save-btn').disabled = !currentFileDirty || isReadOnly;
            document.getElementById('save-all-btn').disabled = !hasDirtyFiles;
            document.getElementById('download-btn').disabled = !hasActiveFile;
            document.getElementById('snapshot-btn').disabled = !hasActiveFile;

            const dirtyCount = Array.from(openFiles.values()).filter(f => f.dirty && !f.readOnly).length;
            if (dirtyCount > 0) {
                document.getElementById('status-dirty').textContent = 
                    `${dirtyCount} unsaved ${dirtyCount === 1 ? 'file' : 'files'}`;
                document.getElementById('status-dirty').style.color = 'var(--warning-color)';
            } else if (isReadOnly) {
                document.getElementById('status-dirty').textContent = 'READ ONLY';
                document.getElementById('status-dirty').style.color = 'var(--text-secondary)';
            } else {
                document.getElementById('status-dirty').textContent = '';
            }
        }

        function updateFileStats() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) {
                document.getElementById('status-size').textContent = '';
                document.getElementById('status-words').textContent = '';
                return;
            }
            
            const content = fileData.model.getValue();
            const bytes = new Blob([content]).size;
            const size = bytes < 1024 ? `${bytes} B` : 
                        bytes < 1024 * 1024 ? `${(bytes / 1024).toFixed(1)} KB` : 
                        `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
            
            const words = content.split(/\s+/).filter(w => w.length > 0).length;
            
            document.getElementById('status-size').textContent = size;
            document.getElementById('status-words').textContent = `${words} words`;
        }

        function updateSelectionInfo() {
            const selection = editor.getSelection();
            if (!selection) return;
            
            const model = editor.getModel();
            if (!model) return;
            
            const start = model.getOffsetAt(selection.getStartPosition());
            const end = model.getOffsetAt(selection.getEndPosition());
            const length = end - start;
            
            if (length > 0) {
                const lines = selection.endLineNumber - selection.startLineNumber + 1;
                document.getElementById('status-selection').textContent = 
                    `${length} chars, ${lines} lines selected`;
            } else {
                document.getElementById('status-selection').textContent = '';
            }
        }

        function showToast(message, type = 'success', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // ============================================================================
        // SYSTEM SWITCHING
        // ============================================================================
        
        async function loadAvailableSystems() {
            try {
            if (IDE_MODE === 'filesystem') return;  // Standalone mode
                const response = await fetch('/api/compiled-docs/all');
                const data = await response.json();
                
                if (data.success) {
                    availableSystems = data.systems;
                    
                    const picker = document.getElementById('system-picker');
                    picker.innerHTML = '';
                    
                    if (availableSystems.length === 0) {
                        picker.innerHTML = '<option value="">No systems compiled yet</option>';
                        picker.disabled = true;
                        return;
                    }
                    
                    const byRun = {};
                    availableSystems.forEach(sys => {
                        if (!byRun[sys.runName]) byRun[sys.runName] = [];
                        byRun[sys.runName].push(sys);
                    });
                    
                    for (const [run, systems] of Object.entries(byRun)) {
                        const group = document.createElement('optgroup');
                        group.label = run;
                        
                        systems.forEach(sys => {
                            const option = document.createElement('option');
                            option.value = `${sys.runName}:${sys.systemId}`;
                            option.textContent = sys.systemId;
                            
                            if (sys.runName === runName && sys.systemId === systemId) {
                                option.selected = true;
                            }
                            
                            group.appendChild(option);
                        });
                        
                        picker.appendChild(group);
                    }
                }
            } catch (error) {
                console.error('Failed to load available systems:', error);
            }
        }
        
        function switchSystem() {
            if (IDE_MODE === 'filesystem') return;  // Standalone mode
            const picker = document.getElementById('system-picker');
            const value = picker.value;
            
            if (!value) return;
            
            const hasDirty = Array.from(openFiles.values()).some(f => f.dirty);
            if (hasDirty) {
                if (!confirm('You have unsaved changes. Switch anyway?')) {
                    picker.value = `${runName}:${systemId}`;
                    return;
                }
            }
            
            const [newRun, newSystem] = value.split(':');
            window.location.href = `/docs-ide?run=${newRun}&system=${newSystem}`;
        }

        // ============================================================================
        // FILE MANAGEMENT
        // ============================================================================
        
        function closeOtherTabs() {
            if (!activeFile) return;
            
            const tabsToClose = Array.from(openFiles.keys()).filter(path => path !== activeFile);
            
            if (tabsToClose.length === 0) {
                showToast('No other tabs to close', 'error');
                return;
            }
            
            const dirtyTabs = tabsToClose.filter(path => openFiles.get(path)?.dirty);
            if (dirtyTabs.length > 0) {
                if (!confirm(`${dirtyTabs.length} tab(s) have unsaved changes. Close anyway?`)) {
                    return;
                }
            }
            
            tabsToClose.forEach(path => closeTab(path));
            showToast(`Closed ${tabsToClose.length} tab(s)`, 'success');
        }
        
        function closeUnpinnedTabs() {
            const tabsToClose = Array.from(openFiles.keys()).filter(path => !pinnedTabs.has(path));
            
            if (tabsToClose.length === 0) {
                showToast('No unpinned tabs to close', 'error');
                return;
            }
            
            const dirtyTabs = tabsToClose.filter(path => openFiles.get(path)?.dirty);
            if (dirtyTabs.length > 0) {
                if (!confirm(`${dirtyTabs.length} unpinned tab(s) have unsaved changes. Close anyway?`)) {
                    return;
                }
            }
            
            tabsToClose.forEach(path => closeTab(path));
            showToast(`Closed ${tabsToClose.length} unpinned tab(s)`, 'success');
        }
        
        function showNewFileDialog() {
            showToast('File creation requires backend API support', 'error');
            // TODO: Implement file creation via API
            // const fileName = prompt('Enter new file name:');
            // if (fileName) {
            //     createNewFile(fileName);
            // }
        }
        
        function renameFileDialog(filePath) {
            const fileData = openFiles.get(filePath);
            if (!fileData) return;
            
            showToast('File rename requires backend API support', 'error');
            // TODO: Implement file rename via API
            // const newName = prompt('Enter new file name:', fileData.name);
            // if (newName && newName !== fileData.name) {
            //     renameFile(filePath, newName);
            // }
        }
        
        function deleteFileDialog(filePath) {
            const fileData = openFiles.get(filePath);
            if (!fileData) return;
            
            if (!confirm(`Delete ${fileData.name}? This action cannot be undone.`)) {
                return;
            }
            
            showToast('File deletion requires backend API support', 'error');
            // TODO: Implement file deletion via API
            // deleteFile(filePath);
        }
        
        function showFindInFiles() {
            const query = prompt('Find in all files:');
            if (!query) return;
            
            showToast('Searching...', 'success');
            
            // Search through all open files and potentially all files in the system
            const results = [];
            
            // Search in open files
            for (const [path, fileData] of openFiles.entries()) {
                const content = fileData.model.getValue();
                const lines = content.split('\n');
                
                lines.forEach((line, lineNumber) => {
                    if (line.toLowerCase().includes(query.toLowerCase())) {
                        results.push({
                            path,
                            name: fileData.name,
                            line: lineNumber + 1,
                            content: line.trim()
                        });
                    }
                });
            }
            
            if (results.length === 0) {
                showToast('No results found in open files', 'error');
                return;
            }
            
            // Show results in command palette
            const palette = document.getElementById('command-palette');
            const input = document.getElementById('command-input');
            const resultsDiv = document.getElementById('command-results');
            const overlay = document.getElementById('overlay');
            
            palette.classList.remove('hidden');
            overlay.classList.remove('hidden');
            input.value = query;
            input.placeholder = `Found ${results.length} result(s)`;
            
            resultsDiv.innerHTML = results.map((result, idx) => `
                <div class="command-item ${idx === 0 ? 'selected' : ''}" data-index="${idx}" onclick="openFileFromPalette('${result.path}', '${result.name}')">
                    <div>
                        <div class="command-label">${result.name}:${result.line}</div>
                        <div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;">${result.content.substring(0, 80)}...</div>
                    </div>
                </div>
            `).join('');
        }

        // ============================================================================
        // AI ASSISTANT
        // ============================================================================
        
        let aiConversationHistory = [];
        let aiProcessing = false;
        
        function buildFileTreeContext() {
            // Build a compact representation of file tree for AI
            let totalCount = 0; // Shared counter across all recursion levels
            const maxItems = 100;
            
            const flattenTree = (items, depth = 0) => {
                let result = '';
                
                for (const item of items) {
                    if (totalCount >= maxItems) {
                        result += `${'  '.repeat(depth)}... (truncated at ${maxItems} items)\n`;
                        break;
                    }
                    
                    const indent = '  '.repeat(depth);
                    if (item.isDirectory) {
                        result += `${indent}ðŸ“ ${item.name}/\n`;
                        totalCount++;
                        if (item.children && depth < 2 && totalCount < maxItems) {
                            result += flattenTree(item.children, depth + 1);
                        }
                    } else {
                        result += `${indent}ðŸ“„ ${item.name}\n`;
                        totalCount++;
                    }
                }
                return result;
            };
            
            return allFiles && allFiles.length > 0 ? flattenTree(allFiles) : '';
        }
        
        function toggleAI() {
            const panel = document.getElementById('ai-panel');
            const aiBtn = document.getElementById('ai-btn');
            panel.classList.toggle('hidden');
            
            if (aiBtn) {
                aiBtn.classList.toggle('active', !panel.classList.contains('hidden'));
            }

            if (!panel.classList.contains('hidden')) {
                document.getElementById('ai-input').focus();
            }
        }
        
        /**
         * Update a streaming message in real-time (Cursor-style)
         */
        function updateStreamingMessage(messageId, content) {
            const messageDiv = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageDiv) {
                const contentDiv = messageDiv.querySelector('.ai-message-content');
                if (contentDiv) {
                    // Use plain text during streaming for performance
                    contentDiv.textContent = content;
                    
                    // Auto-scroll to bottom
                    const messagesContainer = document.getElementById('ai-chat-messages');
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }
            }
        }
        
        // Global AbortController for stopping AI requests
        let currentAIAbortController = null;

        function handleAIInputKeydown(event) {
            // Shift+Enter = new line (default behavior, do nothing)
            if (event.shiftKey && event.key === 'Enter') {
                return; // Allow default behavior (new line)
            }
            
            // Enter alone = send message (like Cursor)
            if (event.key === 'Enter') {
                event.preventDefault();
                sendAIMessage();
            }
        }

        function stopAIRequest() {
            if (currentAIAbortController) {
                console.log('[AI] Stopping request...');
                currentAIAbortController.abort();
                currentAIAbortController = null;
                
                // Update UI
                aiProcessing = false;
                document.getElementById('ai-send-btn').style.display = '';
                document.getElementById('ai-stop-btn').style.display = 'none';
                document.getElementById('ai-input').focus();
                
                // Add system message
                addChatMessage('system', 'Request stopped by user');
            }
        }
        
        async function sendAIMessage() {
            const input = document.getElementById('ai-input');
            const message = input.value.trim();
            
            if (!message || aiProcessing) return;
            
            // Get current file context
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            const documentContent = fileData ? fileData.model.getValue() : '';
            const fileName = fileData ? fileData.name : 'untitled';
            const language = fileData ? fileData.model.getLanguageId() : 'text';
            
            // Get selected text if any
            const selection = editor.getSelection();
            const selectedText = selection && !selection.isEmpty() ? 
                editor.getModel().getValueInRange(selection) : null;
            
            // Add user message to chat
            addChatMessage('user', message);
            
            // Clear input
            input.value = '';
            
            // Show thinking indicator  
            aiProcessing = true;
            document.getElementById('ai-send-btn').style.display = 'none';
            document.getElementById('ai-stop-btn').style.display = '';
            
            // Create streaming message placeholder
            const streamingMessageId = `streaming-${Date.now()}`;
            addChatMessage('assistant', '', { streaming: true, messageId: streamingMessageId });
            
            // Create new AbortController for this request
            currentAIAbortController = new AbortController();
            
            try {
                // Build file tree context (just structure, not content)
                const fileTreeContext = buildFileTreeContext();
                
                // Get selected model
                const selectedModel = document.getElementById('ai-model-select')?.value || 'claude-sonnet-4-5';
                
                // Use streaming for real-time response (Cursor-style)
                const requestBody = {
                    message,
                    documentContent,
                    selectedText,
                    fileName,
                    language,
                    fileTreeContext,
                    currentFolder: IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.'),
                    model: selectedModel,
                    conversationHistory: aiConversationHistory.slice(-12),
                    stream: true  // Enable streaming
                };
                
                // Handle streaming response with incremental file creation (look-ahead pattern)
                let fullResponse = '';
                let data = null;
                let pendingFile = null; // {path, content} - file being streamed
                const currentFolderForRealtime = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
                let realtimeCreatedPaths = new Set(); // Track files created during streaming
                
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: currentAIAbortController.signal
                });
                
                // Handle SSE streaming with tool feedback
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let toolFeedbackMessage = null;
                let buffer = ''; // Buffer for incomplete lines
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;
                    const lines = buffer.split('\n');
                    
                    // Keep last line in buffer if incomplete (no \n at end)
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const jsonStr = line.slice(6).trim();
                                if (!jsonStr) continue; // Skip empty data lines
                                const event = JSON.parse(jsonStr);
                                
                                // Handle different event types
                                console.log('[EVENT RECEIVED]', event.type, event);
                                
                                if (event.type === 'error') {
                                    throw new Error(event.error);
                                }
                                
                                else if (event.type === 'iteration') {
                                    console.log(`[AI] Iteration ${event.iteration}/${event.max}`);
                                }
                                
                                else if (event.type === 'tools_start') {
                                    // Create details container for this iteration
                                    console.log(`[AI] Starting ${event.tools.length} tools`);
                                    let detailsContainer = document.getElementById('ai-details-active');
                                    if (!detailsContainer) {
                                        detailsContainer = addChatMessage('system', '');
                                        detailsContainer.id = 'ai-details-active';
                                        detailsContainer.classList.add('ai-details-container');
                                        detailsContainer.innerHTML = `
                                            <details open>
                                                <summary>ðŸ” AI Process (click to collapse)</summary>
                                                <div class="ai-details-content"></div>
                                            </details>
                                        `;
                                    }
                                }
                                
                                else if (event.type === 'tool_start') {
                                    // Show tool starting in details container
                                    const icon = event.tool === 'read_file' ? 'ðŸ“–' :
                                                event.tool === 'list_directory' ? 'ðŸ“' :
                                                event.tool === 'read_image' ? 'ðŸ–¼ï¸' :
                                                event.tool === 'create_image' ? 'ðŸŽ¨' :
                                                event.tool === 'edit_image' ? 'âœï¸' :
                                                event.tool === 'grep_search' ? 'ðŸ”' :
                                                event.tool === 'codebase_search' ? 'ðŸ§ ' :
                                                event.tool === 'edit_file' ? 'âœï¸' :
                                                event.tool === 'create_file' ? 'ðŸ“' :
                                                event.tool === 'create_docx' ? 'ðŸ“„' :
                                                event.tool === 'create_xlsx' ? 'ðŸ“Š' :
                                                event.tool === 'run_terminal' ? 'âš¡' :
                                                event.tool === 'delete_file' ? 'ðŸ—‘ï¸' : 'ðŸ”§';
                                    
                                    // Make sure details container exists
                                    let detailsContainer = document.getElementById('ai-details-active');
                                    if (!detailsContainer) {
                                        detailsContainer = addChatMessage('system', '');
                                        detailsContainer.id = 'ai-details-active';
                                        detailsContainer.classList.add('ai-details-container');
                                        detailsContainer.innerHTML = `
                                            <details open>
                                                <summary>ðŸ” AI Process (click to collapse)</summary>
                                                <div class="ai-details-content"></div>
                                            </details>
                                        `;
                                    }
                                    
                                    const contentDiv = detailsContainer.querySelector('.ai-details-content');
                                    const toolDiv = document.createElement('div');
                                    toolDiv.className = 'tool-item tool-running';
                                    toolDiv.dataset.toolIndex = event.index;
                                    const argStr = event.args?.file_path || event.args?.directory_path || event.args?.query || event.args?.pattern || event.args?.command || '';
                                    toolDiv.innerHTML = `<span class="tool-icon">${icon}</span><span class="tool-status">â³</span><span class="tool-text">${escapeHtml(event.tool)}${argStr ? ': ' + escapeHtml(argStr.substring(0, 50)) + (argStr.length > 50 ? '...' : '') : ''}</span>`;
                                    contentDiv.appendChild(toolDiv);
                                }
                                
                                else if (event.type === 'tool_complete') {
                                    console.log(`[AI] ${event.tool} complete`);
                                    // Tool complete is just for logging, result will show in tool_result event
                                }
                                
                                else if (event.type === 'thinking') {
                                    // Show AI's reasoning/thinking in collapsible details
                                    console.log('[FRONTEND] THINKING EVENT:', event.content);
                                    
                                    // Find or create details container for this iteration
                                    let detailsContainer = document.getElementById('ai-details-active');
                                    if (!detailsContainer) {
                                        detailsContainer = addChatMessage('system', '');
                                        detailsContainer.id = 'ai-details-active';
                                        detailsContainer.classList.add('ai-details-container');
                                        detailsContainer.innerHTML = `
                                            <details open>
                                                <summary>ðŸ” AI Process (click to collapse)</summary>
                                                <div class="ai-details-content"></div>
                                            </details>
                                        `;
                                    }
                                    
                                    const contentDiv = detailsContainer.querySelector('.ai-details-content');
                                    const thinkingDiv = document.createElement('div');
                                    thinkingDiv.className = 'thinking-item';
                                    thinkingDiv.innerHTML = `<span class="thinking-icon">ðŸ’­</span><span class="thinking-text">${escapeHtml(event.content)}</span>`;
                                    contentDiv.appendChild(thinkingDiv);
                                    
                                    console.log('[FRONTEND] Added thinking message');
                                }
                                
                                else if (event.type === 'tool_result') {
                                    // Show tool execution results in the details container
                                    console.log('[FRONTEND] TOOL_RESULT EVENT:', event);
                                    
                                    const icon = event.tool === 'list_directory' ? 'ðŸ“' :
                                                event.tool === 'read_file' ? 'ðŸ“–' :
                                                event.tool === 'read_image' ? 'ðŸ–¼ï¸' :
                                                event.tool === 'create_image' ? 'ðŸŽ¨' :
                                                event.tool === 'edit_image' ? 'âœï¸' :
                                                event.tool === 'grep_search' ? 'ðŸ”' :
                                                event.tool === 'codebase_search' ? 'ðŸ§ ' :
                                                event.tool === 'edit_file' ? 'âœï¸' :
                                                event.tool === 'create_file' ? 'ðŸ“' :
                                                event.tool === 'create_docx' ? 'ðŸ“„' :
                                                event.tool === 'create_xlsx' ? 'ðŸ“Š' :
                                                event.tool === 'run_terminal' ? 'âš¡' :
                                                event.tool === 'delete_file' ? 'ðŸ—‘ï¸' : 'ðŸ”§';
                                    const statusIcon = event.success ? 'âœ“' : 'âœ—';
                                    
                                    // Find or create details container
                                    let detailsContainer = document.getElementById('ai-details-active');
                                    if (!detailsContainer) {
                                        detailsContainer = addChatMessage('system', '');
                                        detailsContainer.id = 'ai-details-active';
                                        detailsContainer.classList.add('ai-details-container');
                                        detailsContainer.innerHTML = `
                                            <details open>
                                                <summary>ðŸ” AI Process (click to collapse)</summary>
                                                <div class="ai-details-content"></div>
                                            </details>
                                        `;
                                    }
                                    
                                    const contentDiv = detailsContainer.querySelector('.ai-details-content');
                                    
                                    // Update existing running tool or create new
                                    let toolDiv = detailsContainer.querySelector(`[data-tool-index="${event.index}"]`);
                                    if (toolDiv) {
                                        // Update existing
                                        toolDiv.className = `tool-item ${event.success ? 'tool-success' : 'tool-error'}`;
                                        toolDiv.innerHTML = `<span class="tool-icon">${icon}</span><span class="tool-status">${statusIcon}</span><span class="tool-text">${escapeHtml(event.summary)}</span>`;
                                    } else {
                                        // Create new
                                        toolDiv = document.createElement('div');
                                        toolDiv.className = `tool-item ${event.success ? 'tool-success' : 'tool-error'}`;
                                        toolDiv.innerHTML = `<span class="tool-icon">${icon}</span><span class="tool-status">${statusIcon}</span><span class="tool-text">${escapeHtml(event.summary)}</span>`;
                                        contentDiv.appendChild(toolDiv);
                                    }
                                    
                                    console.log('[FRONTEND] Added tool result message');
                                }
                                
                                else if (event.type === 'response_chunk') {
                                    // Finalize details container when response starts
                                    const detailsContainer = document.getElementById('ai-details-active');
                                    if (detailsContainer) {
                                        detailsContainer.id = ''; // Remove active ID so new iteration can create new one
                                        // Auto-collapse details to focus on response
                                        const details = detailsContainer.querySelector('details');
                                        if (details) details.open = false;
                                    }
                                    
                                    // Remove any temp feedback messages
                                    if (toolFeedbackMessage) {
                                        removeChatMessage(toolFeedbackMessage);
                                        toolFeedbackMessage = null;
                                    }
                                    fullResponse += event.chunk;
                                    updateStreamingMessage(streamingMessageId, fullResponse);
                                }
                                
                                else if (event.type === 'complete') {
                                        console.log('[FRONTEND] Complete event received, rendering markdown...');
                                        
                                        // Remove tool feedback if still showing
                                        if (toolFeedbackMessage) {
                                            removeChatMessage(toolFeedbackMessage);
                                            toolFeedbackMessage = null;
                                        }

                                        // Render final markdown
                                        const finalContent = event.fullResponse || fullResponse;
                                        const messageDiv = document.querySelector(`[data-message-id="${streamingMessageId}"]`);
                                        console.log('[FRONTEND] Found message div:', !!messageDiv, 'Content length:', finalContent?.length);
                                        
                                        if (messageDiv) {
                                            const contentDiv = messageDiv.querySelector('.ai-message-content');
                                            if (contentDiv && finalContent) {
                                                try {
                                                    // Render markdown
                                                    if (typeof marked !== 'undefined' && marked.parse) {
                                                        contentDiv.innerHTML = marked.parse(finalContent);
                                                        console.log('[FRONTEND] Markdown rendered successfully');
                                                        
                                                        // Highlight code blocks
                                                        contentDiv.querySelectorAll('pre code').forEach((block) => {
                                                            if (typeof hljs !== 'undefined') {
                                                                hljs.highlightElement(block);
                                                            }
                                                        });
                                                    } else {
                                                        console.warn('[FRONTEND] marked.js not available, using plain text');
                                                        contentDiv.textContent = finalContent;
                                                    }
                                                } catch (err) {
                                                    console.error('[FRONTEND] Error rendering markdown:', err);
                                                    contentDiv.textContent = finalContent; // Fallback to plain text
                                                }
                                            }
                                            // Update header to remove "streaming..."
                                            const headerDiv = messageDiv.querySelector('.ai-message-header');
                                            if (headerDiv) {
                                                headerDiv.textContent = 'AI Assistant';
                                                console.log('[FRONTEND] Header updated to remove streaming indicator');
                                            }
                                        } else {
                                            console.error('[FRONTEND] Could not find streaming message div:', streamingMessageId);
                                        }
                                        
                                        // Handle pending edits (show in queue, not auto-apply)
                                        if (event.pendingEdits && event.pendingEdits.length > 0) {
                                            console.log(`[AI] ${event.pendingEdits.length} edit(s) pending review`);
                                            for (const edit of event.pendingEdits) {
                                                // Add to edit queue for user review
                                                addToEditQueue(edit.file, edit.instructions, edit.edit);
                                            }
                                            
                                            // Show notification
                                            const editsMsg = event.pendingEdits.length === 1 ? '1 edit' : `${event.pendingEdits.length} edits`;
                                            addChatMessage('system', `âœ… ${editsMsg} added to queue for review`, {});
                                        }
                                        
                                        data = {
                                            success: true,
                                            response: event.fullResponse || fullResponse,
                                            tokensUsed: event.tokensUsed || 0,
                                            iterations: event.iterations || 0,
                                            model: selectedModel
                                        };
                                    }
                                } catch (e) {
                                    console.error('Failed to parse SSE event:', e);
                                }
                            }
                        }
                    }
                
                removeThinkingIndicator();
                
                // Finalize any active details container
                const finalDetailsContainer = document.getElementById('ai-details-active');
                if (finalDetailsContainer) {
                    finalDetailsContainer.id = '';
                }
                
                // Function calling v2: tools executed server-side, response is clean
                // No need to parse for READ_FILE, GREP, etc. - already handled
                
                if (!data || !data.success) {
                    throw new Error(data?.error || 'AI request failed');
                }
                
                // Add final response to conversation history
                aiConversationHistory.push(
                    { role: 'user', content: message },
                    { role: 'assistant', content: data.response }
                );
                
                // Auto-save conversation (Cursor-style)
                await chatHistory.saveMessage('user', message);
                await chatHistory.saveMessage('assistant', data.response);
                
                // Limit history size (keep last 24 messages = 12 exchanges)
                if (aiConversationHistory.length > 24) {
                    aiConversationHistory = aiConversationHistory.slice(-24);
                }
                
            } catch (error) {
                removeThinkingIndicator();
                
                // Handle abort differently from other errors
                if (error.name === 'AbortError') {
                    console.log('[AI] Request aborted by user');
                    // Remove the streaming message placeholder
                    const streamingMsg = document.querySelector(`[data-message-id="${streamingMessageId}"]`);
                    if (streamingMsg) {
                        streamingMsg.remove();
                    }
                } else {
                    addChatMessage('error', `Error: ${error.message}`);
                    console.error('AI chat error:', error);
                }
            } finally {
                aiProcessing = false;
                currentAIAbortController = null;
                document.getElementById('ai-send-btn').style.display = '';
                document.getElementById('ai-stop-btn').style.display = 'none';
                input.focus();
            }
        }
        
        // REMOVED OLD TEXT-BASED TOOL HANDLING CODE (~650 lines)
        // Function calling v2 handles all tools server-side (READ_FILE, GREP, etc.)
        
        // addChatMessage defined below (keeping original)

        function addChatMessage(type, content, options = {}) {
            const messagesDiv = document.getElementById('ai-chat-messages');
            
            // Remove welcome message if present (checking for the container or the emoji)
            const welcome = messagesDiv.querySelector('[style*="text-align: center"]');
            if (welcome && (welcome.textContent.includes('Ask me anything') || welcome.textContent.includes('New conversation'))) {
                welcome.remove();
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `ai-message ${type}`;
            
            // Add message ID for streaming updates
            if (options.messageId) {
                messageDiv.dataset.messageId = options.messageId;
            }
            
            const headerText = type === 'user' ? 'ðŸ‘¤ YOU' : 
                              type === 'assistant' ? (options.streaming ? 'ðŸ¤– AI Assistant (streaming...)' : 'ðŸ¤– AI Assistant') : 
                              type === 'system' ? 'âš™ï¸ System' :
                              type === 'error' ? 'âŒ Error' : 
                              '';
            
            // Render content based on type
            let renderedContent;
            if (options.streaming) {
                renderedContent = 'â–‹';
            } else if (type === 'assistant') {
                // Use marked.js for beautiful markdown rendering
                renderedContent = marked.parse(content);
            } else {
                // For user/system/error messages, escape HTML
                renderedContent = escapeHtml(content);
            }
            
            let html = `
                <div class="ai-message-header">${headerText}</div>
                <div class="ai-message-content">${renderedContent}</div>
            `;
            
            // Add action buttons for assistant messages
            if (type === 'assistant' && options.canApply) {
                html += `
                    <div class="ai-message-actions">
                        <button class="btn btn-secondary" onclick="applyAISuggestion(this)" style="padding: 4px 12px; font-size: 11px;">
                            âœ“ Apply
                        </button>
                        <button class="btn btn-secondary" onclick="copyAISuggestion(this)" style="padding: 4px 12px; font-size: 11px;">
                            ðŸ“‹ Copy
                        </button>
                    </div>
                `;
            }
            
            messageDiv.innerHTML = html;
            
            // Highlight code blocks
            if (type === 'assistant') {
                messageDiv.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightElement(block);
                });
            }
            
            // Store response content for apply button
            if (options.canApply) {
                messageDiv.dataset.response = content;
                
                // Store original text for diff view
                const selection = editor.getSelection();
                const model = editor.getModel();
                if (selection && !selection.isEmpty()) {
                    messageDiv.dataset.originalText = model.getValueInRange(selection);
                } else if (model) {
                    messageDiv.dataset.originalText = model.getValue();
                }
            }
            
            // Check if user has scrolled up (reading old messages)
            const isNearBottom = messagesDiv.scrollHeight - messagesDiv.scrollTop <= messagesDiv.clientHeight + 150;
            
            // Always append messages in chronological order
            messagesDiv.appendChild(messageDiv);
            
            // Only auto-scroll if user is already near the bottom (don't hijack if reading)
            if (isNearBottom) {
                messagesDiv.scrollTo({
                    top: messagesDiv.scrollHeight,
                    behavior: 'smooth'
                });
            }
            
            return messageDiv; // Return for later updates/removal
        }
        
        function updateChatMessage(messageElement, newContent) {
            if (!messageElement) return;
            const contentDiv = messageElement.querySelector('.ai-message-content');
            if (contentDiv) {
                // If it's an assistant message, use marked.js for markdown rendering
                if (messageElement.classList.contains('assistant')) {
                    contentDiv.innerHTML = marked.parse(newContent);
                    // Highlight code blocks
                    messageElement.querySelectorAll('pre code').forEach((block) => {
                        hljs.highlightElement(block);
                    });
                } else {
                    contentDiv.textContent = newContent;
                }
                
                // Only auto-scroll if user is near bottom (don't interrupt reading)
                const messagesDiv = document.getElementById('ai-chat-messages');
                const isNearBottom = messagesDiv.scrollHeight - messagesDiv.scrollTop <= messagesDiv.clientHeight + 150;
                if (isNearBottom) {
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                }
            }
        }
        
        function removeChatMessage(messageElement) {
            if (messageElement && messageElement.parentNode) {
                messageElement.remove();
            }
        }
        
        function addThinkingIndicator() {
            const messagesDiv = document.getElementById('ai-chat-messages');
            const thinking = document.createElement('div');
            thinking.id = 'ai-thinking';
            thinking.className = 'ai-thinking';
            thinking.innerHTML = `
                <div class="ai-thinking-spinner"></div>
                <span>AI is thinking...</span>
            `;
            messagesDiv.appendChild(thinking);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function removeThinkingIndicator() {
            const thinking = document.getElementById('ai-thinking');
            if (thinking) {
                thinking.remove();
            }
        }
        
        async function aiQuickAction(action) {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) {
                showToast('No file open', 'error');
                return;
            }
            
            // Get selected text if any
            const selection = editor.getSelection();
            const selectedText = selection && !selection.isEmpty() ? 
                editor.getModel().getValueInRange(selection) : null;
            
            const actionMap = {
                'improve': selectedText ? 
                    'Improve this selected text - make it clearer and more professional' : 
                    'Review this document and suggest improvements',
                'summarize': 'Provide a concise summary of this document',
                'grammar': selectedText ? 
                    'Check grammar and fix any issues in the selected text' : 
                    'Check grammar and fix any issues in this document',
                'examples': 'Add relevant examples to illustrate the concepts'
            };
            
            const message = actionMap[action] || action;
            
            // Set the message and send
            document.getElementById('ai-input').value = message;
            await sendAIMessage();
        }
        
        function applyAISuggestion(button) {
            const messageDiv = button.closest('.ai-message');
            const suggestion = messageDiv.dataset.response;
            const originalText = messageDiv.dataset.originalText;
            
            if (!suggestion || !editor) return;
            
            // Get current selection or full document
            const selection = editor.getSelection();
            const model = editor.getModel();
            const currentText = selection && !selection.isEmpty() ? 
                model.getValueInRange(selection) : model.getValue();
            
            // Show diff preview before applying
            if (suggestion.length > 100 || currentText.length > 100) {
                showDiffPreview(currentText, suggestion, () => {
                    applyEdit(selection, suggestion);
                });
            } else {
                // For small changes, apply directly with confirmation
                if (confirm('Apply AI suggestion?')) {
                    applyEdit(selection, suggestion);
                }
            }
        }
        
        function applyEdit(selection, newText) {
            if (selection && !selection.isEmpty()) {
                // Replace selection
                editor.executeEdits('ai-edit', [{
                    range: selection,
                    text: newText
                }]);
                showToast('Applied AI suggestion to selection', 'success');
            } else {
                // Replace entire document
                editor.setValue(newText);
                showToast('Document updated with AI suggestion', 'success');
            }
            
            // Mark as dirty
            if (activeFile) {
                const fileData = openFiles.get(activeFile);
                if (fileData) {
                    fileData.dirty = true;
                    updateTabDirtyState(activeFile, true);
                    updateSaveButtons();
                }
            }
        }
        
        function showDiffPreview(original, modified, onAccept, customTitle = null) {
            // Use inline diff viewer instead of modal (Cursor-style UX)
            const fileName = customTitle || (activeFile ? openFiles.get(activeFile)?.name : 'Changes');
            showInlineDiff(original, modified, fileName, onAccept);
        }
        
        function copyAISuggestion(button) {
            const messageDiv = button.closest('.ai-message');
            const suggestion = messageDiv.dataset.response;
            
            if (suggestion) {
                copyToClipboard(suggestion);
                showToast('Copied AI suggestion', 'success');
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function clearAIChat() {
            const messagesDiv = document.getElementById('ai-chat-messages');
            messagesDiv.innerHTML = `
                <div style="padding: 20px; text-align: center; color: var(--text-secondary); font-size: 12px;">
                    ðŸ‘‹ Chat cleared. Ask me anything!
                </div>
            `;
            aiConversationHistory = [];
        }

        // ============================================================================
        // EXPORT & DOWNLOAD
        // ============================================================================
        
        function downloadCurrentFile() {
            if (!activeFile) {
                showToast('No file open', 'error');
                return;
            }
            
            const fileData = openFiles.get(activeFile);
            if (!fileData) {
                showToast('File data not found', 'error');
                return;
            }
            
            try {
            const content = fileData.model.getValue();
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = fileData.name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast(`Downloaded: ${fileData.name}`, 'success');
            } catch (error) {
                console.error('Download error:', error);
                showToast('Failed to download file: ' + error.message, 'error');
            }
        }
        
        async function downloadAllFiles() {
            showToast('Preparing download...', 'success');
            
            // For a simple implementation without JSZip, we'll download files one by one
            // Or offer to download a bundle via API
            
            try {
                const response = await fetch(`/api/compiled-docs/${runName}/${systemId}/download`);
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${systemId}-docs.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showToast('Downloaded all files', 'success');
                } else {
                    throw new Error('Download failed');
                }
            } catch (error) {
                console.error('Download failed:', error);
                showToast('Download failed. Downloading current file only.', 'error');
                downloadCurrentFile();
            }
        }
        
        function exportMarkdownToPDF() {
            if (!activeFile) {
                showToast('No file open', 'error');
                return;
            }
            
            const fileData = openFiles.get(activeFile);
            if (!fileData || fileData.model.getLanguageId() !== 'markdown') {
                showToast('Only markdown files can be exported to PDF', 'error');
                return;
            }
            
            try {
            // Use browser print for PDF export
            const content = fileData.model.getValue();
            const html = marked.parse(content);
            
            const printWindow = window.open('', '_blank');
                if (!printWindow) {
                    showToast('Pop-up blocked. Please allow pop-ups to export to PDF.', 'error');
                    return;
                }
                
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${fileData.name}</title>
                    <style>
                        body {
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                            max-width: 800px;
                            margin: 40px auto;
                            padding: 0 20px;
                            line-height: 1.6;
                            color: #333;
                        }
                        h1, h2, h3 { margin-top: 24px; margin-bottom: 12px; }
                        code {
                            background: #f5f5f5;
                            padding: 2px 6px;
                            border-radius: 3px;
                            font-family: 'Monaco', 'Courier New', monospace;
                        }
                        pre {
                            background: #f5f5f5;
                            padding: 16px;
                            border-radius: 6px;
                            overflow-x: auto;
                        }
                        pre code {
                            background: none;
                            padding: 0;
                        }
                    </style>
                </head>
                <body>
                    ${html}
                </body>
                </html>
            `);
            printWindow.document.close();
            
            setTimeout(() => {
                printWindow.print();
            }, 250);
                
                showToast('Opening print dialog...', 'success');
            } catch (error) {
                console.error('PDF export error:', error);
                showToast('Failed to export to PDF: ' + error.message, 'error');
            }
        }
        
        function exportMarkdownToHTML() {
            if (!activeFile) {
                showToast('No file open', 'error');
                return;
            }
            
            const fileData = openFiles.get(activeFile);
            if (!fileData || fileData.model.getLanguageId() !== 'markdown') {
                showToast('Only markdown files can be exported to HTML', 'error');
                return;
            }
            
            try {
            const content = fileData.model.getValue();
            const html = marked.parse(content);
            
            const fullHTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${fileData.name}</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            max-width: 800px;
            margin: 40px auto;
            padding: 0 20px;
            line-height: 1.6;
            color: #333;
        }
        h1, h2, h3 { margin-top: 24px; margin-bottom: 12px; color: #1a1a1a; }
        h1 { font-size: 32px; }
        h2 { font-size: 24px; }
        h3 { font-size: 20px; }
        p { margin-bottom: 12px; }
        code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }
        pre {
            background: #f5f5f5;
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 12px 0;
        }
        pre code {
            background: none;
            padding: 0;
        }
        a { color: #0066cc; text-decoration: none; }
        a:hover { text-decoration: underline; }
        blockquote {
            border-left: 4px solid #ddd;
            margin: 12px 0;
            padding-left: 16px;
            color: #666;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }
        th {
            background: #f5f5f5;
            font-weight: 600;
        }
    </style>
</head>
<body>
${html}
</body>
</html>`;
            
            const blob = new Blob([fullHTML], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = fileData.name.replace(/\.md$/, '.html');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Exported to HTML', 'success');
            } catch (error) {
                console.error('HTML export error:', error);
                showToast('Failed to export to HTML: ' + error.message, 'error');
            }
        }

        // ============================================================================
        // BEFORE UNLOAD WARNING
        // ============================================================================
        
        window.addEventListener('beforeunload', (e) => {
            const hasDirty = Array.from(openFiles.values()).some(f => f.dirty);
            if (hasDirty) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                return e.returnValue;
            }
        });

        // ============================================================================
        // PANEL RESIZING
        // ============================================================================
        
        function initPanelResizing() {
            const handles = document.querySelectorAll('.resize-handle-vertical');
            
            console.log('Initializing panel resizing, found', handles.length, 'handles');
            
            handles.forEach((handle, index) => {
                console.log('Setting up resize handle', index, 'for', handle.dataset.target);
                
                let isResizing = false;
                let startX = 0;
                let startWidth = 0;
                let targetPanel = null;
                let targetId = null;
                
                const handleMouseDown = (e) => {
                    console.log('Resize mousedown on', handle.dataset.target);
                    isResizing = true;
                    startX = e.clientX;
                    targetId = handle.dataset.target;
                    targetPanel = document.getElementById(targetId);
                    
                    if (targetPanel) {
                        startWidth = targetPanel.offsetWidth;
                        handle.classList.add('active');
                        document.body.style.cursor = 'col-resize';
                        document.body.style.userSelect = 'none';
                        console.log('Started resizing', targetId, 'from width', startWidth);
                        
                        // Add move and up listeners
                        document.addEventListener('mousemove', handleMouseMove);
                        document.addEventListener('mouseup', handleMouseUp);
                    } else {
                        console.error('Target panel not found:', targetId);
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                };
                
                const handleMouseMove = (e) => {
                    if (!isResizing || !targetPanel) return;
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    let newWidth;
                    
                    if (targetId === 'sidebar') {
                        // Sidebar: resize from left to right
                        const delta = e.clientX - startX;
                        newWidth = startWidth + delta;
                    } else {
                        // Preview/AI panels: resize from right to left
                        const delta = startX - e.clientX;
                        newWidth = startWidth + delta;
                    }
                    
                    // Apply constraints - generous limits for professional-grade flexibility
                    const minWidth = parseInt(getComputedStyle(targetPanel).minWidth) || 150;
                    const maxWidth = parseInt(getComputedStyle(targetPanel).maxWidth) || 1600;
                    
                    // Ensure minimum 150px for editor area - allow panels to take up to 80% of viewport
                    const editorContainer = document.querySelector('.editor-container');
                    const minEditorWidth = 150;
                    const availableSpace = window.innerWidth - minEditorWidth;
                    
                    // Calculate how much space other panels are using
                    const sidebar = document.getElementById('sidebar');
                    const aiPanel = document.getElementById('ai-panel');
                    const previewPane = document.getElementById('preview-pane');
                    
                    let otherPanelsWidth = 0;
                    if (targetId !== 'sidebar' && sidebar && !sidebar.classList.contains('hidden')) {
                        otherPanelsWidth += sidebar.offsetWidth;
                    }
                    if (targetId !== 'ai-panel' && aiPanel && !aiPanel.classList.contains('hidden')) {
                        otherPanelsWidth += aiPanel.offsetWidth;
                    }
                    if (targetId !== 'preview-pane' && previewPane && !previewPane.classList.contains('hidden')) {
                        otherPanelsWidth += previewPane.offsetWidth;
                    }
                    
                    const maxPanelWidth = availableSpace - otherPanelsWidth;
                    newWidth = Math.max(minWidth, Math.min(maxWidth, maxPanelWidth, newWidth));
                    
                    targetPanel.style.width = newWidth + 'px';
                    targetPanel.style.flexGrow = '0';
                    targetPanel.style.flexShrink = '0';
                    targetPanel.style.flexBasis = 'auto';
                };
                
                const handleMouseUp = (e) => {
                    if (isResizing && targetPanel) {
                        const finalWidth = targetPanel.offsetWidth;
                        
                        savePanelSize(targetId, finalWidth);
                        console.log('Resize complete:', targetId, 'final width:', finalWidth);
                        
                        isResizing = false;
                        handle.classList.remove('active');
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                        
                        // Remove event listeners
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                        
                        targetPanel = null;
                        targetId = null;
                        
                        e.preventDefault();
                        e.stopPropagation();
                    }
                };
                
                // Attach initial mousedown listener
                handle.addEventListener('mousedown', handleMouseDown);
            });
        }
        
        function savePanelSize(panelId, width) {
            try {
                const key = `cosmo-panel-size-${panelId}`;
                localStorage.setItem(key, width.toString());
            } catch (e) {
                console.error('Failed to save panel size:', e);
            }
        }
        
        function restorePanelSizes() {
            const panels = ['sidebar', 'preview-pane', 'ai-panel'];
            
            panels.forEach(panelId => {
                try {
                    const key = `cosmo-panel-size-${panelId}`;
                    const saved = localStorage.getItem(key);
                    if (saved) {
                        const panel = document.getElementById(panelId);
                        if (panel) {
                            panel.style.width = saved + 'px';
                        }
                    }
                } catch (e) {
                    console.error(`Failed to restore ${panelId} size:`, e);
                }
            });
        }

        // ============================================================================
        // FILE CREATION (AI-Triggered or Manual)
        // ============================================================================
        
        // ============================================================================
        // INLINE DIFF VIEWER - Monaco DiffEditor integration
        // ============================================================================
        
        let diffEditor = null;
        let currentDiffCallback = null;
        let currentDiffOriginal = null;
        let currentDiffModified = null;
        
        function showInlineDiff(original, modified, fileName, onAccept) {
            // Store callback and content
            currentDiffCallback = onAccept;
            currentDiffOriginal = original;
            currentDiffModified = modified;
            
            // Hide normal editor, show diff editor
            document.getElementById('monaco-editor').classList.add('hidden');
            document.getElementById('monaco-diff-editor').classList.remove('hidden');
            document.getElementById('diff-action-bar').classList.remove('hidden');
            document.getElementById('diff-file-name').textContent = fileName || 'Changes';
            
            // Create diff editor if it doesn't exist
            const diffContainer = document.getElementById('monaco-diff-editor');
            
            if (!diffEditor) {
                diffEditor = monaco.editor.createDiffEditor(diffContainer, {
                    enableSplitViewResizing: true,
                    renderSideBySide: true,
                    readOnly: false,
                    originalEditable: false,
                    automaticLayout: true,
                    theme: settings.theme || 'vs-dark',
                    fontSize: settings.fontSize || 14,
                    minimap: { enabled: settings.minimap !== false }
                });
            }
            
            // Detect language from filename or use plaintext
            const language = fileName ? detectLanguage(fileName) : 'plaintext';
            
            // Create models
            const originalModel = monaco.editor.createModel(original, language);
            const modifiedModel = monaco.editor.createModel(modified, language);
            
            // Set models in diff editor
            diffEditor.setModel({
                original: originalModel,
                modified: modifiedModel
            });
            
            // Focus the diff editor
            diffEditor.focus();
        }
        
        function acceptCurrentDiff() {
            if (currentDiffCallback) {
                currentDiffCallback();
                currentDiffCallback = null;
            }
            exitDiffMode();
        }
        
        function rejectCurrentDiff() {
            currentDiffCallback = null;
            exitDiffMode();
            showToast('Changes rejected', 'success');
        }
        
        function exitDiffMode() {
            // Dispose diff editor models
            if (diffEditor) {
                const model = diffEditor.getModel();
                if (model) {
                    model.original?.dispose();
                    model.modified?.dispose();
                }
            }
            
            // Hide diff editor, show normal editor
            document.getElementById('monaco-diff-editor').classList.add('hidden');
            document.getElementById('monaco-editor').classList.remove('hidden');
            document.getElementById('diff-action-bar').classList.add('hidden');
            
            // Clear state
            currentDiffCallback = null;
            currentDiffOriginal = null;
            currentDiffModified = null;
            
            // Refocus normal editor
            if (editor) {
                editor.focus();
            }
        }
        
        // ============================================================================
        // CSV TABLE BUILDER
        // ============================================================================
        
        function showCSVBuilder() {
            document.getElementById('csv-builder').classList.remove('hidden');
            document.getElementById('overlay').classList.remove('hidden');
            
            // Generate default grid
            generateCSVGrid();
        }
        
        function closeCSVBuilder() {
            document.getElementById('csv-builder').classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');
        }
        
        function generateCSVGrid() {
            const rows = parseInt(document.getElementById('csv-rows').value) || 5;
            const cols = parseInt(document.getElementById('csv-cols').value) || 4;
            const gridDiv = document.getElementById('csv-grid');
            
            let html = '<table style="width: 100%; border-collapse: collapse;">';
            
            // Header row
            html += '<tr style="background: var(--bg-secondary);">';
            for (let c = 0; c < cols; c++) {
                html += `<th style="border: 1px solid var(--border-color); padding: 8px;">
                    <input type="text" class="csv-cell" data-row="0" data-col="${c}" 
                           placeholder="Column ${c + 1}" 
                           style="width: 100%; background: transparent; border: none; color: var(--text-primary); font-weight: 600;">
                </th>`;
            }
            html += '</tr>';
            
            // Data rows
            for (let r = 1; r <= rows; r++) {
                html += '<tr>';
                for (let c = 0; c < cols; c++) {
                    html += `<td style="border: 1px solid var(--border-color); padding: 4px;">
                        <input type="text" class="csv-cell" data-row="${r}" data-col="${c}" 
                               placeholder="" 
                               style="width: 100%; background: transparent; border: none; color: var(--text-primary);">
                    </td>`;
                }
                html += '</tr>';
            }
            html += '</table>';
            
            gridDiv.innerHTML = html;
        }
        
        async function createCSVFile() {
            const fileName = document.getElementById('csv-filename').value || 'data.csv';
            const cells = document.querySelectorAll('#csv-grid .csv-cell');
            
            if (cells.length === 0) {
                showToast('Generate a grid first', 'error');
                return;
            }
            
            // Build CSV data structure
            const data = {};
            cells.forEach(cell => {
                const row = cell.dataset.row;
                const col = cell.dataset.col;
                if (!data[row]) data[row] = {};
                data[row][col] = cell.value || '';
            });
            
            // Convert to CSV text
            const rows = Object.keys(data).sort((a, b) => parseInt(a) - parseInt(b));
            const csvLines = rows.map(r => {
                const cols = Object.keys(data[r]).sort((a, b) => parseInt(a) - parseInt(b));
                return cols.map(c => {
                    const value = data[r][c];
                    // Escape quotes and wrap in quotes if contains comma, quote, or newline
                    if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                }).join(',');
            });
            
            const csvContent = csvLines.join('\n');
            
            // Create file
            const currentFolder = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            const fullPath = fileName.startsWith('/') ? fileName : `${currentFolder}/${fileName}`;
            
            try {
                await createFileOrFolder(fullPath, csvContent);
                showToast(`Created ${fileName}`, 'success');
                closeCSVBuilder();
            } catch (error) {
                showToast(`Failed to create CSV: ${error.message}`, 'error');
            }
        }
        
        // ============================================================================
        // CHAT HISTORY UI FUNCTIONS
        // ============================================================================
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        async function toggleChatHistory() {
            const panel = document.getElementById('chat-history-panel');
            const btn = document.getElementById('history-toggle-btn');
            const isHidden = panel.classList.contains('hidden');
            
            if (isHidden) {
                // Show panel
                panel.classList.remove('hidden');
                if (btn) btn.classList.add('active');
                await updateChatHistoryUI();
                
                // Add click-outside listener to auto-close
                setTimeout(() => {
                    document.addEventListener('click', closeChatHistoryOnClickOutside);
                }, 100);
            } else {
                // Hide panel
                panel.classList.add('hidden');
                if (btn) btn.classList.remove('active');
                document.removeEventListener('click', closeChatHistoryOnClickOutside);
            }
        }

        function closeChatHistoryOnClickOutside(event) {
            const panel = document.getElementById('chat-history-panel');
            const btn = document.getElementById('history-toggle-btn');
            const historyButton = event.target.closest('#history-toggle-btn');
            
            // Don't close if clicking the history button or inside the panel
            if (!historyButton && !panel.contains(event.target)) {
                panel.classList.add('hidden');
                if (btn) btn.classList.remove('active');
                document.removeEventListener('click', closeChatHistoryOnClickOutside);
            }
        }
        
        function startNewChat() {
            // Clear current conversation
            aiConversationHistory = [];
            chatHistory.startNewConversation();
            
            // Clear chat UI
            const messagesDiv = document.getElementById('ai-chat-messages');
            messagesDiv.innerHTML = `
                <div style="padding: 40px 20px; text-align: center; color: var(--text-secondary); font-size: 13px; opacity: 0.6;">
                    <div style="font-size: 32px; margin-bottom: 16px;">âœ¨</div>
                    New conversation started. How can I help?
                </div>
            `;
            
            showToast('Started new conversation', 'success');
        }
        
        async function updateChatHistoryUI() {
            await chatHistory.loadConversationsFromServer();
            
            // DEBUG: Show ALL conversations regardless of folder
            const allConvs = chatHistory.allConversations;
            console.log('[CHAT HISTORY] Total conversations:', allConvs.length);
            console.log('[CHAT HISTORY] Current directory:', chatHistory.getCurrentDirectory());
            
            const conversations = allConvs; // Show all for now
            const listEl = document.getElementById('chat-history-list');
            
            if (conversations.length === 0) {
                listEl.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: var(--text-secondary); font-size: 12px;">
                        No chat history found
                    </div>
                `;
                return;
            }
            
            listEl.innerHTML = conversations.map(conv => {
                const date = new Date(conv.timestamp);
                const timeStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                const messageCount = conv.messageCount;
                const preview = conv.title || 'Untitled conversation';
                
                return `
                    <div class="chat-history-item" onclick="loadChatConversation('${conv.id}')">
                        <div class="conv-title">${preview}</div>
                        <div class="conv-meta">
                            <span>${timeStr}</span>
                            <span>${messageCount} messages</span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        async function loadChatConversation(conversationId) {
            const conversation = await chatHistory.loadConversation(conversationId);
            if (!conversation) {
                showToast('Conversation not found', 'error');
                return;
            }
            
            // Load messages into conversation history
            aiConversationHistory = conversation.messages.map(m => ({
                role: m.role,
                content: m.content
            }));
            
            // Clear and rebuild chat UI
            const messagesDiv = document.getElementById('ai-chat-messages');
            messagesDiv.innerHTML = '';
            
            conversation.messages.forEach(msg => {
                addChatMessage(msg.role, msg.content, {});
            });
            
            // Close history panel
            const historyPanel = document.getElementById('chat-history-panel');
            historyPanel.classList.add('hidden');
            document.removeEventListener('click', closeChatHistoryOnClickOutside);
            
            showToast(`ðŸ“‚ ${conversation.title}`, 'success');
        }
        
        // ============================================================================
        // CONTEXT MENU - Cursor-style right-click options
        // ============================================================================
        
        function showContextMenu(x, y, filePath) {
            const menu = document.getElementById('context-menu');
            const fileData = openFiles.get(filePath);
            const fileName = filePath.split('/').pop();
            
            const menuItems = [
                { icon: 'ðŸ‘ï¸', label: 'Open in Browser', action: () => openInBrowser(filePath) },
                { icon: 'ðŸ“', label: 'Reveal in Finder', action: () => revealInFinder(filePath) },
                { separator: true },
                { icon: 'ðŸ“‹', label: 'Copy Path', action: () => copyFilePath(filePath) },
                { icon: 'ðŸ“‹', label: 'Copy Relative Path', action: () => copyRelativePath(filePath) },
                { separator: true },
                { icon: 'âœï¸', label: 'Rename...', action: () => renameFileDialog(filePath) },
                { icon: 'ðŸ—‘ï¸', label: 'Delete...', action: () => deleteFileDialog(filePath), danger: true },
                { separator: true },
                { icon: 'ðŸ“Œ', label: fileData && pinnedTabs.has(filePath) ? 'Unpin Tab' : 'Pin Tab', action: () => togglePinTab(filePath) },
                { icon: 'ðŸ’¾', label: 'Save', action: () => saveFile(filePath), disabled: !fileData || !fileData.dirty },
                { icon: 'ðŸ”„', label: 'Close Tab', action: () => closeFile(filePath), disabled: !fileData }
            ];
            
            // Clear menu
            menu.innerHTML = '';
            
            // Build menu with proper event listeners (not inline onclick)
            menuItems.forEach((item, index) => {
                if (item.separator) {
                    const separator = document.createElement('div');
                    separator.className = 'context-menu-separator';
                    menu.appendChild(separator);
                } else {
                    const menuItem = document.createElement('div');
                    menuItem.className = 'context-menu-item';
                    if (item.disabled) menuItem.classList.add('disabled');
                    if (item.danger) menuItem.classList.add('danger');
                    
                    menuItem.innerHTML = `
                        <span>${item.icon}</span>
                        <span>${item.label}</span>
                    `;
                    
                    // Add click handler with proper closure
                    menuItem.addEventListener('click', (e) => {
                        if (!menuItem.classList.contains('disabled')) {
                            item.action();
                            hideContextMenu();
                        }
                    });
                    
                    menu.appendChild(menuItem);
                }
            });
            
            // Position menu
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            menu.classList.remove('hidden');
            
            // Store current file for action callbacks
            window.contextMenuTarget = filePath;
        }
        
        function hideContextMenu() {
            document.getElementById('context-menu').classList.add('hidden');
            window.contextMenuTarget = null;
        }
        
        async function openInBrowser(filePath) {
            const url = `/api/serve-file?path=${encodeURIComponent(filePath)}`;
            window.open(url, '_blank');
            showToast('Opened in browser', 'success');
        }
        
        async function revealInFinder(filePath) {
            try {
                const response = await fetch('/api/reveal-in-finder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: filePath })
                });
                
                const data = await response.json();
                if (data.success) {
                    showToast('Opened in Finder', 'success');
                } else {
                    showToast(data.error || 'Failed to reveal file', 'error');
                }
            } catch (error) {
                showToast('Failed to reveal file', 'error');
            }
        }
        
        function copyFilePath(filePath) {
            copyToClipboard(filePath);
            showToast('Copied full path', 'success');
        }
        
        function copyRelativePath(filePath) {
            const currentFolder = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            let relative = filePath.replace(currentFolder + '/', '');
            if (relative === filePath) relative = './' + filePath.split('/').pop();
            copyToClipboard(relative);
            showToast('Copied relative path', 'success');
        }
        
        function togglePinTab(filePath) {
            if (pinnedTabs.has(filePath)) {
                pinnedTabs.remove(filePath);
                showToast('Tab unpinned', 'success');
            } else {
                pinnedTabs.add(filePath);
                showToast('Tab pinned', 'success');
            }
            renderTabs();
        }
        
        // Close all modals and context menu on click outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.context-menu')) {
                hideContextMenu();
            }
        });
        
        /**
         * User-triggered: Create new file
         * Prompts for filename and creates in current folder
         */
        async function createNewFile() {
            const currentFolder = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            const fileName = prompt('Enter new file name:', 'untitled.md');
            
            if (!fileName) return;
            
            // Build full path
            const fullPath = fileName.startsWith('/') ? fileName : `${currentFolder}/${fileName}`;
            
            try {
                await createFileOrFolder(fullPath, '');
                showToast(`Created ${fileName}`, 'success');
            } catch (error) {
                showToast(`Failed to create file: ${error.message}`, 'error');
            }
        }
        
        /**
         * User-triggered: Create new folder
         * Prompts for folder name and creates in current folder
         */
        async function createNewFolder() {
            const currentFolder = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            const folderName = prompt('Enter new folder name:', 'new-folder');
            
            if (!folderName) return;
            
            // Build full path (ensure it ends with /)
            const fullPath = folderName.startsWith('/') ? folderName : `${currentFolder}/${folderName}`;
            const normalizedPath = fullPath.endsWith('/') ? fullPath : `${fullPath}/`;
            
            try {
                await createFileOrFolder(normalizedPath, '');
                showToast(`Created folder ${folderName}`, 'success');
            } catch (error) {
                showToast(`Failed to create folder: ${error.message}`, 'error');
            }
        }
        
        async function createFileOrFolder(filePath, content = '') {
            try {
                // Detect if it's a folder (ends with / or has no extension and no content)
                const isFolder = filePath.endsWith('/') || (!filePath.includes('.') && !content);
                
                if (isFolder) {
                    // Create folder (just write a .gitkeep file in it)
                    const folderPath = filePath.replace(/\/$/, '');
                    const keepFile = `${folderPath}/.gitkeep`;
                    const data = await FileAPI.writeFile(keepFile, '');
                    
                    if (!data.success) {
                        throw new Error(data.error || 'Failed to create folder');
                    }
                    
                    console.log('[FOLDER CREATE] Success:', folderPath);
                    showToast(`Created folder: ${folderPath.split('/').pop()}`, 'success');
                } else {
                    // Create file
                    const data = await FileAPI.writeFile(filePath, content);
                    
                    if (!data.success) {
                        throw new Error(data.error || 'Failed to create file');
                    }
                    
                    console.log('[FILE CREATE] Success:', filePath);
                    showToast(`Created: ${filePath.split('/').pop()}`, 'success');
                }
                
                // Reload file tree
                await loadFileTree();
                
                // Open the file if it's not a folder
                if (!isFolder) {
                    setTimeout(() => {
                        const fileName = filePath.split('/').pop();
                        openFile(filePath, fileName);
                    }, 500);
                }
                
                return true;
            } catch (error) {
                console.error('[CREATE] Error:', error);
                showToast('Failed to create: ' + error.message, 'error');
                return false;
            }
        }

        // ============================================================================
        // FOLDER BROWSER
        // ============================================================================
        
        // Default browse path - user can navigate anywhere from here
        // Detect OS from user agent (rough heuristic for default path)
        const isWindows = navigator.userAgent.toLowerCase().includes('windows');
        let currentBrowsePath = isWindows ? 'C:\\Users' : '/';
        
        async function showFolderBrowser() {
            document.getElementById('folder-browser').classList.remove('hidden');
            document.getElementById('overlay').classList.remove('hidden');
            await browseFolders(currentBrowsePath);
        }
        
        function closeFolderBrowser() {
            document.getElementById('folder-browser').classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');
        }
        
        async function browseFolders(folderPath) {
            currentBrowsePath = folderPath;
            document.getElementById('current-path-display').textContent = folderPath;
            
            const folderList = document.getElementById('folder-list');
            folderList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">Loading...</div>';
            
            try {
                const response = await fetch(`/api/folder/browse?path=${encodeURIComponent(folderPath)}`);
                const data = await response.json();
                
                if (!data.success) {
                    folderList.innerHTML = `<div style="text-align: center; color: var(--error-color); padding: 20px;">${data.error}</div>`;
                    return;
                }
                
                const folders = data.files.filter(item => item.isDirectory);
                
                if (folders.length === 0) {
                    folderList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No subfolders</div>';
                    return;
                }
                
                folderList.innerHTML = folders.map(folder => `
                    <div onclick="browseFolders('${folder.path.replace(/'/g, "\\'")}');" 
                         style="padding: 10px 12px; cursor: pointer; border-radius: 4px; transition: background 0.15s; display: flex; align-items: center; gap: 8px; margin-bottom: 4px;"
                         onmouseover="this.style.background='var(--bg-tertiary)'" 
                         onmouseout="this.style.background='transparent'">
                        <span style="font-size: 18px;">ðŸ“</span>
                        <span style="font-size: 13px;">${folder.name}</span>
                    </div>
                `).join('');
                
            } catch (error) {
                folderList.innerHTML = `<div style="text-align: center; color: var(--error-color); padding: 20px;">Error: ${error.message}</div>`;
            }
        }
        
        async function navigateUp() {
            const parentPath = currentBrowsePath.substring(0, currentBrowsePath.lastIndexOf('/')) || '/';
            await browseFolders(parentPath);
        }
        
        async function navigateToHome() {
            // Navigate to root URL
            window.location.href = '/';
        }
        
        function selectCurrentFolder() {
            if (!currentBrowsePath) {
                showToast('Please select a folder', 'error');
                return;
            }
            closeFolderBrowser();
            selectAndLoadFolder(currentBrowsePath);
        }
        
        async function selectAndLoadFolder(path) {
            folderPath = path;
            await loadFileTree();
            showToast(`Loaded: ${path.split('/').pop()}`, 'success');
        }
        
        function goToManualPath() {
            const input = document.getElementById('manual-path-input');
            const path = input.value.trim();
            if (!path) {
                showToast('Please enter a path', 'error');
                return;
            }
            // Navigate to that path in the browser
            browseFolders(path);
        }

        // ============================================================================
        // COMMAND REGISTRY INITIALIZATION
        // ============================================================================
        
        function initializeCommands() {
            commands = [
                { id: 'file.save', label: 'Save File', action: saveCurrentFile, keys: 'Cmd+S' },
                { id: 'file.saveAll', label: 'Save All Files', action: saveAllFiles, keys: 'Cmd+Shift+S' },
                { id: 'file.close', label: 'Close File', action: () => { if (activeFile) closeTab(activeFile); }, keys: 'Cmd+W' },
                { id: 'file.closeOthers', label: 'Close Other Tabs', action: closeOtherTabs },
                { id: 'file.closeUnpinned', label: 'Close Unpinned Tabs', action: closeUnpinnedTabs },
                { id: 'file.download', label: 'Download Current File', action: downloadCurrentFile },
                { id: 'file.downloadAll', label: 'Download All Files', action: downloadAllFiles },
                { id: 'file.recent', label: 'Recent Files', action: showRecentFiles, keys: 'Cmd+E' },
                { id: 'file.new', label: 'New File', action: showNewFileDialog },
                { id: 'file.rename', label: 'Rename File', action: () => { if (activeFile) renameFileDialog(activeFile); } },
                { id: 'file.delete', label: 'Delete File', action: () => { if (activeFile) deleteFileDialog(activeFile); } },
                { id: 'export.html', label: 'Export Markdown to HTML', action: exportMarkdownToHTML },
                { id: 'export.pdf', label: 'Export Markdown to PDF', action: exportMarkdownToPDF },
                { id: 'view.toggleSidebar', label: 'Toggle Sidebar', action: toggleSidebar, keys: 'Cmd+B' },
                { id: 'view.togglePreview', label: 'Toggle Preview (MD/HTML/JSON/CSS/SVG/Images)', action: togglePreview, keys: 'Cmd+K V' },
                { id: 'view.settings', label: 'Open Settings', action: toggleSettings, keys: 'Cmd+,' },
                { id: 'editor.action.formatDocument', label: 'Format Document', action: () => editor && editor.getAction('editor.action.formatDocument').run() },
                { id: 'editor.find', label: 'Find', action: toggleSearch, keys: 'Cmd+F' },
                { id: 'editor.findInFiles', label: 'Find in All Files', action: showFindInFiles, keys: 'Cmd+Shift+F' },
                { id: 'tab.pin', label: 'Pin/Unpin Current Tab', action: () => { if (activeFile) togglePinTab(activeFile); } },
                { id: 'ai.toggle', label: 'Toggle AI Assistant', action: toggleAI, keys: 'Cmd+K A' },
                { id: 'ai.improve', label: 'AI: Improve Selection', action: () => aiQuickAction('improve') },
                { id: 'ai.grammar', label: 'AI: Check Grammar', action: () => aiQuickAction('grammar') },
                { id: 'ai.summarize', label: 'AI: Summarize', action: () => aiQuickAction('summarize') },
                { id: 'help.keyboard', label: 'Keyboard Shortcuts', action: toggleKeyboardHelp, keys: '?' },
            ];
        }

        // ============================================================================
        // BRAIN STUDIO TAB SWITCHING
        // ============================================================================
        
        async function loadReadmeTab() {
          const contentEl = document.getElementById('readme-content');
          try {
            const response = await fetch('/api/folder/read?path=README.md');
            const data = await response.json();
            
            if (data.success && window.marked) {
              contentEl.innerHTML = marked.parse(data.content);
              // Highlight code blocks
              contentEl.querySelectorAll('pre code').forEach((block) => {
                if (typeof hljs !== 'undefined') hljs.highlightElement(block);
              });
            } else {
              contentEl.innerHTML = `<div style="color: var(--error-color); padding: 20px;">Failed to load documentation.</div>`;
            }
          } catch (e) {
            console.error('Failed to load README:', e);
            contentEl.innerHTML = `<div style="color: var(--error-color); padding: 20px;">Error loading documentation.</div>`;
          }
        }

        function switchBrainTab(tabName) {
          console.log('[BRAIN STUDIO] Switching to tab:', tabName);
          
          // Update mode description
          const modeDesc = document.getElementById('modeDescription');
          if (modeDesc) {
            if (tabName === 'readme') modeDesc.textContent = 'Platform documentation & guides';
            else if (tabName === 'query') modeDesc.textContent = 'Knowledge retrieval & synthesis';
            else if (tabName === 'files') modeDesc.textContent = 'Action-oriented workspace';
            else if (tabName === 'explore') modeDesc.textContent = 'Knowledge graph exploration';
          }
          
          // Update tab buttons
          document.querySelectorAll('.tab-btn').forEach(btn => {
            const isActive = btn.dataset.tab === tabName;
            btn.classList.toggle('active', isActive);
          });
          
          // Update panels
          document.querySelectorAll('.brain-tab-panel').forEach(panel => {
            panel.style.display = panel.id === (tabName + '-tab-panel') ? 'flex' : 'none';
          });
          
          // AUTO-OPEN AI PANEL in Agent IDE
          if (tabName === 'files') {
            const aiPanel = document.getElementById('ai-panel');
            const aiBtn = document.getElementById('ai-btn');
            if (aiPanel) {
              aiPanel.classList.remove('hidden');
              if (aiBtn) aiBtn.classList.add('active');
            }
          } else if (tabName === 'readme' || tabName === 'explore') {
            // Auto-hide AI panel in documentation or explore modes to maximize space
            const aiPanel = document.getElementById('ai-panel');
            const aiBtn = document.getElementById('ai-btn');
            if (aiPanel && !aiPanel.classList.contains('hidden')) {
              toggleAI();
            }
          }

          // Initialize tabs on first view
          if (tabName === 'readme' && !window.readmeTabInitialized) {
            loadReadmeTab();
            window.readmeTabInitialized = true;
          }
          if (tabName === 'query' && !window.queryTabInitialized) {
            if (typeof initQueryTab === 'function') initQueryTab();
            window.queryTabInitialized = true;
          }
          if (tabName === 'explore' && !window.exploreTabInitialized) {
            if (typeof initExploreTab === 'function') initExploreTab();
            window.exploreTabInitialized = true;
          }
        }
        
        // ============================================================================
        // INITIALIZATION - Setup auto-save on load
        // ============================================================================
        
        initializeCommands();
        setupAutoSave();
        
        // Initialize panel resizing after DOM loaded
        document.addEventListener('DOMContentLoaded', async () => {
            initPanelResizing();
            restorePanelSizes();
            
            // Set initial tab state
            switchBrainTab('files');
            
            // Hard fail-safe: if any modal/overlay got stuck open from a prior session, close it.
            try { closeAllModals(); } catch (e) {}
            
            // Check if brain is loaded and auto-open its output folder
            try {
                const brainInfo = await fetch('/api/brain/info').then(r => r.json());
                window.currentBrainInfo = brainInfo;
                
                if (brainInfo.hasBrain) {
                    // Update title with brain name
                    const stats = await fetch('/api/brain/stats').then(r => r.json());
                    document.getElementById('brainStudioTitle').textContent = `Brain Studio Â· ${brainInfo.brainName} Â· ${stats.nodes} nodes`;
                    
                    // Auto-load brain's output folder
                    if (brainInfo.outputsPath) {
                        console.log('Auto-loading brain outputs:', brainInfo.outputsPath);
                        await selectAndLoadFolder(brainInfo.outputsPath);
                    }
                } else {
                    document.getElementById('brainStudioTitle').textContent = 'Brain Studio (IDE Mode)';
                    // Show folder picker after a short delay
                    setTimeout(() => {
                        const folderBrowser = document.getElementById('folder-browser');
                        const overlay = document.getElementById('overlay');
                        if (folderBrowser && overlay) {
                            folderBrowser.classList.remove('hidden');
                            overlay.classList.remove('hidden');
                            browseFolders('/Users');
                        }
                    }, 150);
                }
            } catch (error) {
                console.error('Failed to load brain info:', error);
                document.getElementById('brainStudioTitle').textContent = 'Brain Studio (IDE Mode)';
            }
        });
    </script>
    
    <!-- Brain Studio Tab Modules -->
    <script src="js/query-tab.js"></script>
    <script src="js/explore-tab.js"></script>
</body>
</html>
