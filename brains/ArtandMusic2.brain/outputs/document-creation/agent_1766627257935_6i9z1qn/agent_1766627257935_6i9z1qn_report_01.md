## 1) Extend `METADATA_SCHEMA.json` to *explicitly require* (a) exact claim text (verbatim), (b) source/context (who/date/link or screenshot reference), and (c) provenance anchor (dataset DOI/link or paper title/author)

Below is a concrete JSON Schema extension that adds **required** fields for each claim’s **verbatim text**, **source/context**, and a **provenance anchor**. This is designed to be dropped into the existing `METADATA_SCHEMA.json` that COSMO already uses (and that is validated in the single-command run that outputs `/outputs/qa/schema_validation.json` and a human-readable summary in the normalized QA report) [Memory item 1].

### Proposed `METADATA_SCHEMA.json` patch (claim-level requirements)

> Intent: every claim record must carry:
> 1) `claim_text_verbatim` (the exact claim string),
> 2) `source_context` (who/when/where, with link or screenshot reference),
> 3) `provenance_anchor` (dataset DOI/link **or** paper title/author).

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "METADATA_SCHEMA.json",
  "title": "COSMO Metadata Schema (extended claim requirements)",
  "type": "object",

  "properties": {
    "claims": {
      "type": "array",
      "items": { "$ref": "#/$defs/claim" },
      "minItems": 1
    }
  },

  "required": ["claims"],

  "$defs": {
    "claim": {
      "type": "object",
      "additionalProperties": true,

      "properties": {
        "claim_text_verbatim": {
          "type": "string",
          "minLength": 1,
          "description": "Exact claim text (verbatim)."
        },

        "source_context": {
          "type": "object",
          "additionalProperties": false,
          "description": "Source/context for where the claim came from: who/when and either a link or a screenshot reference.",

          "properties": {
            "who": {
              "type": "string",
              "minLength": 1,
              "description": "Who authored/said/published the claim (person/org/account)."
            },
            "date": {
              "type": "string",
              "minLength": 1,
              "description": "Date associated with the source/context (store as text if exact format varies)."
            },

            "link": {
              "type": "string",
              "minLength": 1,
              "description": "URL where the claim is visible (if applicable)."
            },
            "screenshot_reference": {
              "type": "string",
              "minLength": 1,
              "description": "Screenshot file reference or internal artifact pointer when no link is available."
            }
          },

          "required": ["who", "date"],
          "anyOf": [
            { "required": ["link"] },
            { "required": ["screenshot_reference"] }
          ]
        },

        "provenance_anchor": {
          "type": "object",
          "additionalProperties": false,
          "description": "Anchor the claim to a dataset DOI/link OR to a paper title/author.",

          "properties": {
            "dataset": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "doi_or_link": {
                  "type": "string",
                  "minLength": 1,
                  "description": "Dataset DOI or canonical dataset link."
                }
              },
              "required": ["doi_or_link"]
            },

            "paper": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "title": {
                  "type": "string",
                  "minLength": 1,
                  "description": "Paper title."
                },
                "author": {
                  "type": "string",
                  "minLength": 1,
                  "description": "Paper author(s) (free text acceptable)."
                }
              },
              "required": ["title", "author"]
            }
          },

          "anyOf": [
            { "required": ["dataset"] },
            { "required": ["paper"] }
          ]
        }
      },

      "required": [
        "claim_text_verbatim",
        "source_context",
        "provenance_anchor"
      ]
    }
  }
}
```

### What this concretely enforces

- **Exact claim text** is now mandatory via `claim_text_verbatim`.
- **Source/context** is mandatory via `source_context.who`, `source_context.date`, and **either** `source_context.link` **or** `source_context.screenshot_reference`.
- **Provenance anchor** is mandatory via `provenance_anchor`, requiring **either**:
  - `provenance_anchor.dataset.doi_or_link`, or
  - `provenance_anchor.paper.title` **and** `provenance_anchor.paper.author`.

This matches the mission’s three explicit requirements and directly integrates into the existing validator step that writes `/outputs/qa/schema_validation.json` [Memory item 1].

---

## 2) Update the runner to hard-stop when `/outputs/qa/schema_validation.json` contains errors

The memory states COSMO already has:  
- a **validator step** in a **single-command run**, and  
- that validator produces `/outputs/qa/schema_validation.json` plus a **human-readable summary** in the normalized QA report [Memory item 1].

The missing behavior requested is: **the runner must hard-stop when `schema_validation.json` contains errors**.

### Runner hard-stop behavior (required)

Implement the following logic in the run pipeline immediately after the schema validation step:

1. Run the schema validator (existing behavior) → it writes:
   - `/outputs/qa/schema_validation.json`
   - and emits/updates a human-readable summary in the normalized QA report [Memory item 1].

2. Load `/outputs/qa/schema_validation.json` and check whether it contains any validation errors.

3. If **any errors exist**, the runner must:
   - print the human-readable summary location (the normalized QA report output that already exists per the current pipeline) [Memory item 1],
   - exit non-zero (hard stop),
   - prevent subsequent steps from running.

### Concrete implementation snippet (Node-style pseudocode)

Because the memory only guarantees *the existence of the file and summary behavior* (not the exact runtime language), below is a minimal and explicit gate that can be adapted to the existing runner:

```js
import fs from "fs";

const validationPath = "outputs/qa/schema_validation.json";

if (!fs.existsSync(validationPath)) {
  throw new Error(`Missing schema validation output: ${validationPath}`);
}

const payload = JSON.parse(fs.readFileSync(validationPath, "utf-8"));

// Hard-stop condition: schema_validation.json contains errors
// (Exact shape may differ; enforce both common patterns.)
const hasErrors =
  (Array.isArray(payload.errors) && payload.errors.length > 0) ||
  payload.status === "error" ||
  payload.ok === false;

if (hasErrors) {
  // The process already produces a human-readable summary in the normalized QA report [Memory item 1]
  console.error("Schema validation failed. Hard-stopping run.");
  console.error(`See: ${validationPath}`);
  process.exit(1);
}
```

### Concrete implementation snippet (Python-style pseudocode)

```py
import json, sys
from pathlib import Path

validation_path = Path("outputs/qa/schema_validation.json")
if not validation_path.exists():
    raise RuntimeError(f"Missing schema validation output: {validation_path}")

payload = json.loads(validation_path.read_text())

has_errors = (
    (isinstance(payload.get("errors"), list) and len(payload["errors"]) > 0)
    or payload.get("status") == "error"
    or payload.get("ok") is False
)

if has_errors:
    # A human-readable summary is already emitted in the normalized QA report [Memory item 1]
    print("Schema validation failed. Hard-stopping run.", file=sys.stderr)
    print(f"See: {validation_path}", file=sys.stderr)
    sys.exit(1)
```

**Key requirement**: the runner must treat schema validation as a **gate**, not an informational step.

---

## Conclusion

This update does two things, both grounded in what COSMO already has in place: (1) it extends `METADATA_SCHEMA.json` so each claim must include **verbatim claim text**, **source/context (who/date plus link or screenshot reference)**, and a **provenance anchor (dataset DOI/link or paper title/author)**; and (2) it makes schema validation a true **blocking checkpoint** by forcing the runner to **hard-stop** whenever `/outputs/qa/schema_validation.json` reports errors—building directly on the existing single-command run that already produces that JSON artifact and a human-readable QA summary [Memory item 1].