## Implementation: `outputs/tools/validate_outputs.py` (single-command validator)

### Purpose (from mission + existing plans)
A one-command validator was repeatedly specified in COSMO planning notes:

- It must **check for the presence of required files**: `REPORT_OUTLINE.md`, `CASE_STUDY_TEMPLATE.md`, `METADATA_SCHEMA.json`, `WORKLOG.md`.  
  (Mission statement; also echoed in the validator plan at `2025-12-24T22-17-09-292Z`.)
- It must **return nonzero exit codes on failure**. (Mission statement.)
- It should be the canonical “QA gate” style step (consistent with the idea of “explicit acceptance/QA criteria with transparent documentation,” and the “canonical QA gate” artifact described in memory).
- One plan version additionally calls for **emitting a validation summary to `/outputs/logs/validation.txt`**. (Validator plan attempt at `2025-12-24T22-17-09-292Z`.)

Because the mission allows either a Python script or Makefile task, this implementation uses a Python script at:

- `outputs/tools/validate_outputs.py`

It is written to:
1) validate required files exist,  
2) write a human-readable summary to `outputs/logs/validation.txt`, and  
3) exit `0` on success and `1` on failure.

> Note: Some planning variants mention “run the scaffold generator first.” The only *explicit, stable* requirement in the mission you gave is the presence check + nonzero exit codes + documenting usage in `WORKLOG.md`. This script focuses strictly on that required gate, and logs the results to the `outputs/logs/validation.txt` path named in the planning notes.

---

## File: `outputs/tools/validate_outputs.py`

Save the following as `outputs/tools/validate_outputs.py`:

```python
#!/usr/bin/env python3
"""
outputs/tools/validate_outputs.py

Validates that required project artifacts exist under /outputs.

Required files (per mission):
- REPORT_OUTLINE.md
- CASE_STUDY_TEMPLATE.md
- METADATA_SCHEMA.json
- WORKLOG.md

Behavior:
- Writes a validation summary to: outputs/logs/validation.txt
- Exits 0 if all required files are present; exits 1 otherwise.
"""

from __future__ import annotations

import sys
from pathlib import Path
from datetime import datetime, timezone


REQUIRED_FILES = [
    "REPORT_OUTLINE.md",
    "CASE_STUDY_TEMPLATE.md",
    "METADATA_SCHEMA.json",
    "WORKLOG.md",
]


def utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat(timespec="seconds")


def main() -> int:
    # Resolve repository root as: two levels above this file (outputs/tools/.. -> outputs -> repo root)
    # This keeps paths stable even if invoked from elsewhere.
    script_path = Path(__file__).resolve()
    repo_root = script_path.parents[2]
    outputs_dir = repo_root / "outputs"
    logs_dir = outputs_dir / "logs"
    logs_dir.mkdir(parents=True, exist_ok=True)

    required_paths = [(name, outputs_dir / name) for name in REQUIRED_FILES]
    missing = [(name, path) for (name, path) in required_paths if not path.exists()]

    lines = []
    lines.append(f"validation_run_at_utc: {utc_now_iso()}")
    lines.append(f"repo_root: {repo_root}")
    lines.append(f"outputs_dir: {outputs_dir}")
    lines.append("")
    lines.append("required_files:")

    for name, path in required_paths:
        status = "OK" if path.exists() else "MISSING"
        lines.append(f"- {name}: {status} ({path})")

    lines.append("")
    if missing:
        lines.append("result: FAIL")
        lines.append("missing_files:")
        for name, path in missing:
            lines.append(f"- {name} ({path})")
        exit_code = 1
    else:
        lines.append("result: PASS")
        exit_code = 0

    report_text = "\n".join(lines) + "\n"
    report_path = logs_dir / "validation.txt"
    report_path.write_text(report_text, encoding="utf-8")

    # Also print the same summary to stdout for CI readability.
    sys.stdout.write(report_text)
    return exit_code


if __name__ == "__main__":
    raise SystemExit(main())
```

### Exit codes (nonzero on failure)
- `0` — all required artifacts exist under `outputs/`
- `1` — one or more required artifacts are missing

### Validation output
- Always writes: `outputs/logs/validation.txt`
- Always prints the same summary to stdout (so CI logs capture it)

---

## WORKLOG.md update (document usage)

The mission requires: “document usage in `WORKLOG.md`.” Below is a **ready-to-paste** entry that matches the dated style implied by the existing memory timeline (work occurred on **2025-12-24**) and records exactly what this validator checks and where it writes its summary.

Append this to `outputs/WORKLOG.md`:

```markdown
## 2025-12-24 — Outputs validation command added

Added a single-command validator script:

- Path: `outputs/tools/validate_outputs.py`

What it validates (required artifacts under `outputs/`):

- `REPORT_OUTLINE.md`
- `CASE_STUDY_TEMPLATE.md`
- `METADATA_SCHEMA.json`
- `WORKLOG.md`

Behavior:

- Writes a validation summary to: `outputs/logs/validation.txt`
- Prints the same summary to stdout
- Exit codes:
  - `0` if all required files are present
  - `1` if any required file is missing

How to run (from repo root):

```bash
python outputs/tools/validate_outputs.py
```
```

---

## Conclusion

This fulfills the mission requirements using only the specified facts from COSMO’s stored planning notes: a validator at `outputs/tools/validate_outputs.py` that checks for `REPORT_OUTLINE.md`, `CASE_STUDY_TEMPLATE.md`, `METADATA_SCHEMA.json`, and `WORKLOG.md`, writes a summary to `outputs/logs/validation.txt`, and returns a **nonzero exit code on failure**. Usage is explicitly documented as a dated entry in `outputs/WORKLOG.md`.