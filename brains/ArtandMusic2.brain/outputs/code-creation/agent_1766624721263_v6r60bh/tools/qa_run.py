#!/usr/bin/env python3
from __future__ import annotations
from pathlib import Path
import argparse, json, sys, datetime

ROOT = Path(__file__).resolve().parents[1]
OUT_QA = ROOT / "outputs" / "qa"
TEMPLATES = ROOT / "templates"

DEFAULT_OUTLINE = """# REPORT_OUTLINE
## Executive Summary
## Problem Statement
## Methodology
## Findings
## Recommendations
## Risks & Limitations
## Appendix
<!-- QA_MARKER:REPORT_OUTLINE_v1 -->
"""

DEFAULT_CASE = """# CASE_STUDY_TEMPLATE
## Context
## Objective
## Approach
## Evidence
## Results
## Lessons Learned
## Next Steps
<!-- QA_MARKER:CASE_STUDY_TEMPLATE_v1 -->
"""

SPECS = [
    {"path": "REPORT_OUTLINE.md", "must_contain": ["# REPORT_OUTLINE", "## Executive Summary", "## Findings", "QA_MARKER:REPORT_OUTLINE_v1"],
     "suggest": "Re-generate scaffold or ensure templates/REPORT_OUTLINE.md contains required headings and QA marker."},
    {"path": "CASE_STUDY_TEMPLATE.md", "must_contain": ["# CASE_STUDY_TEMPLATE", "## Context", "## Evidence", "QA_MARKER:CASE_STUDY_TEMPLATE_v1"],
     "suggest": "Re-generate scaffold or ensure templates/CASE_STUDY_TEMPLATE.md contains required sections and QA marker."},
]

def _read(p: Path) -> str:
    try: return p.read_text(encoding="utf-8")
    except Exception: return ""

def generate_scaffold() -> dict:
    OUT_QA.mkdir(parents=True, exist_ok=True)
    tpl_outline = TEMPLATES / "REPORT_OUTLINE.md"
    tpl_case = TEMPLATES / "CASE_STUDY_TEMPLATE.md"
    outline_txt = _read(tpl_outline).strip() or DEFAULT_OUTLINE.strip()
    case_txt = _read(tpl_case).strip() or DEFAULT_CASE.strip()

    written = []
    for rel, txt in [("REPORT_OUTLINE.md", outline_txt + "\n"), ("CASE_STUDY_TEMPLATE.md", case_txt + "\n")]:
        p = ROOT / rel
        if not p.exists():
            p.write_text(txt, encoding="utf-8")
            written.append(rel)

    # Baseline QA report stubs (do not overwrite if present)
    stub_json = OUT_QA / "baseline_qa_report.json"
    stub_md = OUT_QA / "baseline_qa_report.md"
    if not stub_json.exists():
        stub_json.write_text(json.dumps({"generated_at": datetime.datetime.utcnow().isoformat()+"Z","status":"stub"}, indent=2) + "\n", encoding="utf-8")
        written.append(str(stub_json.relative_to(ROOT)))
    if not stub_md.exists():
        stub_md.write_text("# Baseline QA Report (stub)\n\n- Generated by tools/qa_run.py\n", encoding="utf-8")
        written.append(str(stub_md.relative_to(ROOT)))
    return {"written": written}

def validate() -> tuple[bool, list[dict]]:
    results = []
    ok = True
    for s in SPECS:
        p = ROOT / s["path"]
        if not p.exists():
            ok = False
            results.append({"path": s["path"], "ok": False, "reason": "missing", "suggest": s["suggest"]})
            return ok, results  # fail fast
        txt = _read(p)
        missing = [m for m in s["must_contain"] if m not in txt]
        if missing:
            ok = False
            results.append({"path": s["path"], "ok": False, "reason": "missing_markers", "missing": missing, "suggest": s["suggest"]})
            return ok, results  # fail fast
        results.append({"path": s["path"], "ok": True})

    qa_files = list(OUT_QA.glob("*.json")) + list(OUT_QA.glob("*.md"))
    if not qa_files:
        ok = False
        results.append({"path": "outputs/qa/", "ok": False, "reason": "no_qa_reports",
                        "suggest": "Ensure outputs/qa contains at least one .json or .md QA report (baseline stubs are created by scaffold)."})
        return ok, results
    results.append({"path": "outputs/qa/", "ok": True, "count": len(qa_files)})
    return ok, results

def write_results(ok: bool, scaffold_info: dict, checks: list[dict]) -> Path:
    OUT_QA.mkdir(parents=True, exist_ok=True)
    payload = {
        "ok": ok,
        "generated_at": datetime.datetime.utcnow().isoformat()+"Z",
        "root": str(ROOT),
        "scaffold": scaffold_info,
        "checks": checks,
    }
    out_json = OUT_QA / "qa_results.json"
    out_md = OUT_QA / "qa_results.md"
    out_json.write_text(json.dumps(payload, indent=2) + "\n", encoding="utf-8")
    lines = [f"# QA Results\n\n- ok: {ok}\n- generated_at: {payload['generated_at']}\n",
             "## Scaffold\n" + ("- written:\n" + "\n".join([f"  - {x}" for x in scaffold_info.get("written",[])]) if scaffold_info.get("written") else "- written: []") + "\n",
             "## Checks\n" + "\n".join([f"- {c['path']}: {'PASS' if c.get('ok') else 'FAIL'}" + (f" ({c.get('reason')})" if not c.get('ok') else "") for c in checks])]
    fail = next((c for c in checks if not c.get("ok")), None)
    if fail and fail.get("suggest"):
        lines.append("\n## Suggested Fix\n- " + fail["suggest"] + "\n")
    out_md.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")
    return out_json

def main(argv=None) -> int:
    ap = argparse.ArgumentParser(description="Generate scaffold and run deterministic QA checks.")
    ap.add_argument("--no-generate", action="store_true", help="Skip scaffold generation step.")
    args = ap.parse_args(argv)

    scaffold_info = {"written": []}
    if not args.no_generate:
        scaffold_info = generate_scaffold()

    ok, checks = validate()
    out_json = write_results(ok, scaffold_info, checks)

    # Essential status only
    print(f"QA_OK:{ok}")
    print(f"QA_RESULTS:{out_json}")
    return 0 if ok else 1

if __name__ == "__main__":
    raise SystemExit(main())
