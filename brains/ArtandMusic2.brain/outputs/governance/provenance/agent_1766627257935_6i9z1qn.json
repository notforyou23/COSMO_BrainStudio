{
  "agentId": "agent_1766627257935_6i9z1qn",
  "timestamp": "2025-12-25T01:48:04.223Z",
  "mode": "observe",
  "stats": {
    "eventsLogged": 3642,
    "actionsClassified": 0,
    "actionsBlocked": 0,
    "actionsWarned": 0,
    "errors": 0
  },
  "inventoryHash": "no_inventory",
  "agentData": {
    "mission": "Extend METADATA_SCHEMA.json to explicitly require: (1) exact claim text (verbatim), (2) source/context (who/date/link or screenshot reference), and (3) provenance anchor (dataset DOI/link or paper title/author); update the runner to hard-stop when schema_validation.json contains errors.",
    "status": "completed",
    "results": {
      "success": true,
      "document": {
        "title": "Generated report",
        "content": "## 1) Extend `METADATA_SCHEMA.json` to *explicitly require* (a) exact claim text (verbatim), (b) source/context (who/date/link or screenshot reference), and (c) provenance anchor (dataset DOI/link or paper title/author)\n\nBelow is a concrete JSON Schema extension that adds **required** fields for each claim’s **verbatim text**, **source/context**, and a **provenance anchor**. This is designed to be dropped into the existing `METADATA_SCHEMA.json` that COSMO already uses (and that is validated in the single-command run that outputs `/outputs/qa/schema_validation.json` and a human-readable summary in the normalized QA report) [Memory item 1].\n\n### Proposed `METADATA_SCHEMA.json` patch (claim-level requirements)\n\n> Intent: every claim record must carry:\n> 1) `claim_text_verbatim` (the exact claim string),\n> 2) `source_context` (who/when/where, with link or screenshot reference),\n> 3) `provenance_anchor` (dataset DOI/link **or** paper title/author).\n\n```json\n{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"METADATA_SCHEMA.json\",\n  \"title\": \"COSMO Metadata Schema (extended claim requirements)\",\n  \"type\": \"object\",\n\n  \"properties\": {\n    \"claims\": {\n      \"type\": \"array\",\n      \"items\": { \"$ref\": \"#/$defs/claim\" },\n      \"minItems\": 1\n    }\n  },\n\n  \"required\": [\"claims\"],\n\n  \"$defs\": {\n    \"claim\": {\n      \"type\": \"object\",\n      \"additionalProperties\": true,\n\n      \"properties\": {\n        \"claim_text_verbatim\": {\n          \"type\": \"string\",\n          \"minLength\": 1,\n          \"description\": \"Exact claim text (verbatim).\"\n        },\n\n        \"source_context\": {\n          \"type\": \"object\",\n          \"additionalProperties\": false,\n          \"description\": \"Source/context for where the claim came from: who/when and either a link or a screenshot reference.\",\n\n          \"properties\": {\n            \"who\": {\n              \"type\": \"string\",\n              \"minLength\": 1,\n              \"description\": \"Who authored/said/published the claim (person/org/account).\"\n            },\n            \"date\": {\n              \"type\": \"string\",\n              \"minLength\": 1,\n              \"description\": \"Date associated with the source/context (store as text if exact format varies).\"\n            },\n\n            \"link\": {\n              \"type\": \"string\",\n              \"minLength\": 1,\n              \"description\": \"URL where the claim is visible (if applicable).\"\n            },\n            \"screenshot_reference\": {\n              \"type\": \"string\",\n              \"minLength\": 1,\n              \"description\": \"Screenshot file reference or internal artifact pointer when no link is available.\"\n            }\n          },\n\n          \"required\": [\"who\", \"date\"],\n          \"anyOf\": [\n            { \"required\": [\"link\"] },\n            { \"required\": [\"screenshot_reference\"] }\n          ]\n        },\n\n        \"provenance_anchor\": {\n          \"type\": \"object\",\n          \"additionalProperties\": false,\n          \"description\": \"Anchor the claim to a dataset DOI/link OR to a paper title/author.\",\n\n          \"properties\": {\n            \"dataset\": {\n              \"type\": \"object\",\n              \"additionalProperties\": false,\n              \"properties\": {\n                \"doi_or_link\": {\n                  \"type\": \"string\",\n                  \"minLength\": 1,\n                  \"description\": \"Dataset DOI or canonical dataset link.\"\n                }\n              },\n              \"required\": [\"doi_or_link\"]\n            },\n\n            \"paper\": {\n              \"type\": \"object\",\n              \"additionalProperties\": false,\n              \"properties\": {\n                \"title\": {\n                  \"type\": \"string\",\n                  \"minLength\": 1,\n                  \"description\": \"Paper title.\"\n                },\n                \"author\": {\n                  \"type\": \"string\",\n                  \"minLength\": 1,\n                  \"description\": \"Paper author(s) (free text acceptable).\"\n                }\n              },\n              \"required\": [\"title\", \"author\"]\n            }\n          },\n\n          \"anyOf\": [\n            { \"required\": [\"dataset\"] },\n            { \"required\": [\"paper\"] }\n          ]\n        }\n      },\n\n      \"required\": [\n        \"claim_text_verbatim\",\n        \"source_context\",\n        \"provenance_anchor\"\n      ]\n    }\n  }\n}\n```\n\n### What this concretely enforces\n\n- **Exact claim text** is now mandatory via `claim_text_verbatim`.\n- **Source/context** is mandatory via `source_context.who`, `source_context.date`, and **either** `source_context.link` **or** `source_context.screenshot_reference`.\n- **Provenance anchor** is mandatory via `provenance_anchor`, requiring **either**:\n  - `provenance_anchor.dataset.doi_or_link`, or\n  - `provenance_anchor.paper.title` **and** `provenance_anchor.paper.author`.\n\nThis matches the mission’s three explicit requirements and directly integrates into the existing validator step that writes `/outputs/qa/schema_validation.json` [Memory item 1].\n\n---\n\n## 2) Update the runner to hard-stop when `/outputs/qa/schema_validation.json` contains errors\n\nThe memory states COSMO already has:  \n- a **validator step** in a **single-command run**, and  \n- that validator produces `/outputs/qa/schema_validation.json` plus a **human-readable summary** in the normalized QA report [Memory item 1].\n\nThe missing behavior requested is: **the runner must hard-stop when `schema_validation.json` contains errors**.\n\n### Runner hard-stop behavior (required)\n\nImplement the following logic in the run pipeline immediately after the schema validation step:\n\n1. Run the schema validator (existing behavior) → it writes:\n   - `/outputs/qa/schema_validation.json`\n   - and emits/updates a human-readable summary in the normalized QA report [Memory item 1].\n\n2. Load `/outputs/qa/schema_validation.json` and check whether it contains any validation errors.\n\n3. If **any errors exist**, the runner must:\n   - print the human-readable summary location (the normalized QA report output that already exists per the current pipeline) [Memory item 1],\n   - exit non-zero (hard stop),\n   - prevent subsequent steps from running.\n\n### Concrete implementation snippet (Node-style pseudocode)\n\nBecause the memory only guarantees *the existence of the file and summary behavior* (not the exact runtime language), below is a minimal and explicit gate that can be adapted to the existing runner:\n\n```js\nimport fs from \"fs\";\n\nconst validationPath = \"outputs/qa/schema_validation.json\";\n\nif (!fs.existsSync(validationPath)) {\n  throw new Error(`Missing schema validation output: ${validationPath}`);\n}\n\nconst payload = JSON.parse(fs.readFileSync(validationPath, \"utf-8\"));\n\n// Hard-stop condition: schema_validation.json contains errors\n// (Exact shape may differ; enforce both common patterns.)\nconst hasErrors =\n  (Array.isArray(payload.errors) && payload.errors.length > 0) ||\n  payload.status === \"error\" ||\n  payload.ok === false;\n\nif (hasErrors) {\n  // The process already produces a human-readable summary in the normalized QA report [Memory item 1]\n  console.error(\"Schema validation failed. Hard-stopping run.\");\n  console.error(`See: ${validationPath}`);\n  process.exit(1);\n}\n```\n\n### Concrete implementation snippet (Python-style pseudocode)\n\n```py\nimport json, sys\nfrom pathlib import Path\n\nvalidation_path = Path(\"outputs/qa/schema_validation.json\")\nif not validation_path.exists():\n    raise RuntimeError(f\"Missing schema validation output: {validation_path}\")\n\npayload = json.loads(validation_path.read_text())\n\nhas_errors = (\n    (isinstance(payload.get(\"errors\"), list) and len(payload[\"errors\"]) > 0)\n    or payload.get(\"status\") == \"error\"\n    or payload.get(\"ok\") is False\n)\n\nif has_errors:\n    # A human-readable summary is already emitted in the normalized QA report [Memory item 1]\n    print(\"Schema validation failed. Hard-stopping run.\", file=sys.stderr)\n    print(f\"See: {validation_path}\", file=sys.stderr)\n    sys.exit(1)\n```\n\n**Key requirement**: the runner must treat schema validation as a **gate**, not an informational step.\n\n---\n\n## Conclusion\n\nThis update does two things, both grounded in what COSMO already has in place: (1) it extends `METADATA_SCHEMA.json` so each claim must include **verbatim claim text**, **source/context (who/date plus link or screenshot reference)**, and a **provenance anchor (dataset DOI/link or paper title/author)**; and (2) it makes schema validation a true **blocking checkpoint** by forcing the runner to **hard-stop** whenever `/outputs/qa/schema_validation.json` reports errors—building directly on the existing single-command run that already produces that JSON artifact and a human-readable QA summary [Memory item 1].",
        "format": "markdown",
        "metadata": {
          "author": "COSMO Document Agent",
          "createdAt": "2025-12-25T01:48:03.443Z",
          "mode": "memory_based",
          "memoryNodesUsed": 20,
          "formattedAt": "2025-12-25T01:48:03.443Z"
        },
        "filePath": "/Users/jtr/_JTR23_/COSMO/runtime/outputs/document-creation/agent_1766627257935_6i9z1qn/agent_1766627257935_6i9z1qn_report_01.md",
        "wordCount": 908,
        "createdAt": "2025-12-25T01:48:03.445Z",
        "version": "1.0.0",
        "deliverablePath": "/Users/jtr/_JTR23_/COSMO/runtime/outputs/document-creation/agent_1766627257935_6i9z1qn/agent_1766627257935_6i9z1qn_report_01.md",
        "metadataPath": "/Users/jtr/_JTR23_/COSMO/runtime/outputs/document-creation/agent_1766627257935_6i9z1qn/agent_1766627257935_6i9z1qn_report_01_metadata.json"
      },
      "metadata": {
        "type": "report",
        "title": "Generated report",
        "filePath": "/Users/jtr/_JTR23_/COSMO/runtime/outputs/document-creation/agent_1766627257935_6i9z1qn/agent_1766627257935_6i9z1qn_report_01.md",
        "wordCount": 908,
        "filesCreated": 1,
        "status": "complete",
        "createdAt": "2025-12-25T01:48:03.445Z"
      }
    }
  }
}