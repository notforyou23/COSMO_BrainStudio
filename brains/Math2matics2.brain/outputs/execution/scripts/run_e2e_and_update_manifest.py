#!/usr/bin/env python3
from __future__ import annotations

from pathlib import Path
import json
import math
import os
import random
import hashlib
import datetime as _dt

ROOT = Path('/Users/jtr/_JTR23_/COSMO/runtime/outputs/execution')
OUTDIR = ROOT / 'outputs'
README_PATH = OUTDIR / 'README.md'
MANIFEST_PATH = OUTDIR / 'manifest.json'
RESULTS_PATH = OUTDIR / 'results.json'
FIGURE_PATH = OUTDIR / 'figure.png'

MANIFEST_SCHEMA_VERSION = '1.0'
ARTIFACT_SCHEMA_VERSION = '1.0'
RESULTS_SCHEMA_VERSION = '1.0'

def _utc_now_iso() -> str:
    return _dt.datetime.now(tz=_dt.timezone.utc).isoformat().replace('+00:00', 'Z')

def _sha256_file(p: Path) -> str:
    h = hashlib.sha256()
    with p.open('rb') as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b''):
            h.update(chunk)
    return h.hexdigest()

def _write_readme() -> None:
    OUTDIR.mkdir(parents=True, exist_ok=True)
    text = (
        "# Outputs Artifact Rules\n\n"
        "This directory contains machine- and human-consumable artifacts produced by demo runs.\n\n"
        "## Naming + Locations\n"
        "- `results.json`: most recent end-to-end run results (JSON).\n"
        "- `figure.png`: plot generated by the most recent run.\n"
        "- `manifest.json`: machine-readable list of current artifacts + metadata.\n\n"
        "## Schema + Versioning\n"
        "- `manifest.json` has `manifest_schema_version` and each artifact has `artifact_schema_version`.\n"
        "- `results.json` has `results_schema_version`.\n\n"
        "## Overwrite / Retention Policy\n"
        "- `results.json` and `figure.png` are overwritten on each run (single 'latest' snapshot).\n"
        "- `manifest.json` is updated on each run to match current files and hashes.\n"
        "- No automatic retention; if history is desired, copy artifacts elsewhere before re-running.\n"
    )
    README_PATH.write_text(text, encoding='utf-8')

def _generate_results_and_figure() -> dict:
    seed = int(os.environ.get('E2E_SEED', str(random.randrange(1_000_000_000))))
    rng = random.Random(seed)
    n = int(os.environ.get('E2E_N', '200'))
    xs = [i * (2 * math.pi) / (n - 1) for i in range(n)]
    noise = float(os.environ.get('E2E_NOISE', '0.15'))
    ys = [math.sin(x) + rng.gauss(0.0, noise) for x in xs]
    mean_y = sum(ys) / len(ys)
    rms = math.sqrt(sum((y - math.sin(x)) ** 2 for x, y in zip(xs, ys)) / len(ys))
    results = {
        "results_schema_version": RESULTS_SCHEMA_VERSION,
        "run_id": f"e2e_{_utc_now_iso()}",
        "created_at_utc": _utc_now_iso(),
        "seed": seed,
        "n": n,
        "noise_std": noise,
        "metrics": {"mean_y": mean_y, "rms_error_vs_sin": rms},
        "series_preview": {
            "x0": xs[0], "x_last": xs[-1],
            "y_first5": ys[:5], "y_last5": ys[-5:],
        },
    }
    OUTDIR.mkdir(parents=True, exist_ok=True)
    RESULTS_PATH.write_text(json.dumps(results, indent=2, sort_keys=True) + "\n", encoding='utf-8')

    fig_written = False
    try:
        import matplotlib
        matplotlib.use('Agg')
        import matplotlib.pyplot as plt
        plt.figure(figsize=(8, 4.5), dpi=150)
        plt.plot(xs, [math.sin(x) for x in xs], label='sin(x)', linewidth=2)
        plt.scatter(xs, ys, s=8, alpha=0.6, label='noisy samples')
        plt.title('End-to-end demo: noisy sin samples')
        plt.xlabel('x')
        plt.ylabel('y')
        plt.grid(True, alpha=0.25)
        plt.legend()
        plt.tight_layout()
        plt.savefig(FIGURE_PATH)
        plt.close()
        fig_written = True
    except Exception:
        fig_written = False

    if not fig_written:
        try:
            from PIL import Image, ImageDraw
            w, h = 1200, 675
            img = Image.new('RGB', (w, h), (255, 255, 255))
            draw = ImageDraw.Draw(img)
            draw.rectangle([40, 40, w - 40, h - 40], outline=(0, 0, 0), width=3)
            draw.text((60, 60), "End-to-end demo figure (fallback)", fill=(0, 0, 0))
            def _tx(x): return 60 + int((w - 120) * (x - xs[0]) / (xs[-1] - xs[0]))
            def _ty(y): return h - 60 - int((h - 120) * (y + 1.5) / 3.0)
            pts = [(_tx(x), _ty(y)) for x, y in zip(xs, ys)]
            for i in range(1, len(pts)):
                draw.line([pts[i - 1], pts[i]], fill=(30, 80, 200), width=2)
            img.save(FIGURE_PATH, format='PNG')
        except Exception as e:
            raise RuntimeError("Failed to generate figure.png (matplotlib and PIL unavailable)") from e

    return results

def _load_manifest() -> dict:
    if MANIFEST_PATH.exists():
        try:
            return json.loads(MANIFEST_PATH.read_text(encoding='utf-8'))
        except Exception:
            return {}
    return {}

def _artifact_entry(path: Path, kind: str, schema_version: str, desc: str) -> dict:
    st = path.stat()
    return {
        "artifact_schema_version": schema_version,
        "path": str(path.relative_to(ROOT)).replace('\\', '/'),
        "kind": kind,
        "description": desc,
        "bytes": int(st.st_size),
        "sha256": _sha256_file(path),
        "modified_at_utc": _dt.datetime.fromtimestamp(st.st_mtime, tz=_dt.timezone.utc).isoformat().replace('+00:00', 'Z'),
    }

def _update_manifest(latest_results: dict) -> None:
    m = _load_manifest()
    m["manifest_schema_version"] = MANIFEST_SCHEMA_VERSION
    m["project_root"] = str(ROOT).replace('\\', '/')
    m["updated_at_utc"] = _utc_now_iso()
    m["latest_run"] = {
        "run_id": latest_results.get("run_id"),
        "created_at_utc": latest_results.get("created_at_utc"),
        "results_path": str(RESULTS_PATH.relative_to(ROOT)).replace('\\', '/'),
        "figure_path": str(FIGURE_PATH.relative_to(ROOT)).replace('\\', '/'),
    }
    artifacts = [
        _artifact_entry(README_PATH, "documentation", ARTIFACT_SCHEMA_VERSION, "Artifact rules and policies for outputs/."),
        _artifact_entry(RESULTS_PATH, "results", ARTIFACT_SCHEMA_VERSION, "Most recent end-to-end run results."),
        _artifact_entry(FIGURE_PATH, "figure", ARTIFACT_SCHEMA_VERSION, "Figure generated by most recent end-to-end run."),
    ]
    m["artifacts"] = artifacts
    MANIFEST_PATH.write_text(json.dumps(m, indent=2, sort_keys=True) + "\n", encoding='utf-8')

def main() -> int:
    _write_readme()
    results = _generate_results_and_figure()
    _update_manifest(results)
    print("OK: wrote outputs/results.json, outputs/figure.png and updated outputs/manifest.json")
    return 0

if __name__ == '__main__':
    raise SystemExit(main())
