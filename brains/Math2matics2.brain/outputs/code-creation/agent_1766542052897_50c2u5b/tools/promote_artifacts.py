#!/usr/bin/env python3
"""Promote agent-generated artifacts into canonical /outputs.

Discovers likely artifact files under agent-specific directories (e.g. agent_*/),
copies them into outputs/ with collision-safe names, and (re)generates
outputs/index.md linking to all promoted files.
"""

from __future__ import annotations

import argparse
import shutil
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Optional, Tuple
@dataclass(frozen=True)
class Rules:
    agent_dir_prefixes: Tuple[str, ...] = ("agent_",)
    allow_exts: Tuple[str, ...] = (".md", ".txt", ".json", ".yaml", ".yml")
    allow_names: Tuple[str, ...] = ("README.md", "first_artifact.md", "research_template.md")
    deny_dir_names: Tuple[str, ...] = ("outputs", "tools", "docs", ".git", "__pycache__")
    deny_file_names: Tuple[str, ...] = ("index.md",)
def _is_agent_dir(p: Path, rules: Rules) -> bool:
    return p.is_dir() and any(p.name.startswith(pref) for pref in rules.agent_dir_prefixes)

def discover_files(root: Path, rules: Rules) -> List[Path]:
    files: List[Path] = []
    for child in root.iterdir():
        if not _is_agent_dir(child, rules):
            continue
        for p in child.rglob("*"):
            if any(part in rules.deny_dir_names for part in p.parts):
                continue
            if not p.is_file():
                continue
            if p.name in rules.deny_file_names:
                continue
            if p.suffix.lower() in rules.allow_exts or p.name in rules.allow_names:
                files.append(p)
    return sorted(set(files))
def safe_dest_name(src: Path, root: Path) -> str:
    rel = src.relative_to(root).as_posix()
    rel = rel.replace("/", "__")
    return rel

def ensure_unique(dest_dir: Path, name: str) -> Path:
    base = Path(name).stem
    ext = "".join(Path(name).suffixes) or ""
    candidate = dest_dir / (base + ext)
    i = 2
    while candidate.exists():
        candidate = dest_dir / f"{base}_{i}{ext}"
        i += 1
    return candidate
def promote(files: Iterable[Path], root: Path, out_dir: Path, dry_run: bool = False) -> List[Path]:
    out_dir.mkdir(parents=True, exist_ok=True)
    promoted: List[Path] = []
    for src in files:
        name = safe_dest_name(src, root)
        dest = ensure_unique(out_dir, name)
        promoted.append(dest)
        if dry_run:
            continue
        shutil.copy2(src, dest)
    return promoted

def write_index(out_dir: Path, title: str = "Outputs") -> Path:
    out_dir.mkdir(parents=True, exist_ok=True)
    index = out_dir / "index.md"
    items = sorted([p for p in out_dir.iterdir() if p.is_file() and p.name != "index.md"], key=lambda p: p.name.lower())
    lines: List[str] = [f"# {title}", "", "Autogenerated index of promoted artifacts in this directory.", ""]
    if not items:
        lines += ["(No promoted files found.)", ""]
    else:
        for p in items:
            lines.append(f"- [{p.name}](./{p.name})")
        lines.append("")
    index.write_text("\n".join(lines), encoding="utf-8")
    return index
def main(argv: Optional[List[str]] = None) -> int:
    ap = argparse.ArgumentParser(description="Promote agent artifacts into outputs/ and generate outputs/index.md")
    ap.add_argument("--root", type=Path, default=Path.cwd(), help="Project root (default: cwd)")
    ap.add_argument("--out", type=Path, default=None, help="Outputs directory (default: <root>/outputs)")
    ap.add_argument("--dry-run", action="store_true", help="Discover and plan without copying/writing index")
    ap.add_argument("--quiet", action="store_true", help="Minimize stdout")
    args = ap.parse_args(argv)

    root = args.root.resolve()
    out_dir = (args.out or (root / "outputs")).resolve()
    rules = Rules()

    files = discover_files(root, rules)
    if not args.quiet:
        print(f"DISCOVERED:{len(files)}")
    promoted = promote(files, root, out_dir, dry_run=args.dry_run)
    if not args.dry_run:
        write_index(out_dir)
    if not args.quiet:
        print(f"PROMOTED:{len(promoted)}")
        print(f"OUTPUT_DIR:{out_dir}")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
