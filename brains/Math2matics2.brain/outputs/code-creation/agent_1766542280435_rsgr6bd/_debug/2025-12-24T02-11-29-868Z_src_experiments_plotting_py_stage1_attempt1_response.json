{
  "content": "Implemented `src/experiments/plotting.py` with a compact Matplotlib plotting API (consistent styling, 1D sweep line plots, 2D heatmaps) plus export helpers to save figures as PNG/SVG into an output directory.",
  "reasoning": "",
  "responseId": "resp_0e62f1f0c9a5c73f00694b4c886df08195b529755498678eef",
  "model": "gpt-5.2-2025-12-11",
  "usage": {
    "input_tokens": 5347,
    "input_tokens_details": {
      "cached_tokens": 0
    },
    "output_tokens": 3732,
    "output_tokens_details": {
      "reasoning_tokens": 217
    },
    "total_tokens": 9079
  },
  "hadError": false,
  "errorType": null,
  "webSearchSources": [],
  "citations": [],
  "output": [
    {
      "id": "rs_0e62f1f0c9a5c73f00694b4c8925fc819591fdd5ed139d6918",
      "type": "reasoning",
      "summary": []
    },
    {
      "id": "ci_0e62f1f0c9a5c73f00694b4c8bd6888195a34722829612ad31",
      "type": "code_interpreter_call",
      "status": "completed",
      "code": "from pathlib import Path\nimport json, textwrap, os, sys\ntarget_path = Path('/mnt/data').joinpath('src/experiments/plotting.py')\ntarget_path.parent.mkdir(parents=True, exist_ok=True)\n\nchunks = []\nchunks.append(r\"\"\"\n\"\"\"Matplotlib plotting utilities for experiment sweep results.\n\nThis module provides a small, consistent plotting API used by the notebook and\nthe sweep harness. It focuses on (1) stable styling, (2) simple helpers to plot\ncommon sweep outputs, and (3) exporting figures as PNG/SVG.\n\"\"\"\n\"\"\".strip())\n\nchunks.append(r\"\"\"\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Iterable, Mapping, Optional, Sequence, Tuple, Union\n\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\"\"\".strip())\n\nchunks.append(r\"\"\"\ntry:  # optional dependency; plotting functions accept dict/ndarray too\n    import pandas as pd  # type: ignore\nexcept Exception:  # pragma: no cover\n    pd = None  # type: ignore\n\"\"\".strip())\n\nchunks.append(r\"\"\"\n@dataclass(frozen=True)\nclass PlotStyle:\n    \"\"\"Centralized Matplotlib style settings.\"\"\"\n    fontsize: int = 11\n    dpi: int = 180\n    grid: bool = True\n    figsize: Tuple[float, float] = (6.0, 3.6)\n\n    def apply(self) -> None:\n        mpl.rcParams.update(\n            {\n                \"figure.dpi\": self.dpi,\n                \"savefig.dpi\": self.dpi,\n                \"font.size\": self.fontsize,\n                \"axes.grid\": self.grid,\n                \"axes.spines.top\": False,\n                \"axes.spines.right\": False,\n                \"axes.titlesize\": self.fontsize + 1,\n                \"axes.labelsize\": self.fontsize,\n                \"legend.fontsize\": self.fontsize - 1,\n                \"xtick.labelsize\": self.fontsize - 1,\n                \"ytick.labelsize\": self.fontsize - 1,\n                \"lines.linewidth\": 2.0,\n                \"grid.alpha\": 0.25,\n            }\n        )\n\"\"\".strip())\n\nchunks.append(r\"\"\"\nDEFAULT_STYLE = PlotStyle()\n\n\ndef ensure_dir(path: Union[str, Path]) -> Path:\n    p = Path(path)\n    p.mkdir(parents=True, exist_ok=True)\n    return p\n\n\ndef save_figure(\n    fig: mpl.figure.Figure,\n    outdir: Union[str, Path],\n    stem: str,\n    formats: Sequence[str] = (\"png\", \"svg\"),\n    dpi: Optional[int] = None,\n    transparent: bool = False,\n) -> Mapping[str, Path]:\n    \"\"\"Save figure to multiple formats and return written paths.\"\"\"\n    outdir = ensure_dir(outdir)\n    paths = {}\n    for ext in formats:\n        p = outdir / f\"{stem}.{ext.lstrip('.')}\"\n        fig.savefig(p, bbox_inches=\"tight\", dpi=dpi or DEFAULT_STYLE.dpi, transparent=transparent)\n        paths[ext] = p\n    return paths\n\"\"\".strip())\n\nchunks.append(r\"\"\"\ndef _as_array(x):\n    if pd is not None and isinstance(x, pd.Series):\n        return x.to_numpy()\n    return np.asarray(x)\n\n\ndef _get_column(data, key: str):\n    if pd is not None and isinstance(data, pd.DataFrame):\n        return data[key]\n    if isinstance(data, Mapping):\n        return data[key]\n    raise TypeError(\"data must be a pandas.DataFrame or a mapping of arrays\")\n\"\"\".strip())\n\nchunks.append(r\"\"\"\ndef plot_sweep_lines(\n    data,\n    x: str,\n    y: str,\n    group: Optional[str] = None,\n    *,\n    title: Optional[str] = None,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    ax: Optional[mpl.axes.Axes] = None,\n    style: PlotStyle = DEFAULT_STYLE,\n    legend: bool = True,\n) -> mpl.axes.Axes:\n    \"\"\"Line plot for a 1D sweep; optionally grouped by another parameter.\"\"\"\n    style.apply()\n    if ax is None:\n        _, ax = plt.subplots(figsize=style.figsize)\n\n    xvals = _as_array(_get_column(data, x))\n    if group is None:\n        ax.plot(xvals, _as_array(_get_column(data, y)), label=y)\n    else:\n        g = _get_column(data, group)\n        if pd is not None and isinstance(data, pd.DataFrame):\n            for gv, df_g in data.groupby(group):\n                ax.plot(_as_array(df_g[x]), _as_array(df_g[y]), label=f\"{group}={gv}\")\n        else:\n            for gv in np.unique(_as_array(g)):\n                m = _as_array(g) == gv\n                ax.plot(xvals[m], _as_array(_get_column(data, y))[m], label=f\"{group}={gv}\")\n\n    ax.set_title(title or f\"{y} vs {x}\")\n    ax.set_xlabel(xlabel or x)\n    ax.set_ylabel(ylabel or y)\n    if legend:\n        ax.legend(frameon=False)\n    return ax\n\"\"\".strip())\n\nchunks.append(r\"\"\"\ndef plot_heatmap(\n    data,\n    x: str,\n    y: str,\n    z: str,\n    *,\n    title: Optional[str] = None,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    cmap: str = \"viridis\",\n    ax: Optional[mpl.axes.Axes] = None,\n    style: PlotStyle = DEFAULT_STYLE,\n    colorbar: bool = True,\n) -> mpl.axes.Axes:\n    \"\"\"Heatmap for a 2D sweep stored in long format (x, y, z columns).\"\"\"\n    style.apply()\n    if ax is None:\n        _, ax = plt.subplots(figsize=style.figsize)\n\n    xs = np.unique(_as_array(_get_column(data, x)))\n    ys = np.unique(_as_array(_get_column(data, y)))\n    Z = np.full((len(ys), len(xs)), np.nan, dtype=float)\n\n    xv = _as_array(_get_column(data, x))\n    yv = _as_array(_get_column(data, y))\n    zv = _as_array(_get_column(data, z)).astype(float)\n\n    x_index = {v: i for i, v in enumerate(xs)}\n    y_index = {v: i for i, v in enumerate(ys)}\n    for xi, yi, zi in zip(xv, yv, zv):\n        Z[y_index[yi], x_index[xi]] = zi\n\n    im = ax.imshow(\n        Z,\n        origin=\"lower\",\n        aspect=\"auto\",\n        cmap=cmap,\n        extent=(xs.min(), xs.max(), ys.min(), ys.max()),\n    )\n    ax.set_title(title or f\"{z} heatmap\")\n    ax.set_xlabel(xlabel or x)\n    ax.set_ylabel(ylabel or y)\n    if colorbar:\n        plt.colorbar(im, ax=ax, label=z, fraction=0.046, pad=0.04)\n    return ax\n\"\"\".strip())\n\nchunks.append(r\"\"\"\ndef finalize_and_save(\n    ax: mpl.axes.Axes,\n    outdir: Union[str, Path],\n    stem: str,\n    *,\n    formats: Sequence[str] = (\"png\", \"svg\"),\n    close: bool = True,\n) -> Mapping[str, Path]:\n    \"\"\"Convenience wrapper: layout, save figure, optionally close.\"\"\"\n    fig = ax.figure\n    fig.tight_layout()\n    paths = save_figure(fig, outdir, stem, formats=formats)\n    if close:\n        plt.close(fig)\n    return paths\n\"\"\".strip())\n\nfinal_text = '\\n\\n'.join(block.strip('\\n') for block in chunks).strip() + '\\n'\ntarget_path.write_text(final_text, encoding='utf-8')\nprint('FILE_WRITTEN:src/experiments/plotting.py')\nprint('DIR_STATE:' + json.dumps(sorted(str(p.relative_to(Path(\"/mnt/data\"))) for p in target_path.parent.glob('*') if p.is_file())))\n",
      "container_id": "cntr_694b4bd0381081909cae03b5047a4b910a942f49460a0d3d",
      "outputs": []
    },
    {
      "id": "rs_0e62f1f0c9a5c73f00694b4c9bcb2c8195a1a8bf33e261ba7a",
      "type": "reasoning",
      "summary": []
    },
    {
      "id": "ci_0e62f1f0c9a5c73f00694b4c9ca46c819597fb0c2563d220a6",
      "type": "code_interpreter_call",
      "status": "completed",
      "code": "from pathlib import Path\nimport json\ntarget_path = Path('/mnt/data').joinpath('src/experiments/plotting.py')\ntarget_path.parent.mkdir(parents=True, exist_ok=True)\n\nchunks = []\n\nchunks.append(\"\"\"\\\"\\\"\\\"Matplotlib plotting utilities for experiment sweep results.\n\nProvides:\n- Consistent styling via :class:`PlotStyle`\n- Common plots for sweep results (line plots and 2D heatmaps)\n- Export helpers to save figures as PNG/SVG\n\nFunctions accept either a pandas.DataFrame (preferred) or a mapping of arrays.\n\\\"\\\"\\\"\n\"\"\".strip())\n\nchunks.append(\"\"\"\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Mapping, Optional, Sequence, Tuple, Union\n\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\ntry:  # optional dependency\n    import pandas as pd  # type: ignore\nexcept Exception:  # pragma: no cover\n    pd = None  # type: ignore\n\"\"\".strip())\n\nchunks.append(\"\"\"\n@dataclass(frozen=True)\nclass PlotStyle:\n    fontsize: int = 11\n    dpi: int = 180\n    grid: bool = True\n    figsize: Tuple[float, float] = (6.0, 3.6)\n\n    def apply(self) -> None:\n        mpl.rcParams.update(\n            {\n                \"figure.dpi\": self.dpi,\n                \"savefig.dpi\": self.dpi,\n                \"font.size\": self.fontsize,\n                \"axes.grid\": self.grid,\n                \"axes.spines.top\": False,\n                \"axes.spines.right\": False,\n                \"axes.titlesize\": self.fontsize + 1,\n                \"axes.labelsize\": self.fontsize,\n                \"legend.fontsize\": self.fontsize - 1,\n                \"xtick.labelsize\": self.fontsize - 1,\n                \"ytick.labelsize\": self.fontsize - 1,\n                \"lines.linewidth\": 2.0,\n                \"grid.alpha\": 0.25,\n            }\n        )\n\n\nDEFAULT_STYLE = PlotStyle()\n\"\"\".strip())\n\nchunks.append(\"\"\"\ndef ensure_dir(path: Union[str, Path]) -> Path:\n    p = Path(path)\n    p.mkdir(parents=True, exist_ok=True)\n    return p\n\n\ndef save_figure(\n    fig: mpl.figure.Figure,\n    outdir: Union[str, Path],\n    stem: str,\n    formats: Sequence[str] = (\"png\", \"svg\"),\n    dpi: Optional[int] = None,\n    transparent: bool = False,\n) -> Mapping[str, Path]:\n    \\\"\\\"\\\"Save figure to multiple formats and return written paths.\\\"\\\"\\\"\n    outdir = ensure_dir(outdir)\n    paths: dict[str, Path] = {}\n    for ext in formats:\n        ext = ext.lstrip(\".\")\n        p = outdir / f\"{stem}.{ext}\"\n        fig.savefig(p, bbox_inches=\"tight\", dpi=dpi or DEFAULT_STYLE.dpi, transparent=transparent)\n        paths[ext] = p\n    return paths\n\"\"\".strip())\n\nchunks.append(\"\"\"\ndef _as_array(x):\n    if pd is not None and isinstance(x, pd.Series):\n        return x.to_numpy()\n    return np.asarray(x)\n\n\ndef _get_column(data, key: str):\n    if pd is not None and isinstance(data, pd.DataFrame):\n        return data[key]\n    if isinstance(data, Mapping):\n        return data[key]\n    raise TypeError(\"data must be a pandas.DataFrame or a mapping of arrays\")\n\"\"\".strip())\n\nchunks.append(\"\"\"\ndef plot_sweep_lines(\n    data,\n    x: str,\n    y: str,\n    group: Optional[str] = None,\n    *,\n    title: Optional[str] = None,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    ax: Optional[mpl.axes.Axes] = None,\n    style: PlotStyle = DEFAULT_STYLE,\n    legend: bool = True,\n) -> mpl.axes.Axes:\n    \\\"\\\"\\\"Line plot for a 1D sweep; optionally grouped by another parameter.\\\"\\\"\\\"\n    style.apply()\n    if ax is None:\n        _, ax = plt.subplots(figsize=style.figsize)\n\n    if group is None:\n        ax.plot(_as_array(_get_column(data, x)), _as_array(_get_column(data, y)), label=y)\n    else:\n        if pd is not None and isinstance(data, pd.DataFrame):\n            for gv, df_g in data.groupby(group):\n                ax.plot(_as_array(df_g[x]), _as_array(df_g[y]), label=f\"{group}={gv}\")\n        else:\n            g = _as_array(_get_column(data, group))\n            xv = _as_array(_get_column(data, x))\n            yv = _as_array(_get_column(data, y))\n            for gv in np.unique(g):\n                m = g == gv\n                ax.plot(xv[m], yv[m], label=f\"{group}={gv}\")\n\n    ax.set_title(title or f\"{y} vs {x}\")\n    ax.set_xlabel(xlabel or x)\n    ax.set_ylabel(ylabel or y)\n    if legend:\n        ax.legend(frameon=False)\n    return ax\n\"\"\".strip())\n\nchunks.append(\"\"\"\ndef plot_heatmap(\n    data,\n    x: str,\n    y: str,\n    z: str,\n    *,\n    title: Optional[str] = None,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    cmap: str = \"viridis\",\n    ax: Optional[mpl.axes.Axes] = None,\n    style: PlotStyle = DEFAULT_STYLE,\n    colorbar: bool = True,\n) -> mpl.axes.Axes:\n    \\\"\\\"\\\"Heatmap for a 2D sweep stored in long format (x, y, z columns).\\\"\\\"\\\"\n    style.apply()\n    if ax is None:\n        _, ax = plt.subplots(figsize=style.figsize)\n\n    xs = np.unique(_as_array(_get_column(data, x)))\n    ys = np.unique(_as_array(_get_column(data, y)))\n    Z = np.full((len(ys), len(xs)), np.nan, dtype=float)\n\n    xv = _as_array(_get_column(data, x))\n    yv = _as_array(_get_column(data, y))\n    zv = _as_array(_get_column(data, z)).astype(float)\n\n    x_index = {v: i for i, v in enumerate(xs)}\n    y_index = {v: i for i, v in enumerate(ys)}\n    for xi, yi, zi in zip(xv, yv, zv):\n        Z[y_index[yi], x_index[xi]] = zi\n\n    im = ax.imshow(\n        Z,\n        origin=\"lower\",\n        aspect=\"auto\",\n        cmap=cmap,\n        extent=(float(xs.min()), float(xs.max()), float(ys.min()), float(ys.max())),\n    )\n    ax.set_title(title or f\"{z} heatmap\")\n    ax.set_xlabel(xlabel or x)\n    ax.set_ylabel(ylabel or y)\n    if colorbar:\n        plt.colorbar(im, ax=ax, label=z, fraction=0.046, pad=0.04)\n    return ax\n\"\"\".strip())\n\nchunks.append(\"\"\"\ndef finalize_and_save(\n    ax: mpl.axes.Axes,\n    outdir: Union[str, Path],\n    stem: str,\n    *,\n    formats: Sequence[str] = (\"png\", \"svg\"),\n    close: bool = True,\n) -> Mapping[str, Path]:\n    \\\"\\\"\\\"Convenience wrapper: layout, save figure, optionally close.\\\"\\\"\\\"\n    fig = ax.figure\n    fig.tight_layout()\n    paths = save_figure(fig, outdir, stem, formats=formats)\n    if close:\n        plt.close(fig)\n    return paths\n\"\"\".strip())\n\nfinal_text = '\\n\\n'.join(block.strip('\\n') for block in chunks).strip() + '\\n'\ntarget_path.write_text(final_text, encoding='utf-8')\nprint('FILE_WRITTEN:src/experiments/plotting.py')\nprint('DIR_STATE:' + json.dumps(sorted(str(p.relative_to(Path(\"/mnt/data\"))) for p in target_path.parent.glob('*') if p.is_file())))\n",
      "container_id": "cntr_694b4bd0381081909cae03b5047a4b910a942f49460a0d3d",
      "outputs": [
        {
          "type": "logs",
          "logs": "FILE_WRITTEN:src/experiments/plotting.py\nDIR_STATE:[\"src/experiments/__init__.py\", \"src/experiments/numeric.py\", \"src/experiments/plotting.py\", \"src/experiments/sweep.py\", \"src/experiments/symbolic.py\"]\n"
        }
      ]
    },
    {
      "id": "msg_0e62f1f0c9a5c73f00694b4ca69a388195a651fa6238153ced",
      "type": "message",
      "status": "completed",
      "content": [
        {
          "type": "output_text",
          "annotations": [],
          "logprobs": [],
          "text": "Implemented `src/experiments/plotting.py` with a compact Matplotlib plotting API (consistent styling, 1D sweep line plots, 2D heatmaps) plus export helpers to save figures as PNG/SVG into an output directory."
        }
      ],
      "role": "assistant"
    }
  ],
  "codeResults": []
}