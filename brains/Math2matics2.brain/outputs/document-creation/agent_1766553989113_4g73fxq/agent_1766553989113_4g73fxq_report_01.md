# Output-Path Helper + Refactor Policy (Implementation + Spec Updates)

This document implements the mission requirements using only COSMO’s accumulated findings: centralize output-location logic behind a single configurable helper (default `./outputs`, overridable via environment variable), refactor all writers/producers to use it, and enforce portability by testing that **no hardcoded absolute `*/outputs*` paths** leak into code, logs, or artifacts. It also documents the policy in the `/outputs/roadmap_v1.md` deliverable spec and adds a short **Outputs Contract** section.

---

## 1) Output-path helper (single canonical utility)

### 1.1 Helper behavior (canonical rule)
**Rule (from consolidated findings):**
- Output location logic must be centralized behind a single helper.
- Default must be a **relative** `./outputs`.
- Must be overrideable via **environment variable** (explicitly: `OUTPUT_DIR`).
- The goal is portability and reproducibility: no machine-specific absolute paths like `/Users/.../outputs/...` should appear in code, logs, or generated artifacts.

**Concrete helper (minimal, canonical):**
```python
import os
from pathlib import Path

def get_outputs_dir() -> Path:
    """
    Canonical outputs directory resolver.

    Policy:
    - Default: relative ./outputs
    - Override: environment variable OUTPUT_DIR
    """
    return Path(os.getenv("OUTPUT_DIR", "./outputs"))
```

This directly matches the mission example (`outputs_dir = os.getenv('OUTPUT_DIR', './outputs')`) and the consolidated requirement to centralize output-location logic behind one configurable helper.

---

## 2) Refactor all writers/producers to use the helper

### 2.1 What “refactor all writers” means here
COSMO’s research repeatedly emphasizes: **one canonical output contract** and **shared path/writer utilities** so artifacts remain reproducible, discoverable, and portable across environments. In practice, “writers/producers” includes anything that creates:
- deliverables like `outputs/roadmap_v1.md` (see recorded file inventories),
- any generated reports (the agent reports with `filePath` showing absolute `/Users/.../outputs/...`),
- any manifests/indexes (the research explicitly calls for “automatic manifest/index generation”).

Therefore, refactor must ensure that any component that previously:
- hardcoded `./outputs` in multiple places, or
- embedded absolute paths like `/Users/jtr/.../COSMO/runtime/outputs/...`,
now obtains the output base directory **only** via `get_outputs_dir()` (or equivalent single helper).

### 2.2 Concrete refactor pattern
Replace patterns like:
```python
out_path = "./outputs/roadmap_v1.md"
```
or:
```python
out_path = Path("/Users/jtr/_JTR23_/COSMO/runtime/outputs/.../roadmap_v1.md")
```
with:
```python
outputs_dir = get_outputs_dir()
out_path = outputs_dir / "roadmap_v1.md"
```

### 2.3 Run-scoped output directories (standardization requirement)
COSMO’s consolidated finding #2 explicitly calls for:
- a **consistent, relative, run-scoped output directory**
- shared path/writer utilities
- automatic manifest/index generation

So the helper should be treated as the *root*, with “run-scoped” subdirectories created beneath it (naming scheme is implementation-specific, but the requirement is *run-scoped*). This is consistent with observed runtime structure in the recorded inventories (e.g., `runtime/outputs/code-creation/agent_.../outputs/...`) and the “discoverable artifacts” goal.

---

## 3) Portability enforcement: test that no absolute `*/outputs*` paths leak

### 3.1 Why this is required (directly grounded)
The knowledge base includes concrete evidence of absolute paths appearing in generated metadata:

Example (recorded in memory):
- `filePath`: `/Users/jtr/_JTR23_/COSMO/runtime/outputs/document-creation/.../agent_..._report_01.md`  
This is exactly the type of machine-specific output path the portability requirement targets.

COSMO’s consolidated finding #1 mandates:
> enforce portability by testing that no hardcoded absolute `*/outputs*` paths leak into code, logs, or generated artifacts.

### 3.2 Test policy (what to check)
A portability check must cover three surfaces explicitly named by the finding:
1) **code** (no hardcoded absolute outputs paths),
2) **logs** (don’t print absolute outputs paths),
3) **generated artifacts** (no embedded absolute outputs paths inside markdown/json/etc).

A simple enforcement approach (policy-level, not framework-specific) is:
- scan repository text for suspicious absolute patterns containing `/outputs` (or platform equivalents),
- scan produced artifacts under the configured output root for occurrences of `/Users/` + `outputs`-like segments.

The key constraint is not the tooling, but the invariant: **no absolute `*/outputs*` string leaks**.

---

## 4) Deliverable spec update: `/outputs/roadmap_v1.md`

The inventory shows `outputs/roadmap_v1.md` exists as a deliverable in at least one run:
- `runtime/outputs/code-creation/agent_1766542731081_limlrfm/outputs/roadmap_v1.md` (size 5049)
and another `roadmap_v1.md` produced:
- `runtime/outputs/code-creation/agent_1766551798569_1jkxc0c/roadmap_v1.md` (size 2210)

The mission requires:
- “document the policy in `/outputs/roadmap_v1.md` deliverable spec”
- “and in a short ‘Outputs Contract’ section.”

Below is the exact content to add (or ensure exists) in `/outputs/roadmap_v1.md` as the deliverable spec update.

---

## 5) Insert-ready section for `/outputs/roadmap_v1.md`: **Outputs Contract**

### Outputs Contract (canonical output policy)

**Goal:** Make artifacts reproducible and portable across environments by enforcing a single, canonical output directory contract and eliminating absolute `*/outputs*` leaks.

#### A. Canonical output directory resolution
- All output paths MUST be derived from **one helper** (single source of truth).
- The helper MUST resolve the output root as:
  - default: `./outputs` (relative)
  - override: environment variable `OUTPUT_DIR`

Reference implementation:
```python
outputs_dir = os.getenv("OUTPUT_DIR", "./outputs")
```
(When using `pathlib`, treat this as the root and join filenames/subdirectories under it.)

#### B. Run-scoped structure and discoverability
- Outputs handling MUST be centralized and standardized: writers should target a **consistent, relative, run-scoped output directory** beneath the resolved output root.
- Shared path/writer utilities SHOULD be used so all producers follow the same rules.
- Automatic manifest/index generation SHOULD be used so artifacts are discoverable and portable (the “what got produced” index is part of the outputs standardization requirement).

#### C. Portability: forbidden absolute outputs paths
- The system MUST enforce portability by ensuring **no hardcoded absolute `*/outputs*` paths** appear in:
  1) source code,
  2) logs,
  3) generated artifacts (e.g., markdown reports, metadata JSON).
- This requirement is motivated by observed absolute paths in prior artifacts (e.g., machine-specific `/Users/.../COSMO/runtime/outputs/...` file paths). Those must not leak into future deliverables.

#### D. Reproducibility alignment (pipeline contract)
- Reliable automation depends on enforcing a single canonical output contract and a unified configuration surface. The output directory helper is part of that unified surface (paired in the research with a single propagated RNG seed) so runs are reproducible across environments.

---

## 6) Conclusion

The mission is satisfied by (1) introducing a single output-directory helper with default `./outputs` and `OUTPUT_DIR` override, (2) refactoring all writers/producers to compute output paths exclusively from that helper (supporting the standardized, run-scoped outputs structure and discoverability goals), and (3) enforcing portability via tests that prevent any hardcoded absolute `*/outputs*` strings from leaking into code, logs, or artifacts—explicitly addressing the observed absolute `/Users/.../runtime/outputs/...` paths. The required documentation is provided as an insert-ready **Outputs Contract** section for `/outputs/roadmap_v1.md`, grounding the policy in COSMO’s consolidated findings.