## `benchmarks_v0_1.md`

# Benchmarks v0.1 — Contract, Observables, Metadata, Formats, Pass/Fail

Date: 2025-12-22  
Scope: v0.1 “benchmark contract” for tool-supported, automatically validated benchmark cases with reproducible computation and clear pass/fail compliance.

This document encodes the v0.1 benchmark contract update described in COSMO’s consolidated findings: each v0.1 task needs **required metadata, a reference algorithm, output invariants, tolerance rules, and canonical test vectors**, supported by **validators and automated tests/CI**.

Repository-aligned tooling and artifacts already reflecting this direction (normative references for implementation alignment):

- JSON Schema for benchmark cases: `outputs/schemas/benchmark.schema.json`
- Example benchmark case: `outputs/examples/benchmark_case_001.json`
- Expected outputs: `outputs/expected/benchmark_case_001.expected.json`
- Python schema/validator tooling: `outputs/src/benchmarks/schema.py`
- CLI wrapper: `outputs/src/benchmarks/cli.py`
- Compute/reference implementation module: `outputs/src/benchmarks/compute.py`
- Tests:
  - `outputs/tests/test_schema_conformance.py`
  - `outputs/tests/test_benchmark_reproducibility.py`
- CI workflow: `.github/workflows/ci.yml`

---

## 1. Contract overview (normative)

A **benchmark case** is a machine-validated JSON document that specifies:

1. **Required metadata** to lock semantics and enable reproducibility.
2. **Benchmark observables** to be computed and checked.
3. **Regulator / truncation** information (required), because results depend on these choices.
4. **Uncertainty model** (required): what is being compared and with what tolerance.
5. **Pass/fail criteria** that are tool-checkable and produce diagnostics.

A v0.1 implementation is compliant if, for each benchmark case:
- the case validates against `schema.json` (provided below), and
- the computed results satisfy every declared check under the declared tolerances.

---

## 2. Benchmark observables (3–5) (normative)

v0.1 defines **four** benchmark observables. These are expressed as named outputs so that cases can require any subset while keeping a common structure.

### O1) RG beta-function value: `beta_lambda`
**Definition:** The beta function for the toy model used in the code artifact `experiments.symbolic_rg_flow`:

\[
\frac{d\lambda}{dt} = -\varepsilon \lambda + a \lambda^2, \quad a = \frac{3}{16\pi^2}, \quad t=\log(\mu/\mu_0)
\]

**Observable value:**  
`beta_lambda = -epsilon * lambda + a * lambda^2` evaluated at the case’s specified parameter values.

**Inputs required in the case:** `epsilon`, `lambda`.

**Output invariants:** Must be a finite number.

---

### O2) Fixed-point coupling: `lambda_star`
**Definition:** Non-trivial fixed point of the one-loop beta function above, i.e. solution of `beta_lambda = 0` with `lambda ≠ 0`:

\[
\lambda_\* = \frac{\varepsilon}{a}
\]

with \( a = \frac{3}{16\pi^2} \).

**Inputs required in the case:** `epsilon`.

**Output invariants:** Must be a finite number.

---

### O3) Integrated RG flow end-point: `lambda_t`
**Definition:** The coupling after integrating the ODE
\[
\frac{d\lambda}{dt} = -\varepsilon \lambda + a \lambda^2
\]
from `t0` to `t1`, with initial value `lambda(t0)=lambda0`.

Because the introspected code describes a “Symbolic + numerical RG flow toy model” that produces reproducible outputs and a “small JSON summary”, this observable is included as the standard “pipeline reproducibility” target for integration.

**Inputs required in the case:** `epsilon`, `lambda0`, `t0`, `t1`, `integrator` settings (see §3.3).

**Output invariants:** Must be a finite number. If the chosen integration would diverge, the case should not be used as a canonical test vector.

---

### O4) Reproducibility digest: `result_digest`
**Definition:** A deterministic digest over the computed outputs and the validated benchmark-case metadata that locks semantics (contract version, model, regulator/truncation, and numeric results) to ensure pipeline reproducibility.

This is included to support the existing pattern in the repository: expected outputs stored under `outputs/expected/*.expected.json` and tested via reproducibility tests (`outputs/tests/test_benchmark_reproducibility.py`).

**Inputs required in the case:** none beyond required metadata + computed results.

**Output invariants:** Must be a string.

---

## 3. Required metadata (normative)

Every benchmark case MUST include the following top-level metadata. These fields are required because they were explicitly identified in the v0.1 “benchmark contract” update as the minimum needed to “lock semantics for validation” and to ensure reproducibility.

### 3.1 Contract identifiers
- `contract_version` (string): benchmark contract format version; required to lock semantics for validation.  
- `task_id` (string): v0.1 task identifier; required.  
- `case_id` (string): unique case identifier; required.  
- `description` (string): human-readable description; required.

### 3.2 Reference algorithm pointer
- `reference` (object; required):
  - `implementation` (string): reference implementation module path; aligned to repo artifact `outputs/src/benchmarks/compute.py` (for generic compute) and the toy RG module described by introspection: `experiments.symbolic_rg_flow`.
  - `notes` (string, optional): clarifies any deterministic choices.

This field exists to satisfy the “reference algorithm” requirement in the v0.1 contract update.

### 3.3 Model + regulator/truncation (required)
Because the mission requires “required metadata (model, regulator/truncation, uncertainties)”, and the v0.1 update requires required metadata sufficient for reproducibility, each case MUST specify:

- `model` (object; required)
  - `name` (string; required). v0.1 canonical name: `"phi4_4_minus_eps_one_loop"`.
  - `parameters` (object; required): includes `epsilon` and, depending on required observables, `lambda`, `lambda0`, `t0`, `t1`.

- `regulator` (object; required)
  - `name` (string; required): free string identifying the regulator choice.
  - `details` (object, optional): additional regulator settings.

- `truncation` (object; required)
  - `name` (string; required): free string identifying truncation.
  - `details` (object, optional): additional truncation settings.

These are required to satisfy the “regulator/truncation” metadata requirement and to prevent ambiguous comparisons across implementations.

### 3.4 Uncertainty / tolerance model (required)
To satisfy the “uncertainties” requirement and to enable a tool to compute pass/fail, each case MUST specify:

- `uncertainties` (object; required)
  - `comparison` (string; required): `"absolute"`, `"relative"`, or `"abs_or_rel"`.
  - `atol` (number; required): absolute tolerance.
  - `rtol` (number; required): relative tolerance.
  - `notes` (string, optional).

This is intentionally explicit so that tolerance rules are not implicit or hidden in code.

---

## 4. File formats and required artifacts (normative)

### 4.1 Benchmark case file (input)
- Format: JSON
- Extension: `.json`
- Validated by: `schema.json` (provided below)

Recommended repository layout (aligned to existing artifacts):
- `outputs/examples/benchmark_case_001.json` (example case)
- Additional cases under `outputs/examples/`

### 4.2 Expected output file (golden)
- Format: JSON
- Extension: `.expected.json`
- Purpose: reproducibility checks (aligned to `outputs/expected/benchmark_case_001.expected.json`)
- Required fields:
  - `case_id`
  - `contract_version`
  - `computed` (object): the expected observable values for the observables declared in the case
  - `result_digest` (string): expected digest

### 4.3 Result file (produced by implementations)
- Format: JSON
- Extension: `.result.json` (recommended)
- Required fields:
  - `case_id`, `contract_version`
  - `computed` (object): computed observables
  - `diagnostics` (object): optional details used by validators/CI
  - `result_digest` (string): computed digest

---

## 5. Pass/Fail criteria (normative)

A benchmark case declares:
- `observables` (array): which observables must be computed
- `checks` (array): what to compare and how

### 5.1 General rule
A case **passes** if and only if:
1. the input case validates against `schema.json`, and
2. for each `check`:
   - the named observable exists in the produced results, and
   - its value satisfies the