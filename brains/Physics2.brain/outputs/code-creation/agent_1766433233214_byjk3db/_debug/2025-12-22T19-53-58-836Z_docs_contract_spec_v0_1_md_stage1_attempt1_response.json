{
  "content": "Wrote `docs/contract_spec_v0_1.md`, defining the required v0.1 Contract section YAML format, mandatory fields, tolerance semantics, canonical test vector rules, invariants, and contributor compliance reporting requirements.",
  "reasoning": "",
  "responseId": "resp_03499625c5925727006949a3bdfbf08197897d23ed85adaf60",
  "model": "gpt-5.2-2025-12-11",
  "usage": {
    "input_tokens": 4082,
    "input_tokens_details": {
      "cached_tokens": 0
    },
    "output_tokens": 2566,
    "output_tokens_details": {
      "reasoning_tokens": 77
    },
    "total_tokens": 6648
  },
  "hadError": false,
  "errorType": null,
  "webSearchSources": [],
  "citations": [],
  "output": [
    {
      "id": "rs_03499625c5925727006949a3becf8c819797ec55677fff7234",
      "type": "reasoning",
      "summary": []
    },
    {
      "id": "ci_03499625c5925727006949a3c0e8f48197a5d1d446e5927070",
      "type": "code_interpreter_call",
      "status": "completed",
      "code": "from pathlib import Path\nimport json\n\ntarget_path = Path('/mnt/data').joinpath('docs/contract_spec_v0_1.md')\ntarget_path.parent.mkdir(parents=True, exist_ok=True)\n\nchunks = []\n\nchunks.append(\"\"\"# COSMO v0.1 Benchmark Contract Spec (Contract section)\n\nThis document defines the standardized **Contract** section that MUST be present for every benchmark in `benchmarks_v0_1.md` and the compliance reporting required for every contributed implementation.\n\n## 1. Contract section placement and shape\nEach benchmark entry MUST contain a top-level subsection named exactly `## Contract` (or `### Contract` if nested under the benchmark heading) containing a single fenced YAML block:\n\n```yaml\ncontract:\n  version: \"v0.1\"\n  benchmark_id: \"...\"\n  title: \"...\"\n  scope: \"...\"\n  io:\n    inputs: [...]\n    outputs: [...]\n  required_metadata: {...}\n  reference_algorithm:\n    kind: \"pseudocode\"  # or \"math\"\n    body: |-\n      ...\n  output_invariants:\n    - id: \"inv_...\"\n      statement: \"...\"\n      severity: \"MUST\"  # MUST|SHOULD\n  tolerance_policy: {...}\n  canonical_test_vector: {...}\n  compliance_reporting: {...}\n```\n\nNormative keywords **MUST/SHOULD/MAY** are used as in RFC 2119.\n\n## 2. Required fields (schema-level requirements)\nAll keys below MUST be present unless explicitly marked MAY.\n\n- `contract.version` MUST equal `\"v0.1\"`.\n- `contract.benchmark_id` MUST match the benchmark identifier used in the document (stable, lowercase, `[a-z0-9_]+`).\n- `contract.title` human-readable name for the benchmark.\n- `contract.scope` one-paragraph description of what is in/out of scope (include exclusions).\n- `contract.io.inputs` list of input descriptors, each:\n  - `name` (string), `type` (string), `units` (string or `null`), `shape` (string), `domain` (string), `required` (bool).\n- `contract.io.outputs` list of output descriptors, each:\n  - `name`, `type`, `units`, `shape`, `range` (string), and `determinism` (`deterministic|stochastic`).\n- `contract.required_metadata` MUST include:\n  - `dataset` (id or `\"none\"`), `dataset_version` (string or `null`)\n  - `license` (string), `citation` (string)\n  - `randomness` (`none|seeded|stochastic`), `required_seed_fields` (list, possibly empty)\n  - `hardware_assumptions` (string, MAY be `\"none\"`)\n  - `dependencies` (list of `{name, version_spec}`), MAY be empty\n- `contract.reference_algorithm` MUST specify the authoritative computation:\n  - `kind`: `\"pseudocode\"` or `\"math\"`.\n  - `body`: minimal but complete description sufficient to reproduce outputs.\n- `contract.output_invariants` list of invariants; each invariant MUST include `id`, `statement`, `severity`.\n- `contract.tolerance_policy` defines pass/fail semantics for numeric comparisons (see §3).\n- `contract.canonical_test_vector` defines a small, deterministic test that every implementation MUST pass (see §4).\n- `contract.compliance_reporting` defines how contributors report compliance (see §5).\"\"\")\n\nchunks.append(\"\"\"## 3. Tolerance policy (comparison semantics)\nImplementations MUST evaluate outputs against the contract using the policy below. The policy is expressed per output field; if absent for a field, `default` applies.\n\n```yaml\ntolerance_policy:\n  default:\n    mode: \"exact\"  # exact|abs|rel|abs_rel|ulps|custom\n    abs: 0.0\n    rel: 0.0\n    ulps: 0\n    nan_equal: false\n    inf_equal: true\n  per_output:\n    output_name:\n      mode: \"abs_rel\"\n      abs: 1e-8\n      rel: 1e-6\n```\n\nModes:\n- `exact`: values MUST be bitwise-equal for scalars; for arrays, elementwise equality.\n- `abs`: pass if `|a-b| <= abs`.\n- `rel`: pass if `|a-b| <= rel*max(|a|,|b|)`.\n- `abs_rel`: pass if `|a-b| <= max(abs, rel*max(|a|,|b|))`.\n- `ulps`: pass if ULP distance <= `ulps` (IEEE-754 floats only).\n- `custom`: allowed only if `reference_algorithm.body` defines the comparator unambiguously.\n\nSpecial values:\n- `nan_equal`: if true, NaN compares equal to NaN; otherwise any NaN yields failure for that element.\n- `inf_equal`: if true, +inf==+inf and -inf==-inf; otherwise any inf yields failure.\n\nAggregation for arrays/tensors:\n- The comparison MUST be elementwise; failure occurs if ANY element fails unless the policy includes\n  `aggregate: \"all\"` (default) or `aggregate: \"fraction\"` with `max_fail_fraction` in `[0,1]`.\n- Shape/dtype mismatches are always failures independent of tolerances.\n\nNon-numeric outputs:\n- MUST be compared with `exact` semantics unless `reference_algorithm` defines a different, deterministic canonicalization.\"\"\")\n\nchunks.append(\"\"\"## 4. Canonical test vector (CTV) rules\nEach benchmark MUST include exactly one `canonical_test_vector` with:\n- `id`: stable id string (e.g., `\"ctv_001\"`).\n- `purpose`: what the vector validates.\n- `inputs`: fully specified inputs (no ellipses; no external files).\n- `expected_outputs`: expected outputs from the reference algorithm.\n- `notes` (MAY): clarifications, edge cases, or numerical caveats.\n- `tolerance_overrides` (MAY): per-output overrides that supersede `tolerance_policy` ONLY for the CTV.\n\nCTV requirements:\n1. Deterministic: if randomness exists, the CTV MUST specify seed fields listed in `required_seed_fields`.\n2. Minimal: small enough to run quickly (seconds) on commodity hardware.\n3. Representative: exercises at least one non-trivial code path (not a degenerate identity case).\n4. Self-contained: any constants used MUST be embedded as literals.\n5. Canonical encoding: numbers in decimal; arrays in JSON-like lists; strings in UTF-8.\n\nIf a benchmark is stochastic by design, the CTV MUST specify either:\n- a fixed seed that makes outputs deterministic, OR\n- a distributional invariant in `output_invariants` plus a tolerance policy that compares summary statistics (must be defined under `custom`).\"\"\")\n\nchunks.append(\"\"\"## 5. Output invariants (required checks)\nInvariants are additional checks beyond direct output matching. Examples:\n- shape and dtype constraints (e.g., “output logits shape == (N,K)”)\n- monotonicity / boundedness (e.g., “all probabilities in [0,1] and sum to 1 within 1e-6”)\n- conservation constraints, symmetry, ordering, or schema constraints\n\nSeverity:\n- `MUST`: failing invariant => benchmark FAIL even if tolerances pass.\n- `SHOULD`: failing invariant => benchmark WARN; does not change pass/fail unless an implementation opts-in to stricter mode.\n\nEvery benchmark MUST include at least:\n- one invariant about output shape/schema, and\n- one invariant about value validity (range, normalization, finiteness, etc.), if applicable.\n\n## 6. Compliance reporting (required for contributors)\nEvery contributed implementation MUST report contract compliance for each benchmark it claims to support.\n\nRequired report fields (machine-readable JSON recommended):\n- `benchmark_id`, `contract_version`\n- `implementation_id` (name/version), `runtime` (language + version), `platform` (OS/CPU/GPU)\n- `result`: `pass|fail|warn`\n- `checks` list, each: `{name, status, details}` where `status` is `pass|fail|warn|skip`\n- `diagnostics` on failure: mismatched outputs with indices, max abs/rel error, invariant failures, seed used, and input hash.\n\nMinimum checks to report:\n1. Contract parsing/validation of required fields.\n2. CTV execution and output comparison using tolerance policy (+ overrides).\n3. Evaluation of all `MUST` invariants (and `SHOULD` if supported).\n\nIf an implementation cannot support a benchmark, it MUST report `skip` with a reason (e.g., missing dependency/hardware).\"\"\")\n\nchunks.append(\"\"\"## 7. Canonical Contract example (compact)\n```yaml\ncontract:\n  version: \"v0.1\"\n  benchmark_id: \"example_bench\"\n  title: \"Example Benchmark\"\n  scope: \"Compute y = a*x + b for scalar x.\"\n  io:\n    inputs:\n      - {name: x, type: float64, units: null, shape: \"()\", domain: \"finite real\", required: true}\n      - {name: a, type: float64, units: null, shape: \"()\", domain: \"finite real\", required: true}\n      - {name: b, type: float64, units: null, shape: \"()\", domain: \"finite real\", required: true}\n    outputs:\n      - {name: y, type: float64, units: null, shape: \"()\", range: \"finite real\", determinism: deterministic}\n  required_metadata:\n    dataset: \"none\"\n    dataset_version: null\n    license: \"CC-BY-4.0\"\n    citation: \"COSMO Benchmarks v0.1\"\n    randomness: \"none\"\n    required_seed_fields: []\n    hardware_assumptions: \"none\"\n    dependencies: []\n  reference_algorithm:\n    kind: \"pseudocode\"\n    body: |-\n      y = a*x + b\n  output_invariants:\n    - {id: inv_shape, statement: \"y is a scalar float64\", severity: MUST}\n    - {id: inv_finite, statement: \"y is finite (not NaN/Inf)\", severity: MUST}\n  tolerance_policy:\n    default: {mode: abs_rel, abs: 0.0, rel: 0.0, ulps: 0, nan_equal: false, inf_equal: true}\n    per_output: {y: {mode: abs_rel, abs: 1e-12, rel: 1e-12}}\n  canonical_test_vector:\n    id: \"ctv_001\"\n    purpose: \"Basic affine mapping.\"\n    inputs: {x: 2.0, a: 3.0, b: 4.0}\n    expected_outputs: {y: 10.0}\n  compliance_reporting:\n    required: true\n    format: \"json\"\n    minimum_fields: [\"benchmark_id\",\"contract_version\",\"implementation_id\",\"result\",\"checks\",\"diagnostics\"]\n```\"\"\")\n\nfinal_text = '\\n'.join(block.strip('\\n') for block in chunks).strip() + '\\n'\ntarget_path.write_text(final_text, encoding='utf-8')\n\nprint('FILE_WRITTEN:docs/contract_spec_v0_1.md')\nprint('DIR_STATE:' + json.dumps(sorted(str(p.relative_to(Path(\"/mnt/data\"))) for p in target_path.parent.glob('*') if p.is_file())))\n",
      "container_id": "cntr_6949a1d5445881908092d2723527a8b207f782e9910e8fd5",
      "outputs": [
        {
          "type": "logs",
          "logs": "FILE_WRITTEN:docs/contract_spec_v0_1.md\nDIR_STATE:[\"docs/contract_spec_v0_1.md\"]\n"
        }
      ]
    },
    {
      "id": "msg_03499625c5925727006949a3f29b288197a490427eba3a18b9",
      "type": "message",
      "status": "completed",
      "content": [
        {
          "type": "output_text",
          "annotations": [],
          "logprobs": [],
          "text": "Wrote `docs/contract_spec_v0_1.md`, defining the required v0.1 Contract section YAML format, mandatory fields, tolerance semantics, canonical test vector rules, invariants, and contributor compliance reporting requirements."
        }
      ],
      "role": "assistant"
    }
  ],
  "codeResults": []
}