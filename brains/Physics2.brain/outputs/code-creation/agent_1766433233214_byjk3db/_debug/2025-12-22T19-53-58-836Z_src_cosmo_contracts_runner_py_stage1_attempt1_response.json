{
  "content": "Implemented `src/cosmo_contracts/runner.py` as a self-contained compliance runner that validates contract structure, executes contributed implementations on canonical test vectors, checks invariants, applies exact/approx tolerance policies, and emits a JSON-serializable per-benchmark pass/fail + diagnostics report (including expected/actual on failures).",
  "reasoning": "",
  "responseId": "resp_000e02c82db0c614006949a262743c81948bafedbfb42d8916",
  "model": "gpt-5.2-2025-12-11",
  "usage": {
    "input_tokens": 4400,
    "input_tokens_details": {
      "cached_tokens": 0
    },
    "output_tokens": 2878,
    "output_tokens_details": {
      "reasoning_tokens": 416
    },
    "total_tokens": 7278
  },
  "hadError": false,
  "errorType": null,
  "webSearchSources": [],
  "citations": [],
  "output": [
    {
      "id": "rs_000e02c82db0c614006949a26341d4819485dfc6d381dcf6e8",
      "type": "reasoning",
      "summary": []
    },
    {
      "id": "ci_000e02c82db0c614006949a26f48cc8194a5399feda607b1f5",
      "type": "code_interpreter_call",
      "status": "completed",
      "code": "from pathlib import Path\nimport json\n\ntarget_path = Path('/mnt/data').joinpath('src/cosmo_contracts/runner.py')\ntarget_path.parent.mkdir(parents=True, exist_ok=True)\n\nchunks = []\n\nchunks.append(\"\"\"\n\\\"\\\"\\\"cosmo_contracts.runner\n\nRuns contributed benchmark implementations against canonical contract test vectors\nand produces a per-contract compliance report (pass/fail + diagnostics).\n\nThis module is intentionally self-contained so it can be used even when only\ncontracts (dicts) and implementations (callables/import paths) are available.\n\\\"\\\"\\\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom importlib import import_module\nfrom typing import Any, Callable, Dict, Iterable, List, Mapping, Optional, Tuple, Union\n\"\"\")\n\nchunks.append(\"\"\"\nNumber = Union[int, float]\n\n\ndef _is_number(x: Any) -> bool:\n    return isinstance(x, (int, float)) and not isinstance(x, bool)\n\n\ndef _iterable(x: Any) -> bool:\n    return isinstance(x, (list, tuple))\n\n\ndef _load_impl(spec: Union[str, Callable[..., Any]]) -> Callable[..., Any]:\n    \\\"\\\"\\\"Load an implementation from a callable or a 'module:attr' string.\\\"\\\"\\\"\n    if callable(spec):\n        return spec\n    if not isinstance(spec, str) or \":\" not in spec:\n        raise TypeError(\"Implementation spec must be callable or 'module:attr' string\")\n    mod, attr = spec.split(\":\", 1)\n    fn = getattr(import_module(mod), attr)\n    if not callable(fn):\n        raise TypeError(f\"Loaded object {spec!r} is not callable\")\n    return fn\n\"\"\")\n\nchunks.append(\"\"\"\ndef _approx_equal(a: Any, b: Any, *, atol: float, rtol: float) -> Tuple[bool, str]:\n    \\\"\\\"\\\"Deep approximate equality with useful diagnostics (no numpy required).\\\"\\\"\\\"\n    if a is b:\n        return True, \"\"\n    if _is_number(a) and _is_number(b):\n        diff = abs(a - b)\n        tol = atol + rtol * abs(b)\n        ok = diff <= tol\n        return ok, f\"abs_diff={diff} tol={tol} a={a} b={b}\" if not ok else \"\"\n    if isinstance(a, str) or isinstance(b, str):\n        ok = a == b\n        return ok, f\\\"a={a!r} b={b!r}\\\" if not ok else \"\"\n    if isinstance(a, Mapping) and isinstance(b, Mapping):\n        if set(a.keys()) != set(b.keys()):\n            return False, f\\\"dict_keys a={sorted(a.keys())} b={sorted(b.keys())}\\\"\n        for k in a:\n            ok, diag = _approx_equal(a[k], b[k], atol=atol, rtol=rtol)\n            if not ok:\n                return False, f\\\"key={k!r}: {diag}\\\"\n        return True, \"\"\n    if _iterable(a) and _iterable(b):\n        if len(a) != len(b):\n            return False, f\\\"len a={len(a)} b={len(b)}\\\"\n        for i, (ai, bi) in enumerate(zip(a, b)):\n            ok, diag = _approx_equal(ai, bi, atol=atol, rtol=rtol)\n            if not ok:\n                return False, f\\\"idx={i}: {diag}\\\"\n        return True, \"\"\n    ok = a == b\n    return ok, f\\\"a={a!r} b={b!r}\\\" if not ok else \"\"\n\"\"\")\n\nchunks.append(\"\"\"\ndef _exact_equal(a: Any, b: Any) -> Tuple[bool, str]:\n    if a is b:\n        return True, \"\"\n    if isinstance(a, Mapping) and isinstance(b, Mapping):\n        if set(a.keys()) != set(b.keys()):\n            return False, f\\\"dict_keys a={sorted(a.keys())} b={sorted(b.keys())}\\\"\n        for k in a:\n            ok, diag = _exact_equal(a[k], b[k])\n            if not ok:\n                return False, f\\\"key={k!r}: {diag}\\\"\n        return True, \"\"\n    if _iterable(a) and _iterable(b):\n        if len(a) != len(b):\n            return False, f\\\"len a={len(a)} b={len(b)}\\\"\n        for i, (ai, bi) in enumerate(zip(a, b)):\n            ok, diag = _exact_equal(ai, bi)\n            if not ok:\n                return False, f\\\"idx={i}: {diag}\\\"\n        return True, \"\"\n    ok = a == b\n    return ok, f\\\"a={a!r} b={b!r}\\\" if not ok else \"\"\n\"\"\")\n\nchunks.append(\"\"\"\ndef validate_contract(contract: Mapping[str, Any]) -> List[str]:\n    \\\"\\\"\\\"Return diagnostics (empty => structurally OK).\\\"\\\"\\\"\n    required = [\"id\", \"metadata\", \"reference\", \"invariants\", \"tolerance\", \"test_vector\"]\n    diags: List[str] = []\n    for k in required:\n        if k not in contract:\n            diags.append(f\\\"missing_section:{k}\\\")\n    meta_req = [\"name\", \"version\"]\n    md = contract.get(\"metadata\") if isinstance(contract.get(\"metadata\"), Mapping) else {}\n    for k in meta_req:\n        if k not in md:\n            diags.append(f\\\"missing_metadata:{k}\\\")\n    tv = contract.get(\"test_vector\")\n    if tv is None or not isinstance(tv, Mapping):\n        diags.append(\"invalid_test_vector\")\n    else:\n        if not any(k in tv for k in (\"args\", \"kwargs\", \"input\")):\n            diags.append(\"test_vector_missing_inputs\")\n        if \"expected\" not in tv:\n            diags.append(\"test_vector_missing_expected\")\n    tol = contract.get(\"tolerance\")\n    if isinstance(tol, Mapping):\n        pol = tol.get(\"policy\", \"exact\")\n        if pol not in (\"exact\", \"approx\"):\n            diags.append(f\\\"invalid_tolerance_policy:{pol}\\\")\n    return diags\n\"\"\")\n\nchunks.append(\"\"\"\ndef _apply_invariants(invariants: Mapping[str, Any], output: Any) -> List[str]:\n    diags: List[str] = []\n    if not isinstance(invariants, Mapping):\n        return diags\n    t = invariants.get(\"output_type\")\n    if t:\n        allowed = tuple(getattr(__builtins__, t, object) for t in ([t] if isinstance(t, str) else t))\n        if allowed and not isinstance(output, allowed):\n            diags.append(f\\\"invariant_output_type_failed: got={type(output).__name__}\\\")\n    keys = invariants.get(\"dict_keys\")\n    if keys is not None:\n        if not isinstance(output, Mapping):\n            diags.append(\"invariant_dict_keys_failed:not_a_dict\")\n        else:\n            missing = [k for k in keys if k not in output]\n            extra = [k for k in output.keys() if k not in set(keys)]\n            if missing:\n                diags.append(f\\\"invariant_dict_missing_keys:{missing}\\\")\n            if extra:\n                diags.append(f\\\"invariant_dict_extra_keys:{sorted(extra)}\\\")\n    length = invariants.get(\"length\")\n    if length is not None:\n        if not _iterable(output):\n            diags.append(\"invariant_length_failed:not_a_sequence\")\n        elif len(output) != int(length):\n            diags.append(f\\\"invariant_length_failed: got={len(output)} expected={int(length)}\\\")\n    return diags\n\"\"\")\n\nchunks.append(\"\"\"\n@dataclass\nclass ComplianceResult:\n    benchmark_id: str\n    passed: bool\n    diagnostics: List[str]\n    expected: Any = None\n    actual: Any = None\n\n\ndef run_contract(contract: Mapping[str, Any], impl: Union[str, Callable[..., Any]]) -> ComplianceResult:\n    bid = str(contract.get(\"id\", \"<unknown>\"))\n    diags = validate_contract(contract)\n    if diags:\n        return ComplianceResult(bid, False, diags)\n\n    fn = _load_impl(impl)\n    tv = contract[\"test_vector\"]\n    args = tv.get(\"args\")\n    kwargs = tv.get(\"kwargs\")\n    if \"input\" in tv and args is None and kwargs is None:\n        inp = tv[\"input\"]\n        args = inp.get(\"args\", []) if isinstance(inp, Mapping) else [inp]\n        kwargs = inp.get(\"kwargs\", {}) if isinstance(inp, Mapping) else {}\n    args = list(args) if args is not None else []\n    kwargs = dict(kwargs) if kwargs is not None else {}\n    expected = tv.get(\"expected\")\n\n    try:\n        actual = fn(*args, **kwargs)\n    except Exception as e:  # noqa: BLE001\n        return ComplianceResult(bid, False, [f\\\"exception:{type(e).__name__}:{e}\\\"], expected=expected)\n\n    diags.extend(_apply_invariants(contract.get(\"invariants\", {}), actual))\n\n    tol = contract.get(\"tolerance\", {}) if isinstance(contract.get(\"tolerance\"), Mapping) else {}\n    policy = tol.get(\"policy\", \"exact\")\n    if policy == \"approx\":\n        atol = float(tol.get(\"atol\", 0.0))\n        rtol = float(tol.get(\"rtol\", 0.0))\n        ok, diag = _approx_equal(actual, expected, atol=atol, rtol=rtol)\n    else:\n        ok, diag = _exact_equal(actual, expected)\n    if not ok:\n        diags.append(f\\\"mismatch:{diag}\\\")\n    passed = ok and not diags\n    return ComplianceResult(bid, passed, diags, expected=expected, actual=actual)\n\"\"\")\n\nchunks.append(\"\"\"\ndef run_compliance(\n    contracts: Iterable[Mapping[str, Any]],\n    implementations: Mapping[str, Union[str, Callable[..., Any]]],\n) -> Dict[str, Any]:\n    \\\"\\\"\\\"Run all contracts against provided implementations.\n\n    Returns a JSON-serializable dict keyed by benchmark id:\n    {id: {passed: bool, diagnostics: [...], expected: ..., actual: ...}}\n    \\\"\\\"\\\"\n    report: Dict[str, Any] = {}\n    for c in contracts:\n        bid = str(c.get(\"id\", \"<unknown>\"))\n        impl = implementations.get(bid)\n        if impl is None:\n            report[bid] = {\"passed\": False, \"diagnostics\": [\"missing_implementation\"]}\n            continue\n        res = run_contract(c, impl)\n        report[bid] = {\n            \"passed\": bool(res.passed),\n            \"diagnostics\": list(res.diagnostics),\n        }\n        if not res.passed:\n            report[bid][\"expected\"] = res.expected\n            report[bid][\"actual\"] = res.actual\n    return report\n\"\"\")\n\nfinal_text = '\\n'.join(block.strip('\\n') for block in chunks).strip() + '\\n'\ntarget_path.write_text(final_text, encoding='utf-8')\n\nprint('FILE_WRITTEN:src/cosmo_contracts/runner.py')\nprint('DIR_STATE:' + json.dumps(sorted(str(p.relative_to(Path(\"/mnt/data\"))) for p in target_path.parent.glob('*') if p.is_file())))\n",
      "container_id": "cntr_6949a1d5445881908092d2723527a8b207f782e9910e8fd5",
      "outputs": [
        {
          "type": "logs",
          "logs": "FILE_WRITTEN:src/cosmo_contracts/runner.py\nDIR_STATE:[\"src/cosmo_contracts/__init__.py\", \"src/cosmo_contracts/contracts.py\", \"src/cosmo_contracts/markdown.py\", \"src/cosmo_contracts/runner.py\", \"src/cosmo_contracts/schema.py\"]\n"
        }
      ]
    },
    {
      "id": "msg_000e02c82db0c614006949a28c7c688194bb3061d31ba27752",
      "type": "message",
      "status": "completed",
      "content": [
        {
          "type": "output_text",
          "annotations": [],
          "logprobs": [],
          "text": "Implemented `src/cosmo_contracts/runner.py` as a self-contained compliance runner that validates contract structure, executes contributed implementations on canonical test vectors, checks invariants, applies exact/approx tolerance policies, and emits a JSON-serializable per-benchmark pass/fail + diagnostics report (including expected/actual on failures)."
        }
      ],
      "role": "assistant"
    }
  ],
  "codeResults": []
}