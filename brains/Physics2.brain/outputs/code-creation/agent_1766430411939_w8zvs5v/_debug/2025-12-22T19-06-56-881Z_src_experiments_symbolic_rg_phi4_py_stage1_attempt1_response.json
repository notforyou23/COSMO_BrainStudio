{
  "content": "Implemented `src/experiments/symbolic_rg_phi4.py`, a self-contained notebook-as-script that symbolically derives one-loop toy φ⁴ beta functions (with LaTeX/text reporting), computes fixed points and linearized eigenvalues, numerically integrates RG flows, and writes a reproducible phase-portrait plot to an `outputs/` directory.",
  "reasoning": "",
  "responseId": "resp_044a23ff59d1638900694997e0dbdc8193b0095f26a81e7808",
  "model": "gpt-5.2-2025-12-11",
  "usage": {
    "input_tokens": 3990,
    "input_tokens_details": {
      "cached_tokens": 0
    },
    "output_tokens": 2428,
    "output_tokens_details": {
      "reasoning_tokens": 346
    },
    "total_tokens": 6418
  },
  "hadError": false,
  "errorType": null,
  "webSearchSources": [],
  "citations": [],
  "output": [
    {
      "id": "rs_044a23ff59d1638900694997e1ac2c819390247ddf8d6887b2",
      "type": "reasoning",
      "summary": []
    },
    {
      "id": "ci_044a23ff59d1638900694997e8d7fc8193aa2ac1ac755384dd",
      "type": "code_interpreter_call",
      "status": "completed",
      "code": "from pathlib import Path\nimport json\n\ntarget_path = Path('/mnt/data').joinpath('src/experiments/symbolic_rg_phi4.py')\ntarget_path.parent.mkdir(parents=True, exist_ok=True)\n\nchunks = [\nr\"\"\"#!/usr/bin/env python3\n\\\"\\\"\\\"Symbolic + toy numerical RG flow for a φ^4-like theory.\n\nWe use a standard one-loop Wilson-Fisher-style beta function model in d=4-ε:\n  β_λ = dλ/dt = -ε λ + 3 λ^2/(16π^2)\n  β_m2 = dm^2/dt = (-2 + λ/(16π^2)) m^2\nwhere t = log(μ/μ0) is RG \"time\" and m^2, λ are dimensionless couplings.\n\nThe script prints LaTeX for the beta functions and fixed points, and saves\na small phase-portrait plot (λ vs m^2) for a few initial conditions.\n\\\"\\\"\\\"\n\nfrom __future__ import annotations\n\nimport argparse\nfrom pathlib import Path\n\nimport numpy as np\nimport sympy as sp\nimport matplotlib.pyplot as plt\n\"\"\",\nr\"\"\"def symbolic_report(eps: float) -> str:\n    lam, m2, pi, eps_s = sp.symbols(\"lambda m^2 pi epsilon\", positive=True, real=True)\n    beta_lam = -eps_s * lam + sp.Rational(3, 1) * lam**2 / (16 * pi**2)\n    beta_m2 = (-2 + lam / (16 * pi**2)) * m2\n\n    # Fixed points: solve β_λ=0 for λ; m^2 is a relevant perturbation at WF.\n    fp_lam = sp.solve(sp.Eq(beta_lam, 0), lam)\n    wf = sp.simplify(fp_lam[1])  # 16 π^2 ε / 3\n    # Linearized eigenvalues at fixed points (λ, m^2) for (β_λ, β_m2)\n    J = sp.Matrix([beta_lam, beta_m2]).jacobian([lam, m2])\n    evals_g = [sp.simplify(ev) for ev in J.subs({lam: 0, m2: 0}).eigenvals().keys()]\n    evals_wf = [sp.simplify(ev) for ev in J.subs({lam: wf, m2: 0}).eigenvals().keys()]\n\n    subs_num = {eps_s: sp.nsimplify(eps)}\n    lines = []\n    lines.append(\"=== Toy φ^4 RG (one-loop, d=4-ε) ===\")\n    lines.append(f\"epsilon = {eps:g}\")\n    lines.append(\"\")\n    lines.append(\"Beta functions (symbolic):\")\n    lines.append(\"  β_λ = \" + sp.latex(beta_lam))\n    lines.append(\"  β_{m^2} = \" + sp.latex(beta_m2))\n    lines.append(\"\")\n    lines.append(\"Fixed points from β_λ=0:\")\n    lines.append(\"  Gaussian: λ*=0\")\n    lines.append(\"  Wilson–Fisher: λ* = \" + sp.latex(wf))\n    lines.append(\"  (numerical) λ* ≈ \" + str(sp.N(wf.subs(subs_num))))\n    lines.append(\"\")\n    lines.append(\"Linearized eigenvalues at (λ*, m^2=0):\")\n    lines.append(\"  Gaussian: \" + \", \".join(map(sp.latex, evals_g)))\n    lines.append(\"  Wilson–Fisher: \" + \", \".join(map(sp.latex, evals_wf)))\n    lines.append(\"  (numerical WF) \" + \", \".join(str(sp.N(ev.subs(subs_num))) for ev in evals_wf))\n    return \"\\n\".join(lines)\n\"\"\",\nr\"\"\"def rg_rhs(eps: float, lam: np.ndarray, m2: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    c = 1.0 / (16.0 * np.pi**2)\n    dlam = -eps * lam + 3.0 * c * lam**2\n    dm2 = (-2.0 + c * lam) * m2\n    return dlam, dm2\n\n\ndef integrate_rg(eps: float, lam0: float, m20: float, dt: float, steps: int) -> tuple[np.ndarray, np.ndarray]:\n    lam = np.empty(steps + 1)\n    m2 = np.empty(steps + 1)\n    lam[0], m2[0] = lam0, m20\n    for i in range(steps):\n        dlam, dm2 = rg_rhs(eps, lam[i], m2[i])\n        lam[i + 1] = lam[i] + dt * dlam\n        m2[i + 1] = m2[i] + dt * dm2\n        # guardrail: keep plot readable if flow runs away\n        if abs(lam[i + 1]) > 200 or abs(m2[i + 1]) > 200:\n            lam[i + 1 :] = lam[i + 1]\n            m2[i + 1 :] = m2[i + 1]\n            break\n    return lam, m2\n\"\"\",\nr\"\"\"def make_plot(eps: float, outdir: Path, steps: int, dt: float, inits: list[tuple[float, float]]) -> Path:\n    outdir.mkdir(parents=True, exist_ok=True)\n    fig, ax = plt.subplots(figsize=(6.2, 4.4), dpi=140)\n\n    # Vector field on a coarse grid\n    lam_grid = np.linspace(0, max(0.5, max(l for l, _ in inits) * 1.4), 18)\n    m2_grid = np.linspace(-1.0, 1.0, 18)\n    L, M = np.meshgrid(lam_grid, m2_grid)\n    dL, dM = rg_rhs(eps, L, M)\n    speed = np.hypot(dL, dM) + 1e-12\n    ax.quiver(L, M, dL / speed, dM / speed, speed, cmap=\"viridis\", alpha=0.65, width=0.003)\n\n    for lam0, m20 in inits:\n        lam, m2 = integrate_rg(eps, lam0, m20, dt, steps)\n        ax.plot(lam, m2, lw=2, label=f\"(λ0={lam0:g}, m0^2={m20:g})\")\n        ax.scatter([lam[0]], [m2[0]], s=18)\n\n    lam_star = 16 * np.pi**2 * eps / 3.0\n    ax.axvline(lam_star, color=\"k\", ls=\"--\", lw=1, alpha=0.6, label=\"λ* (WF)\")\n    ax.set_title(rf\"Toy RG flow in $(\\lambda, m^2)$, $d=4-\\epsilon$, $\\epsilon={eps:g}$\")\n    ax.set_xlabel(r\"$\\lambda$\")\n    ax.set_ylabel(r\"$m^2$\")\n    ax.set_xlim(lam_grid.min(), max(lam_grid.max(), lam_star * 1.05))\n    ax.set_ylim(m2_grid.min(), m2_grid.max())\n    ax.legend(fontsize=7, loc=\"upper right\", frameon=True)\n    ax.grid(True, alpha=0.25)\n\n    outpath = outdir / f\"rg_phi4_flow_eps{eps:g}.png\"\n    fig.tight_layout()\n    fig.savefig(outpath)\n    plt.close(fig)\n    return outpath\n\"\"\",\nr\"\"\"def main() -> None:\n    ap = argparse.ArgumentParser(description=\"Symbolic + toy numerical RG for φ^4 (one-loop).\")\n    ap.add_argument(\"--epsilon\", type=float, default=1.0, help=\"ε in d=4-ε (default: 1 => 3D)\")\n    ap.add_argument(\"--steps\", type=int, default=900)\n    ap.add_argument(\"--dt\", type=float, default=0.01, help=\"Euler step in RG time t\")\n    ap.add_argument(\"--outdir\", type=Path, default=Path(\"outputs\"), help=\"Directory to save plots\")\n    args = ap.parse_args()\n\n    print(symbolic_report(args.epsilon))\n    inits = [(0.2, 0.8), (0.2, -0.8), (1.0, 0.6), (2.0, -0.4), (4.0, 0.2)]\n    outpath = make_plot(args.epsilon, args.outdir, args.steps, args.dt, inits)\n    print(f\"\\nWROTE_PLOT:{outpath.as_posix()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n\"\"\"\n]\n\nfinal_text = '\\n'.join(block.strip('\\n') for block in chunks).strip() + '\\n'\ntarget_path.write_text(final_text, encoding='utf-8')\n\nprint('FILE_WRITTEN:src/experiments/symbolic_rg_phi4.py')\nprint('DIR_STATE:' + json.dumps(sorted(str(p.relative_to(Path(\"/mnt/data\"))) for p in target_path.parent.glob('*') if p.is_file())))\n",
      "container_id": "cntr_694996cf1f0881908fd6ebe4e5dd54140c8f193d7d2aa5f8",
      "outputs": [
        {
          "type": "logs",
          "logs": "FILE_WRITTEN:src/experiments/symbolic_rg_phi4.py\nDIR_STATE:[\"src/experiments/symbolic_rg_phi4.py\", \"src/experiments/toy_ising_emergent_classicality.py\"]\n"
        }
      ]
    },
    {
      "id": "msg_044a23ff59d1638900694998055a908193b39d01060ad81b7b",
      "type": "message",
      "status": "completed",
      "content": [
        {
          "type": "output_text",
          "annotations": [],
          "logprobs": [],
          "text": "Implemented `src/experiments/symbolic_rg_phi4.py`, a self-contained notebook-as-script that symbolically derives one-loop toy φ⁴ beta functions (with LaTeX/text reporting), computes fixed points and linearized eigenvalues, numerically integrates RG flows, and writes a reproducible phase-portrait plot to an `outputs/` directory."
        }
      ],
      "role": "assistant"
    }
  ],
  "codeResults": []
}