{
  "content": "Implemented `src/dgpipe/simulations.py` providing lightweight controlled simulations (finite-size mode truncation, UV cutoff via microscopic spacing, modified dispersion), synthetic noisy datasets for correlators and a two-mode logarithmic-negativity diagnostic, plus unified protocol execution and systematic sweeps for calibration/inference testing.",
  "reasoning": "",
  "responseId": "resp_01103ad26d31d7a1006949b1e4d70c81949775fbbf36638273",
  "model": "gpt-5.2-2025-12-11",
  "usage": {
    "input_tokens": 4841,
    "input_tokens_details": {
      "cached_tokens": 0
    },
    "output_tokens": 3259,
    "output_tokens_details": {
      "reasoning_tokens": 504
    },
    "total_tokens": 8100
  },
  "hadError": false,
  "errorType": null,
  "webSearchSources": [],
  "citations": [],
  "output": [
    {
      "id": "rs_01103ad26d31d7a1006949b1e5847c8194b11ffb0c94264ac3",
      "type": "reasoning",
      "summary": []
    },
    {
      "id": "ci_01103ad26d31d7a1006949b1f3e55c81949981fa1bffd2079d",
      "type": "code_interpreter_call",
      "status": "completed",
      "code": "from pathlib import Path\nimport json, textwrap, os, numpy as np\ntarget_path = Path('/mnt/data').joinpath('src/dgpipe/simulations.py')\ntarget_path.parent.mkdir(parents=True, exist_ok=True)\n\nchunks = []\nchunks.append(\"\"\"\n\\\"\\\"\\\"dgpipe.simulations\n\nControlled numerical + semi-analytical simulators used to quantify finite-size,\ndiscretization, and dispersive systematics for measurement protocols and to\nproduce synthetic datasets for inference tests.\n\nThe models here are intentionally lightweight: a free scalar field in 1D with\nperiodic boundary conditions and a causal-set/discrete-microstructure inspired\nmodified dispersion relation.\n\\\"\\\"\\\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, asdict\nfrom typing import Any, Dict, Iterable, Literal, Mapping, Optional, Tuple\n\nimport numpy as np\n\n\nProtocolName = Literal[\n    \"equal_time_correlator\",\n    \"time_correlator\",\n    \"logneg_two_mode\",\n]\n\"\"\")\n\nchunks.append(\"\"\"\n@dataclass(frozen=True)\nclass DiscreteParams:\n    \\\"\\\"\\\"Parameters encoding discrete microstructure effects.\n\n    alpha, power: control a leading-order dispersive correction\n        omega(k) = sqrt(k^2 + m^2) * (1 + alpha * (a|k|)^power)\n    a: microscopic length/spacing, also sets UV cutoff k_max ~ pi/a.\n    \\\"\\\"\\\"\n\n    a: float = 1.0\n    alpha: float = 0.0\n    power: int = 2\n    m: float = 0.0\n\n\n@dataclass(frozen=True)\nclass SimConfig:\n    \\\"\\\"\\\"Finite-size/discretization controls.\\\"\\\"\\\"\n\n    L: float = 64.0          # system length\n    N_modes: int = 256       # number of Fourier modes (finite-size)\n    k_cut: Optional[float] = None  # optional additional cutoff (<= pi/a)\n\n\n@dataclass(frozen=True)\nclass NoiseModel:\n    \\\"\\\"\\\"Simple i.i.d. Gaussian measurement noise.\\\"\\\"\\\"\n\n    sigma: float = 1e-3\n    seed: int = 0\n\"\"\")\n\nchunks.append(\"\"\"\ndef _k_grid(cfg: SimConfig, dp: DiscreteParams) -> np.ndarray:\n    n = np.arange(-cfg.N_modes // 2, cfg.N_modes // 2, dtype=float)\n    k = 2.0 * np.pi * n / cfg.L\n    k_max = np.pi / max(dp.a, 1e-12)\n    if cfg.k_cut is not None:\n        k_max = min(k_max, float(cfg.k_cut))\n    return k[np.abs(k) <= k_max]\n\n\ndef _omega(k: np.ndarray, dp: DiscreteParams) -> np.ndarray:\n    w0 = np.sqrt(k * k + dp.m * dp.m)\n    corr = 1.0 + dp.alpha * np.power(dp.a * np.abs(k), dp.power)\n    return w0 * corr\n\n\ndef _wightman(t: float, x: np.ndarray, cfg: SimConfig, dp: DiscreteParams) -> np.ndarray:\n    \\\"\\\"\\\"Discrete-mode approximation to <phi(t,x) phi(0,0)> in vacuum.\\\"\\\"\\\"\n    k = _k_grid(cfg, dp)\n    w = _omega(k, dp)\n    phase = np.outer(k, x) - (w[:, None] * t)\n    # (1/L) sum_k (e^{i(kx - wt)})/(2w)\n    return (np.cos(phase) / (2.0 * w[:, None])).sum(axis=0) / cfg.L\n\n\ndef _pi_pi(t: float, x: np.ndarray, cfg: SimConfig, dp: DiscreteParams) -> np.ndarray:\n    \\\"\\\"\\\"Discrete-mode approximation to <pi(t,x) pi(0,0)> with pi=dot(phi).\\\"\\\"\\\"\n    k = _k_grid(cfg, dp)\n    w = _omega(k, dp)\n    phase = np.outer(k, x) - (w[:, None] * t)\n    return ((w[:, None] * np.cos(phase)) / 2.0).sum(axis=0) / cfg.L\n\"\"\")\n\nchunks.append(\"\"\"\ndef _add_noise(y: np.ndarray, noise: NoiseModel) -> Tuple[np.ndarray, np.ndarray]:\n    rng = np.random.default_rng(noise.seed)\n    eps = rng.normal(0.0, noise.sigma, size=y.shape)\n    return y + eps, np.full_like(y, noise.sigma, dtype=float)\n\n\ndef simulate_equal_time_correlator(\n    x: Iterable[float],\n    *,\n    cfg: SimConfig,\n    dp: DiscreteParams,\n    noise: Optional[NoiseModel] = None,\n) -> Dict[str, Any]:\n    x = np.asarray(list(x), dtype=float)\n    y = _wightman(0.0, x, cfg, dp)\n    if noise is not None:\n        y, yerr = _add_noise(y, noise)\n    else:\n        yerr = np.zeros_like(y)\n    return {\n        \"protocol\": \"equal_time_correlator\",\n        \"x\": x.tolist(),\n        \"t\": 0.0,\n        \"y\": y.tolist(),\n        \"yerr\": yerr.tolist(),\n        \"meta\": {\"sim\": asdict(cfg), \"discrete\": asdict(dp), \"noise\": None if noise is None else asdict(noise)},\n    }\n\n\ndef simulate_time_correlator(\n    t: Iterable[float],\n    *,\n    x: float = 0.0,\n    cfg: SimConfig,\n    dp: DiscreteParams,\n    noise: Optional[NoiseModel] = None,\n) -> Dict[str, Any]:\n    t = np.asarray(list(t), dtype=float)\n    y = np.array([_wightman(float(tt), np.array([x]), cfg, dp)[0] for tt in t], dtype=float)\n    if noise is not None:\n        y, yerr = _add_noise(y, noise)\n    else:\n        yerr = np.zeros_like(y)\n    return {\n        \"protocol\": \"time_correlator\",\n        \"x\": float(x),\n        \"t\": t.tolist(),\n        \"y\": y.tolist(),\n        \"yerr\": yerr.tolist(),\n        \"meta\": {\"sim\": asdict(cfg), \"discrete\": asdict(dp), \"noise\": None if noise is None else asdict(noise)},\n    }\n\"\"\")\n\nchunks.append(\"\"\"\ndef _symplectic_eigs_2mode(V: np.ndarray) -> np.ndarray:\n    \\\"\\\"\\\"Symplectic eigenvalues for a 4x4 two-mode covariance matrix.\\\"\\\"\\\"\n    if V.shape != (4, 4):\n        raise ValueError(\"V must be 4x4\")\n    A, B, C = V[:2, :2], V[2:, 2:], V[:2, 2:]\n    detA, detB, detC, detV = np.linalg.det(A), np.linalg.det(B), np.linalg.det(C), np.linalg.det(V)\n    Delta = detA + detB + 2.0 * detC\n    rad = max(0.0, Delta * Delta - 4.0 * detV)\n    nu1 = np.sqrt(max(0.0, (Delta + np.sqrt(rad)) / 2.0))\n    nu2 = np.sqrt(max(0.0, (Delta - np.sqrt(rad)) / 2.0))\n    return np.array([nu1, nu2], dtype=float)\n\n\ndef simulate_logneg_two_mode(\n    x1: float,\n    x2: float,\n    *,\n    cfg: SimConfig,\n    dp: DiscreteParams,\n    noise: Optional[NoiseModel] = None,\n) -> Dict[str, Any]:\n    \\\"\\\"\\\"Two-mode logarithmic negativity from field/pi correlators at two points.\n\n    Uses a Gaussian-state (free field) covariance matrix with quadratures\n    (q1,p1,q2,p2). Partial transpose corresponds to p2 -> -p2.\n    \\\"\\\"\\\"\n    xs = np.array([0.0, abs(x2 - x1)], dtype=float)\n    qq = _wightman(0.0, xs, cfg, dp)\n    pp = _pi_pi(0.0, xs, cfg, dp)\n    # Covariance matrix: V_ij = <{R_i,R_j}>/2 with cross qp set to 0 (vacuum, equal time)\n    V = np.zeros((4, 4), dtype=float)\n    V[0, 0] = qq[0]\n    V[2, 2] = qq[0]\n    V[0, 2] = V[2, 0] = qq[1]\n    V[1, 1] = pp[0]\n    V[3, 3] = pp[0]\n    V[1, 3] = V[3, 1] = pp[1]\n\n    # Partial transpose on mode 2: flip sign of p2 correlations => Lambda=diag(1,1,1,-1)\n    Lambda = np.diag([1.0, 1.0, 1.0, -1.0])\n    Vpt = Lambda @ V @ Lambda\n    nus = _symplectic_eigs_2mode(Vpt)\n    nu_min = float(np.min(nus))\n    logneg = max(0.0, -np.log(2.0 * nu_min))\n\n    y = np.array([logneg], dtype=float)\n    if noise is not None:\n        y, yerr = _add_noise(y, noise)\n        logneg = float(y[0])\n        logneg_err = float(yerr[0])\n    else:\n        logneg_err = 0.0\n    return {\n        \"protocol\": \"logneg_two_mode\",\n        \"x1\": float(x1),\n        \"x2\": float(x2),\n        \"y\": logneg,\n        \"yerr\": logneg_err,\n        \"meta\": {\"sim\": asdict(cfg), \"discrete\": asdict(dp), \"noise\": None if noise is None else asdict(noise)},\n    }\n\"\"\")\n\nchunks.append(\"\"\"\ndef run_protocol(\n    protocol: ProtocolName,\n    *,\n    grid: Iterable[float] = (),\n    x: float = 0.0,\n    x1: float = 0.0,\n    x2: float = 1.0,\n    cfg: Optional[SimConfig] = None,\n    dp: Optional[DiscreteParams] = None,\n    noise: Optional[NoiseModel] = None,\n) -> Dict[str, Any]:\n    \\\"\\\"\\\"Unified entrypoint used by the pipeline/CLI.\n\n    grid means x-grid for equal-time correlator and t-grid for time correlator.\n    \\\"\\\"\\\"\n    cfg = SimConfig() if cfg is None else cfg\n    dp = DiscreteParams() if dp is None else dp\n    if protocol == \"equal_time_correlator\":\n        return simulate_equal_time_correlator(grid, cfg=cfg, dp=dp, noise=noise)\n    if protocol == \"time_correlator\":\n        return simulate_time_correlator(grid, x=x, cfg=cfg, dp=dp, noise=noise)\n    if protocol == \"logneg_two_mode\":\n        return simulate_logneg_two_mode(x1, x2, cfg=cfg, dp=dp, noise=noise)\n    raise ValueError(f\"Unknown protocol: {protocol}\")\n\n\ndef sweep_systematics(\n    protocol: ProtocolName,\n    *,\n    grid: Iterable[float],\n    cfgs: Iterable[SimConfig],\n    dp: DiscreteParams,\n    noise: Optional[NoiseModel] = None,\n) -> Dict[str, Any]:\n    \\\"\\\"\\\"Run a controlled sweep over finite-size/discretization configurations.\\\"\\\"\\\"\n    out = []\n    for i, cfg in enumerate(cfgs):\n        nm = None if noise is None else NoiseModel(sigma=noise.sigma, seed=noise.seed + i)\n        out.append(run_protocol(protocol, grid=grid, cfg=cfg, dp=dp, noise=nm))\n    return {\"protocol\": protocol, \"dp\": asdict(dp), \"runs\": out}\n\"\"\")\n\nfinal_text = '\\n'.join(block.strip('\\n') for block in chunks).strip() + '\\n'\ntarget_path.write_text(final_text, encoding='utf-8')\nprint('FILE_WRITTEN:src/dgpipe/simulations.py')\nprint('DIR_STATE:' + json.dumps(sorted(str(p.relative_to(Path(\"/mnt/data\"))) for p in target_path.parent.glob('*') if p.is_file())))\n",
      "container_id": "cntr_6949aff88f24819097f165c497ce475e074f2320f5d510c4",
      "outputs": [
        {
          "type": "logs",
          "logs": "FILE_WRITTEN:src/dgpipe/simulations.py\nDIR_STATE:[\"src/dgpipe/__init__.py\", \"src/dgpipe/cli.py\", \"src/dgpipe/models.py\", \"src/dgpipe/protocols.py\", \"src/dgpipe/simulations.py\"]\n"
        }
      ]
    },
    {
      "id": "msg_01103ad26d31d7a1006949b225454c81949a1fa8aed43b9c9b",
      "type": "message",
      "status": "completed",
      "content": [
        {
          "type": "output_text",
          "annotations": [],
          "logprobs": [],
          "text": "Implemented `src/dgpipe/simulations.py` providing lightweight controlled simulations (finite-size mode truncation, UV cutoff via microscopic spacing, modified dispersion), synthetic noisy datasets for correlators and a two-mode logarithmic-negativity diagnostic, plus unified protocol execution and systematic sweeps for calibration/inference testing."
        }
      ],
      "role": "assistant"
    }
  ],
  "codeResults": []
}